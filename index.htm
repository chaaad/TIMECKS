<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<link rel="icon" href="./favicon.ico"/>

<title>TIMECKS</title>

<style type="text/css">
@import url("https://fonts.cdnfonts.com/css/seven-segment");

/*prereq css begin*/
/*https://codepen.io*/
body {
  font-family: "Lato", sans-serif;
  font-size: 100%;
  font-style: normal;
  font-weight: 300;
}
ul {list-style: none; }
/*prereq css end*/


body.ringing {
  background: lightgray;
}
body.ringingFlash {
  background: pink;
}

i {
  font-style: normal;
  font-weight: bold;
  font-size: 24px;
}

.button {
  color: lightgray;
  background: #eee;
  border-radius: 8px;
  border: 2px solid chartreuse;
  cursor: pointer;
  user-select: none;

  &.squareButton {
    font-size: larger;
    margin: 8px;
    padding: 8px;
    color: gray;
    width: 20px;
    height: 20px;
    text-align: center;
  }
  &.leftButton {
    float: left;
  }
  &.rightButton {
    float: right;
  }

}

.roundButton {
  border-radius: 100%;
  border: 8px solid lightgray;
  background:lightgray;
  color: lightseagreen;
  margin-left: 8px;
  float: right;
  font-size: small;
  cursor: pointer;
  user-select: none;

  &#jwmCloseBut,
  &.delAlarmBut {
    color: red;
  }
}



div#trashCan {
  font-size: xx-large;
  line-height: 20px;
  border-color: lightgray;
  cursor: default;
  background: white;

  &.dropTrash {
    background: cyan;
  }
}

div#autoModeBut,
div#sortBut {
  line-height: 22px;
}

div#alarm {
  float: right;
  font-size: larger;
  padding: 8px;
  position: relative;

  div.alarmInstance {
    margin-bottom: 20px;

    * {
      cursor: pointer;
      user-select: none;
    }

    div.alarmInfo {
      max-width: 290px;
      overflow: auto;
      font-size: medium;
      background: #eee;
      padding: 8px;
      border-radius: 8px;
      margin-bottom: 8px;
      opacity: 50%;
    }

    span.alarmEnable {
      padding: 8px;
      padding: 8px;
      margin-right:8px;
      width: 20px;
      float: left;
    }

    span.alarmTime {
      width: 200px;
      letter-spacing: 2px;
      display: inline-block;
      font: bold 28px "Seven Segment", sans-serif;
      color: greenyellow;
      background: black;
      padding: 4px;
      border-radius: 2px;
      opacity: 25%;
      text-align: right;
/*
      &::before {
        content: "üï≠ ";
      }
*/
    }

    &.alarm-active {
      div.alarmInfo {
        font-weight: 600;
        background: black;
        color:white;
        opacity: 100%;
      }
      span.alarmEnable {
        color: chartreuse;
      }
      span.alarmTime {
        opacity: 100%;
      }
    }

    /*drag n drop*/
    &.dragging {
      opacity: 0.5;
    }

    &.dropAbove {
      border-top: 100px solid lightcyan; /*8px solid blue;*/
      border-bottom: "";
    }
    &.dropBelow {
      border-top: "";
      border-bottom: 100px solid lightcyan; /*8px solid blue;*/
    }

  }

  div#alarmCountdown {}

  span#addAlarmBut {
    margin-top: 8px;
  }

  div#alarmStatus {
    margin-bottom: 16px;

    div#ringerButs {
      margin-top: 16px;

      div#ringerSnooze,
      div#ringerOff {
        width: 100%;
        height:60px;
        line-height:60px;
        text-align: center;
        margin-top: 12px;
        color: darkgray;
        font-weight: bold;
        font-size: 24px;
      }
      div#ringerOff {}
      div#ringerSnooze {
        background: dimgray;

        &.but-active {
          color: chartreuse;
        }
      }
    }

    div#rSnzCountdown {}
  }

  .countdown {
    text-align: right;
    color:gray;
    margin-top: 8px;
    font-size: larger;
    font-weight: 800;
    color: cornflowerblue;
  }


  div#lowerAlarmButs {
    height:50px;
  }

  div#wakeLockEnable {
    float: right;
    margin-right: 0;
    line-height: 24px;

    &.on {
      background-color: lightskyblue;
    }
  }

} /*alarm*/



div#clockFace {
  width: 272px;
  height: 272px;
  background: #FDFAF7;
  border: 12px solid lightgray;
  border-radius: 100%;
  position: absolute;
  left: 30%;
  top: 50%;
  transform: translate(-50%, -50%);
  user-select: none;
  z-index: -1;

  div.hands,
  div.marker {
    position: absolute; top: 50%; left: 50%;
    transform-origin: 50% 50%;
  }

  div.hands::before {
    content: "";
    position: absolute;
    bottom: 50%;
    background: black;
    opacity: 33%;
    border-radius: 3px;
    transform: translateX(-50%);
  }

  div.hands.throt::before {
    background: blue;
  }

  div#minuteHand {
    transition: transform 1s linear
  }
  div#minuteHand::before {
    width: 6px;
    height: 110px;
  }

  div#hourHand::before {
    width: 10px;
    height: 70px;
  }

  div.marker {
    height: 118%;
    font-size: xx-large;
    color: white;
    &.on {
      color: black;
    }
  }

  div#spindle {
    width: 7px;
    height: 7px;
    background: #FDFAF7;
    border: 2px solid darkgray;
    border-radius: 100%;
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }

  span { /*tickmarks //each span has 2 tickmarks, uses ::before and ::after to create left and right, so only 30*/
    display: block;
    width: 1px;
    height: 95%;
    position: absolute; top: 50%; left: 50%;

    &::before,
    &::after {
      content: "";
      background: #A0A1A4;
      position: absolute;
      left: 0;
      width: 100%;
      height: 10px;
    }
    &::before {
      bottom: 0;
    }
    &::after {
      top: 0;
    }

    &.fives {
      &::after,
      &::before {
        height: 20px
      }
    }
  }


  ul#hourNumbers {
    height: 38%;
    position: absolute;
    bottom: 44%; /*changed (eyeballed) from 50%*/
    left: 50%;

    li {
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 50% 100%;

      i {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
    }
  }

  h2,
  h3 {
    letter-spacing: 1px;
    font-variant: small-caps;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }
  h2 {
    font-size: 8px;
    top: 29%;
    letter-spacing: 3px;
    font-weight: bold;
  }
  h3 {
    color: darkgray;
    top: 25%;
    font-size: x-large;
  }

  div#dtDisplay {
    font-size: 32px;
    font-weight: bold;
    color: #bbb;
    background: #eee;
    padding: 6px;
    border-radius: 12px;
    text-align: center;
    position: absolute;
    left: 50%;
    bottom: 25%;
    transform: translateX(-50%);

    &.pm {
      color: #eee;
      background: #bbb;
    }
  }

} /*clockface*/


/* MODAL
modded off of:
https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example#styles-css
-------------------------------*/
body.jw-modal-active { /*dont edit this css*/
  overflow: hidden; /* to hide main scrollbar when modal is active */
  div#jwmOverlay {
    display: block;
  }
}

div#jwmOverlay { /*background mask and overall container*/  /*edit this css carefully*/
  display: none; /* modals are hidden by default */
  position: fixed; /* modal container fixed across whole screen */
  inset: 0;
  z-index: 10000; /* z-index must be higher than everything else on the page */
  background-color: rgba(0, 0, 0, .75); /* semi-transparent black background exposed by padding */
  padding: 40px;
  overflow: auto; /* enables scrolling for tall modals */

  .jw-modal-item { /*modal instance*/
    font-size: larger;
    width: 420px;
    padding: 4px 8px;
    background: #fff;
    margin: 0px auto; /*center horiz*/
    border-radius: 16px;

    .open { /*dont edit this css*/
      display: block;
    }

    * {
      margin:12px;
    }

    div#jwmContent {
      margin-top: 50px;
    }
    div#jwmDescription {
      line-height: 28px;

      b {
        color: cornflowerblue;
        &.E {
          color: red;
        }
      }
    }
    input#jwmInput {
      width: 360px;
      font-size: xxx-large;
    }
    textarea#jwmTextarea {
      width: 360px;
      height: 100px;
      font-size: x-large;
    }

    /*button
    https://getcssscan.com/css-buttons-examples
    button-71
    */
    button {
      background-color: #0078d0;
      border: 0;
      border-radius: 56px;
      color: #fff;
      cursor: pointer;
      display: inline-block;
      font-family: system-ui,-apple-system,system-ui,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",sans-serif;
      font-size: 18px;
      font-weight: 600;
      outline: 0;
      padding: 16px 21px;
      position: relative;
      text-align: center;
      text-decoration: none;
      transition: all .3s;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    button:before {
      background-color: initial;
      background-image: linear-gradient(#fff 0, rgba(255, 255, 255, 0) 100%);
      border-radius: 125px;
      content: "";
      height: 50%;
      left: 4%;
      opacity: .5;
      position: absolute;
      top: 0;
      transition: all .3s;
      width: 92%;
    }

    button:hover {
      box-shadow: rgba(255, 255, 255, .2) 0 3px 15px inset, rgba(0, 0, 0, .1) 0 3px 5px, rgba(0, 0, 0, .1) 0 10px 13px;
      transform: scale(1.05);
    }

    @media (min-width: 768px) {
      button {
        padding: 16px 48px;
      }
    }
    /*button-71*/

    button.toggleable {
      background: chocolate;
      opacity: 40%
    }
    button.hilite {
      opacity: 100%;
    }

    button#jwmCancelBut {
      opacity: 50%
    }
  }

} /*jwmOverlay*/

</style>
</head>

<body>

<div id="editStgsBut" class="button squareButton leftButton" title="Settings (snooze duration)">Ô∏ô</div>
<div id="autoModeBut" class="button squareButton leftButton" title="Auto Mode">‚Æô</div>
<div id="sortBut" class="button squareButton leftButton" title="Sort alarms (ctrl-click to skip confirm)">‚Æù</div>
<div id="trashCan" class="button squareButton leftButton" title="Trash (drop unwanted alarm here)">üóë</div>

<div id="alarm">

  <div id="alarmTemplates">
    <div class="alarmInstance">
      <div class="alarmInfo" title="Edit info"></div>
      <span class="alarmEnable button" title="On/Off">‚èπ</span>
      <span class="alarmTime" title="Edit time"></span>
      <span class="roundButton delAlarmBut" title="Delete">‚úñ</span>
    </div>
  </div>

  <div id="alarmsContainer">
    <div id="alarmStatus">
      <div id="alarmCountdown" class="countdown"></div>
      <div id="ringerButs">
        <div id="ringerOff" class="button">OFF</div>
        <div id="ringerSnooze" class="button">SNOOZE</div>
        <div id="rSnzCountdown" class="countdown"></div>
      </div>
    </div>
  </div>
  <div id="lowerAlarmButs">
    <span id="addAlarmBut" class="roundButton" title="Add alarm">‚úö</span>
  </div>
  <div id="wakeLockEnable" class="button squareButton" title="Wake Lock">üîí</div>
</div>



<div id="clockFace">
  <h2>TIMECKS</h2>
  <h3></h3>

  <div id="dtDisplay"></div>

  <ul id="hourNumbers"></ul>

  <div id="minuteHand" class="hands"></div>
  <div id="hourHand" class="hands"></div>
  <div id="spindle"></div>

  <div id="alarmMarker" class="marker">‚Ä¢</div>
</div>


<div id="jwmOverlay">
  <div id="jwmModal" class="jw-modal-item">
    <span id="jwmCloseBut" class="roundButton">‚úñ</span>
    <div id="jwmContent">
      <div id="jwmDescription"></div>
      <input id="jwmInput"/>
      <textarea id="jwmTextarea"></textarea>
      <button id="jwmOkBut">OK</button>
      <button id="jwmNoBut" class="toggleable">No</button>
      <button id="jwmCancelBut">Cancel</button>
    </div>
  </div>
</div>


<script>
//clock, modded off of:
//https://codepen.io/opheliafl/pen/RaYbvL/

//favicon
//<a href="https://www.freepik.com/icon/alarm-clock_15092469#fromView=keyword&page=1&position=21&uuid=6aee3d4d-c58a-453e-8681-22457f5c0a34">Icon by sonnycandra</a>
//https://realfavicongenerator.net/

var audioClips= {
  beep: new Audio("https://cdn.freesound.org/previews/426/426892_7913959-lq.mp3"),
  buzz: new Audio("https://cdn.freesound.org/previews/696/696600_14786418-lq.mp3"),
  //oops: new Audio("https://cdn.freesound.org/previews/124/124897_1707984-lq.mp3"),
  slam: new Audio("https://cdn.freesound.org/previews/421/421472_3387258-lq.mp3"),
  clik: new Audio("https://cdn.freesound.org/previews/668/668985_14100561-lq.mp3"),
  rngr: new Audio("https://cdn.freesound.org/previews/246/246332_4486188-lq.mp3")
};


var clockFace_el= document.querySelector("DIV#clockFace");

function drawClock() {
  var rotate_n= 0;
  for (var i=0; i<30; i++) {
    let span_el= document.createElement("span");
    if (!(i%5)) span_el.className= "fives";
    span_el.style.transform= "translate(-50%,-50%) rotate(" +rotate_n +"deg)";
    clockFace_el.appendChild(span_el);
    rotate_n+= 6;
  }

  //createHourNumbers
  rotate_n= 0;
  var hr_n= 12;
  var ul_el= document.querySelector("UL#hourNumbers");
  for (i=0; i<12; i++) {
    let li_el= document.createElement("li");
    if (rotate_n) li_el.style.transform= "rotate(" +rotate_n +"deg)";
    ul_el.appendChild(li_el);

    let i_el= document.createElement("i");
    i_el.textContent= hr_n;
    if (rotate_n) i_el.style.transform= "translateX(-50%) rotate(-" +rotate_n +"deg)";
    li_el.appendChild(i_el);

    rotate_n+= 30;
    hr_n++;
    if (hr_n > 12) hr_n= 1;
  }
} //drawClock()

drawClock(); //init


var hand_els= {
  hourH: clockFace_el.querySelector("div#hourHand"),
  minuteH: clockFace_el.querySelector("div#minuteHand")
};
var dayOfWeek_el= clockFace_el.querySelector("h3");
var monthDay_el= document.getElementById("dtDisplay");

var clockMarker_el= clockFace_el.querySelector("div.marker");
clockMarker_el.style.display= "none";

var degO= {};
var h_inc= 360 /720;
var m_inc= 360 /60;

var clock_elapse_ms; //what we want the time to be, when compared to Date.now() we get sync_diff_ms
var clock_hr24;
var clock_ctdn_m;
var inc_ms; //variable increment

function drawHands() {
  hand_els.hourH.style.transform= "rotate(" +degO.hours + "deg)";
  hand_els.minuteH.style.transform= "rotate(" +degO.minutes +"deg)";
} //drawHands()

function startClock() {
  start_dtO= new Date();
  console.log("startClock", start_dtO.toLocaleTimeString());
  play_sound("clik");

  clock_hr24= start_dtO.getHours();
  var minutes= start_dtO.getMinutes(); //0-59
  clock_ctdn_m= 60 -minutes; //60-1

  degO.hours= 30 *clock_hr24 +0.5 *minutes;
  degO.minutes= 6 *minutes;
  drawHands();

  var minute_ms= start_dtO.getSeconds()*1000 +start_dtO.getMilliseconds();
  var topOfMinute_ms= 60000 -minute_ms;
  setTimeout(() => {
    inc_ms= 60000; //default 1 minute (flex)
    clock_elapse_ms= start_dtO.getTime() +topOfMinute_ms;
    advancedClock(); //1st
    mainloop(); //kickoff

    function mainloop() { //self-recursing
      setTimeout(() => {
        clock_elapse_ms+= 60000; //inc (fixed)
        if (advancedClock()) mainloop(); //recurse-->
      }, inc_ms); //inc (flex)
    } //mainloop()

  }, topOfMinute_ms);

  drawDay(start_dtO, clock_hr24);
} //startClock()

var monthDay_str;
function drawDay(dtO, h24) {
  dayOfWeek_el.textContent= dtO.toLocaleDateString("en-US", {weekday:"short"}).toUpperCase(); //eg. "Tue" .. "TUE"

  monthDay_str= (dtO.getMonth()+1) +"/" +dtO.getDate(); //0-11 (+1), 1-31
  monthDay_el.textContent= monthDay_str;
  monthDay_el.classList[h24>=12?"add":"remove"]("pm");
} //drawDay()


var sync_diff_ms; //can debug in console
var unthrottle_flag;
var pcDraft_str;

function advancedClock() { //+1 clock minute
  degO.hours+= h_inc;
  degO.minutes+= m_inc;
  drawHands();

  if (alarm_flag) {
    alarm_ctdn_m--; //inc-
    checkAlarm();
  } else if (snooze_ctdn_m) {
    snooze_ctdn_m--; //inc-
    checkSnooze();
  }

  if (auto_mode && autoTopAI_el) {
    autoMode_ctdn_m--;
    if (autoMode_ctdn_m == 0) {
      if (autoTopAI_el!=active_aI_el) auto_procAlarms(); //dont resort if alarm is active
      else autoProcPending_flag= true;
    }
  }

  if (pcDraft_str= localStorage.getItem("importedAlarm")) importAlarm(); //like a poll, for "importedAlarm" in localStorage

  var sync_dtO= new Date();
  sync_diff_ms= clock_elapse_ms -sync_dtO.getTime();

  //slept
  if (sync_diff_ms <= -120000 ) { //extremely slow, 2 or more minutes (prob from sleep)
    var diff_m= Math.floor(sync_diff_ms /60000);
    //.. note: Math.floor returns lower integer, with negative number, the absolute is the higher integer
    if (alarm_flag) {
      alarm_ctdn_m+= diff_m; //subtract (sync_diff_ms is negative)
      checkAlarm();
      if (alarm_flag && !wakeLockObj && !document.hidden) setWakeLock(); //on
    } else if (snooze_ctdn_m) {
      snooze_ctdn_m+= diff_m; //subtract (sync_diff_ms is negative)
      if (snooze_ctdn_m < 0) snooze_ctdn_m= 0;
      checkSnooze();
    }
    console.log("SLEPT", g_fmatTime(sync_dtO), g_fmatSDM())
    startClock(); //restart
    return false; //abort //-->
    //.. and no mainloop, like clearTimeout for a self-cursing fn
  }


  clock_ctdn_m--; //inc-
  //.. simpler than.. (.getMinutes, then compensate if clock lil slow)
  if (clock_ctdn_m < 1) { //top of hr
    //.. uneffected if clock lil slow
    clock_ctdn_m= 60; //wrap (reset)

    //dst
    clock_hr24= (clock_hr24+1) %24; //inc wrap
    let hrs24= sync_dtO.getHours();
    if (sync_diff_ms > 0) hrs24= (hrs24+1) %24; //inc wrap
    //.. if clock lil fast (before the actual minute), compensate actual +1hr

    //https://www.timeanddate.com/time/dst/transition.html
    if (clock_hr24 != hrs24) { //DST change?
      let diff_hr= hrs24- clock_hr24; // +- 1
      console.log("DST change", diff_hr, g_fmatTime(sync_dtO), g_fmatSDM(), hrs24, clock_hr24)
      play_sound("clik");
      degO.hours+= diff_hr *h_inc *60;
      drawHands();
      clock_hr24= hrs24; //reset
      //.. 2am bacomes 3am (forward) or 1am (back)
    } //DST change

    //am/pm, monthday
    if (hrs24 %12 == 0) drawDay(sync_dtO, hrs24); //noon or midnite
    //.. uneffected by DST change (which happens at '2am')

//console.log("TOP OF HR", g_fmatTime(sync_dtO))
  } //top of hr


  //inc_ms adjust
  if (sync_diff_ms) { //not 0

    if (sync_diff_ms <= -60000 ) { //very slow, 1-2 minute (prob from throttling)
      //.. prob doesnt happen, hope not
console.log("JUMP clock ahead 1 minute", g_fmatTime(sync_dtO), g_fmatSDM())
      play_sound("clik");
      clock_elapse_ms+= 60000; //big adjust
      advancedClock(); //add clock minute
      //.. orig mainloop fires

    } else if (sync_diff_ms>100 || unthrottle_flag) { //unthrottle or unthrottle+1min
      inc_ms= 60000 +sync_diff_ms; //big adjust +, then small adjust -
      if (sync_diff_ms > 100) {
        unthrottle_flag= true;
        hand_els.minuteH.classList.add("throt");
        play_sound("clik", 2, 500);
//console.log("unthrot", g_fmatTime(sync_dtO), g_fmatSDM(), inc_ms)
      } else {
        unthrottle_flag= false;
        hand_els.minuteH.classList.remove("throt");
        if (alarm_flag && !wakeLockObj && !document.hidden) setWakeLock(); //on
      }

    } else { //tweak inc_ms
      inc_ms+= sync_diff_ms; //small adjust //swerving, but dont go off the road
      if (inc_ms < 30000) inc_ms= 30000; //not too small
    }

    //when browser throttled, mainloop 'minute' can be slow (over 7 secs seen), also screen rendering paused
    //https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#reasons_for_delays_longer_than_specified

    //when system sleeps, everything stops

//console.log("advanced Clock",  g_fmatTime(sync_dtO), g_fmatSDM(), inc_ms )
  } //sync_diff_ms

  return true; //advanced, yes
} //advancedClock()

//console.log utils
function g_fmatTime(dtO= new Date()) { //formatted time string, eg. "@11:48:22.005" //shows ms
  return "@" +(dtO.getHours()%12||12) +":" +dtO.toISOString().substring(14, 23);
  //.. toISOString(), eg. "2011-10-05T14:48:22.005Z"
} //g_fmatTime()
function g_fmatSDM() { //formatted sync_diff_ms string, eg. "dif+12"
  var str= "dif";
  if (sync_diff_ms > 0) str+= "+";
  return str +sync_diff_ms;
} //g_fmatSDM()


var body_el= document.querySelector("body");

//div#alarm
var editStgs_el= document.querySelector("div#editStgsBut");
var auto_el= document.querySelector("div#autoModeBut");
var sort_el= document.querySelector("div#sortBut");
var trash_el= document.querySelector("div#trashCan");

var alarmTemplates_el= document.querySelector("div#alarmTemplates");
alarmTemplates_el.style.display= "none";

var alarmsCont_el= document.querySelector("div#alarmsContainer");

var template_alarmInst_el= alarmTemplates_el.querySelector("div.alarmInstance");
var alarmInst_el;
var active_aI_el;

var alarmStatus_el= document.querySelector("div#alarmStatus");
alarmStatus_el.style.display= "none";
var alarmCountdown_el= alarmStatus_el.querySelector("div#alarmCountdown");

var wlEnable_el= document.querySelector("div#wakeLockEnable");


var snooze_def_num= (localStorage.getItem("snooze_num") || 5) *1; //default 5

document.addEventListener("keyup", evt => { //capture any keyup
  if (!document.body.classList.contains("jw-modal-active")) { //modal inactive
    if (evt.key == "-") {
      alarmInst_el= alarmsCont_el.querySelector("div.alarmInstance"); //always the standard (1st) alarm
      editAlarmTime();
    } else if (ringerButs_el.style.display == "block") {
      if (evt.key == " ") stopRinger("snooze");
      else if (evt.key.search(/Enter|Escape/) > -1) stopRinger();
    }
  }
});

editStgs_el.addEventListener("click", editSettings);
auto_el.addEventListener("click", setAutoMode);
sort_el.addEventListener("click", sortAlarms);

alarmsCont_el.addEventListener("click", evt => {
  var targ_el= evt.target;
  alarmInst_el= targ_el.closest("div.alarmInstance");

  if (targ_el.classList.contains("alarmEnable")) {
    stopRinger(); //if needed
    setAlarm(alarmInst_el==active_aI_el?false:alarmInst_el); //toggle

  } else if (targ_el.classList.contains("alarmInfo")) {
    editAlarmInfo();

  } else if (targ_el.classList.contains("alarmTime")) {
    editAlarmTime();

  } else if (targ_el.classList.contains("delAlarmBut")) {
    deleteAlarm();
  }
});

document.querySelector("span#addAlarmBut").addEventListener("click", addAlarm);

wlEnable_el.addEventListener("click", setWakeLock);

//https://developer.chrome.com/blog/new-in-chrome-79/#wake-lock
var wakeLockObj;
async function requestWakeLock() {
	try {
		wakeLockObj= await navigator.wakeLock.request();
      wlEnable_el.classList.add("on");
      //localStorage.setItem("wake_lock", true);

  		wakeLockObj.addEventListener("release", () => {
  			wakeLockObj= undefined; //clear global
        wlEnable_el.classList.remove("on");
        //localStorage.setItem("wake_lock", false);
  		});
	} catch (err) {console.log(err.message); }
} //requestWakeLock()

async function releaseWakeLock() { //note: minimizing of browser, or unfocus of browser tab, will automatically release wakeLock
	if (!wakeLockObj) return; //-->
  try {await wakeLockObj.release(); }
	catch (err) {console.log(err.message); }
} //releaseWakeLock()

//if (localStorage.getItem("wake_lock")) setWakeLock(); //turn on by default

async function setWakeLock() {
	if (wakeLockObj) await releaseWakeLock(); //off
	else await requestWakeLock(); //on
} //setWakeLock()


function editSettings() { //just snooze duration
  jm.prompt("Snooze duration (minutes, 1-30)", snooze_def_num, resp => {
    if (resp == null) return; //-->
    var v_num= resp *1;
    if (v_num == snooze_def_num) return; //same, do nothing //-->
    if (isNaN(v_num) || v_num<1 || v_num>30) {
      jm.error('Snooze must be 1-30 minutes<br><br>Your input:<b class="E">' +resp +'</b>', () => {
        editSettings(); //try again
      });
    } else {
      snooze_def_num= v_num;
      localStorage.setItem("snooze_num", snooze_def_num);
    }
  });
} //editSettings()


var auto_mode= localStorage.getItem("auto_mode") || false;
var autoMode_ctdn_m;
var autoTopAI_el;
var autoProcPending_flag;

function setAutoMode() {
  jm.prompt_boolean('Auto Mode?<br>No manual reordering of alarms, the alarm list will automatically be sorted by time. Also, the first alarm will always self-activate', auto_mode, resp => {
    if (resp==null || resp==auto_mode) return;
    auto_mode= resp;
    exec_setAutoMode();
    localStorage.setItem("auto_mode", auto_mode);
  });
} //setAutoMode()

function exec_setAutoMode() { //on or off
  var displ_str= auto_mode ? "none" : "";
  showEl(sort_el, displ_str);
  showEl(trash_el, displ_str);

  get_aIList().forEach(aI_el => aI_el.draggable= !auto_mode );

  if (auto_mode) auto_procAlarms();
} //exec_setAutoMode()

function auto_procAlarms() { //sort alarms, and activate top alarm
  var aI_arr= exec_sortAlarms();

  autoTopAI_el= aI_arr[0];
  if (autoTopAI_el) {
    autoMode_ctdn_m= Math.ceil((autoTopAI_el.tmp_ms -new Date()) /60000);
    if (autoMode_ctdn_m < 1) autoMode_ctdn_m= 1;
    if (autoTopAI_el != active_aI_el) setAlarm(autoTopAI_el);
  }
} //auto_procAlarms()


var alarm_flag;
var alarm_ctdn_m;
var alarm_dtO;
var hTimO;

function startAlarms() {
  var alarms_json= localStorage.getItem("alarms");
  var alarms_arr= [{t:"12:00 AM"}]; //empty default
  if (alarms_json) try {alarms_arr= JSON.parse(alarms_json); } catch (err) {}

  alarms_arr.forEach((a_obj, i) => {
    aInst_el= template_alarmInst_el.cloneNode(true); //clone
    alarmsCont_el.appendChild(aInst_el); //add
    add_instanceShortcutEls(aInst_el);
    aInst_el.ELO.aInfo.innerHTML= a_obj.i || "";
    aInst_el.ELO.aTime.textContent= a_obj.t;
    if (a_obj.a) alarmInst_el= aInst_el; //active
  });

  if (auto_mode) exec_setAutoMode();
  else if (alarmInst_el) setAlarm(alarmInst_el); //active on init
  alarmDragger();
} //startAlarms()

function add_instanceShortcutEls(aI_el) { //.dataset only stores strings
  //breaks html/js laws, but as far as js only goes, an element is just an object
  aI_el.ELO= {
    aInfo: aI_el.querySelector("div.alarmInfo"),
    aEnable: aI_el.querySelector("span.alarmEnable"),
    aTime: aI_el.querySelector("span.alarmTime")
  };
} //add_instanceShortcutEls()

function editAlarmInfo() {
  var t_str= alarmInst_el.ELO.aTime.textContent;
  var info_str= alarmInst_el.ELO.aInfo.innerHTML.replaceAll("<br>", "\n");
  jm.prompt_textarea('Alarm info (html allowed)<br>Time:<b>' +t_str +'</b>', info_str, resp => {
    if (resp==null || resp==info_str) return; //-->
    info_str= resp.trim();
    if (info_str.length > 80) {
      jm.error("Info length is up to 80 chars. Your text is " +info_str.length +" chars", () => {
        editAlarmInfo(info_str); //try again (and we dont throw away what you typed in)
      });
    } else {
      alarmInst_el.ELO.aInfo.innerHTML= info_str.replaceAll("\n", "<br>");
      saveAlarms();
    }
  });
} //editAlarmInfo()


function editAlarmTime(NEW_str) {
  var alarm_str= NEW_str ? "12:00" : alarmInst_el.ELO.aTime.textContent;
  var livePreview_el;

  function pop_prompt() {
    var new_alarm_obj= proc_alarmTimeText(jm._els.Input.value, "preview");
    livePreview_el.innerHTML= new_alarm_obj ? (new_alarm_obj.time +"<br>" +new_alarm_obj.ahead) : "";
  }

  var prom_str= g_promStr(NEW_str, alarm_str);
  time_prompt();

  function time_prompt() {
    jm.prompt(prom_str, alarm_str, {
      //jm custom hooks object

      begin_cb: () => {
        livePreview_el= jm._els.Description.querySelector(".livePreview");
        pop_prompt();
      },

      Input_keyup: evt => { //or "aliasIO_keyup" would work also
        pop_prompt();
      },

      end_cb: resp => {
        if (resp==null || (resp==alarm_str && !NEW_str)) return; //-->
        var mod_alarm_str= resp;

        //proc input str
        var mod_alarm_obj;
        if (mod_alarm_obj= proc_alarmTimeText(mod_alarm_str, undefined, time_prompt)) {
          //.. passed time_prompt() as err_cb, try again

          if (NEW_str) exec_addAlarm();
          alarmInst_el.ELO.aTime.textContent= mod_alarm_obj.time;
          if (alarmInst_el==active_aI_el || !active_aI_el) {
            stopRinger(); //if needed
            setAlarm(alarmInst_el);
          } else if (!auto_mode) {
            saveAlarms();
          }
          if (auto_mode) {
            auto_procAlarms();
            saveAlarms();
          }
          if (NEW_str) editAlarmInfo();
        }
      }
    });
  } //time_prompt()

} //editAlarmTime()

function addAlarm() {
  editAlarmTime("NEW");
} //addAlarm()

function exec_addAlarm() {
  var clAlrmInst_el= template_alarmInst_el.cloneNode(true); //clone
  add_instanceShortcutEls(clAlrmInst_el);
  alarmsCont_el.appendChild(clAlrmInst_el); //add
  play_sound("beep", 2);
  alarmInst_el= clAlrmInst_el;
} //exec_addAlarm()

function importAlarm() {
  localStorage.removeItem("importedAlarm");
  var spl_ar;
  var pc_alarm_obj;
  var ct= 0;
  pcDraft_str.split("\n").forEach(pcTm_str => {
    spl_ar= pcTm_str.split("|");
    if (spl_ar.length == 5) { //cursory test
//console.log("pcTm_str, split",spl_ar);
// ?pc_draft=Schenectady%20Mohawk%20Giants|508-11|WED|3/12|6:53pm
//      0                                   1     2     3   4
      if (pc_alarm_obj= proc_alarmTimeText(spl_ar[3] +" " +spl_ar[4] +"-20")) { // -20 minutes
        ct++;
        exec_addAlarm();

        //tid= spl_ar[1]
        var html_str= spl_ar[2] +' <br>' +spl_ar[0];
        alarmInst_el.ELO.aInfo.innerHTML= html_str;

        alarmInst_el.ELO.aTime.textContent= pc_alarm_obj.time;
      }
    }
    if (ct) {
      if (auto_mode) auto_procAlarms();
      saveAlarms();
    }
  });
} //importAlarm()

function deleteAlarm() {
  var prom_str= g_promStr();

  jm.prompt_boolean('Delete?<br>' +prom_str, 0, resp => {
    if (resp != true) return; //null or false //-->
    exec_deleteAlarm();
  });
} //deleteAlarm()

function exec_deleteAlarm() {
  alarmInst_el.remove();
  if (alarmInst_el== active_aI_el) setAlarm(false); //if alarm was on, turn off
  if (auto_mode || alarmInst_el!=active_aI_el) {
    if (auto_mode) auto_procAlarms();
    saveAlarms();
  }
  play_sound("slam", 2);
} //exec_deleteAlarm()


function g_promStr(str, t_str) {
  if (!str) str= alarmInst_el.ELO.aInfo.textContent.substring(0, 40);
  if (!t_str) t_str= alarmInst_el.ELO.aTime.textContent;
  return 'Alarm info:<b>' +str +'</b><br>Time:<b class="livePreview">' +t_str +'</b>';
} //g_promStr()

var DoW2_arr= "SU,MO,TU,WE,TH,FR,SA".split(",");
var DoW_arr= "SUN,MON,TUE,WED,THU,FRI,SAT".split(",");

function proc_alarmTimeText(input_str, preview_flag, err_cb) { //returns truthy if raw_str is good
  //.. geared toward keypad input, with some shortcuts baked in
  input_str= input_str.trim();
  var raw_str= input_str.toUpperCase();

  var time_dtO= new Date();
  var moDaO;
  if (raw_str.includes("/") || raw_str.search(/^[SMTWF]/)==0) {
    raw_str+= " ";
    let index= raw_str.indexOf(" ");
    let mD_str= raw_str.substring(0, index);
    raw_str= raw_str.substring(index +1);
    if (!raw_str) raw_str= "12"; //default midnite
    moDaO= valid_moDa(mD_str); if (!moDaO) return err("bad month/day or DoW"); //-->
  }

  var time_str;
  var offset_str, offsetMod_str;
  [time_str, offset_str]= raw_str.split(/\+|-/);
  if (offset_str) offsetMod_str= raw_str[time_str.length]; //1 char,  = or -

  var raw_hTimO;
  if (time_str) {
    raw_hTimO= g_procRawTime(time_str);

    if (raw_hTimO.h > 12) return err('bad hour:<b class="E">' +raw_hTimO.h +'"</b>max is 12'); //-->
    if (raw_hTimO.m > 59) return err('bad minute:<b class="E">' +raw_hTimO.m +'</b>max is 59'); //-->

    raw_hTimO.p= time_str.search(/P|\*/) > -1; //chars: P *
    let rawAmPm_flag= raw_hTimO.p || time_str.search(/A/) > -1; //chars: A (AM)

    if (raw_hTimO.h == 0) { //auto-derive hr from now
        let h= time_dtO.getHours(); //0-23
        if (!rawAmPm_flag) raw_hTimO.p= (h >= 12);
        let m= time_dtO.getMinutes();
        if (raw_hTimO.m <= m) { //if rawminutes less than nowminutes, goto next hour
          h++; //inc
          if (h == 24) h= 0; //wrap
          raw_hTimO.h= h;
          proc_24to12(raw_hTimO);
        }
    }

  } else {
    raw_hTimO= {
      h: time_dtO.getHours(), //0-23
      m: time_dtO.getMinutes()
    };
    proc_24to12(raw_hTimO);
  }

  if (moDaO) raw_hTimO.MD= moDaO;

  time_dtO= g_fromHTimeToDateObj(raw_hTimO);

  var ahead_str= "";

  var ofsO;
  if (offset_str) {
    ofsO= g_procRawTime(offset_str);
    if (ofsO.h +ofsO.m < 1) return err("0 hour+minute (offset mode)"); //-->

    var time_ms= time_dtO.getTime();
    var sgn_num= offsetMod_str=="+" ? 1 : -1;

    if (ofsO.m) {
      if (ofsO.m > 59) return err("ahead minutes:<b>" +ofsO.m +"</b>max is 59"); //-->
      time_ms+= sgn_num *ofsO.m *60000; //60*1000 //add mns
    }
    if (ofsO.h) {
      let max_h= ofsO.m ? 23 : 24; //max 24 hrs ahead
      if (ofsO.h > max_h) return err("ahead hours:<b>" +ofsO.h +"</b>max is " +max_h); //-->
      time_ms+= sgn_num *ofsO.h *3600000; //60*60*1000 //add hrs
    }

    ahead_str= "(OFFSET: ";
    ahead_str+= get_fmatHTime_str(raw_hTimO) + " ";
    ahead_str+= offsetMod_str +g_untilStr(ofsO.m, ofsO.h) +")";

    time_dtO= new Date(time_ms); //is DST handled here by js date ?

  } else { //no offset given, derive for ahead_str
    let ahead_ms= time_dtO -new Date();
    ahead_str= "(in: " +g_untilStr(Math.round(ahead_ms /60000)) +")";
  }

  function g_procRawTime(str) {
    var h= m= 0;

    var split_arr= str.split(/:|\./);
    if (split_arr.length > 1) { //contains ":" or ".", explicit hrs and mns
      h= get_nstr(split_arr[0]) *1;
      m= get_nstr(split_arr[1]) *1;

    } else { //special shorthand
      var hm_str= get_nstr(str);
      var L= hm_str.length;
      if (hm_str[0]=="0" || L<=2) { //1-2 digits, or starts with "0"
        if (hm_str[0] == "0") { //starts with "0"
          //minutes mode, eg. "01" is 1 mn, "012" is 12 mns
          //just mns, hr 0
          m= hm_str *1;
        } else { //1-2 digits
          let n= hm_str *1;
          if (n <= 12) h= n; //just hr, mn 0
          else m= n; //just mn, hr 0
        }
      } else { //3-4 digits
        //.. w "*" for 'pm', eg. 1220 .. 12:20am, or 420* .. 4:20pm
        h= hm_str.substring(0, L -2) *1; //begining, up to last 2 digits
        m= hm_str.substring(L -2) *1; //last 2 digits
      }
    }
    return {h:h, m:m};
  } //g_procRawTime()

  var _hTimO= {
    h: time_dtO.getHours(), //0-23
    m: time_dtO.getMinutes()
  };
  proc_24to12(_hTimO);
  if (moDaO) _hTimO.MD= moDaO;

  if (!preview_flag) hTimO= _hTimO;

  //success
  return {
    time: get_fmatHTime_str(_hTimO),
    ahead: ahead_str,
    ms: time_dtO.getTime()
  };


  function get_nstr(str) {
    return (str.match(/\d+/) || ["0"])[0]; //gets 'first' number, ignores rest //if none, will return "0"
    //note: "0" is truth-y
  }

  function get_fmatHTime_str(tO) {
    var str= "";
    if (tO.MD) str= (tO.MD.DoW ? tO.MD.DoW : ((tO.MD.r_mo || tO.MD.mo) +"/" +tO.MD.da)) +" ";
    return str +tO.h +":" +String(tO.m).padStart(2, "0")  +(tO.p?" PM":" AM"); //human time
  } //get_fmatHTime_str()

  function proc_24to12(tO) { //to human
    tO.p= tO.h >= 12;
    var h= tO.h;
    if (h > 12) h-= 12;
    else if (h == 0) h= 12;
    tO.h= h;
  }

  function g_fromHTimeToDateObj(tO) { //from human time 12:59am/pm, to computer time 23:59
    var dtO= new Date(); //dateobj, using the date, but will reset the time
    var copy_dtO= new Date(dtO);
    var diff_ms;

    if (tO.MD) {
      dtO.setMonth(tO.MD.mo -1);
      dtO.setDate(tO.MD.da);
      diff_ms= dtO -copy_dtO;
      if (diff_ms < 0) { //if reqTime less than nowTime, goto next year
        dtO.setFullYear(dtO.getFullYear() +1); //+1 year
      }
    }

    dtO.setSeconds(0);
    dtO.setMinutes(tO.m);

    var h= tO.h;
    if (h == 12) h= 0;
    if (tO.p) h+= 12;
    dtO.setHours(h);

    diff_ms= dtO -copy_dtO;
    if (diff_ms < 1) { //if reqTime less than nowTime, goto next day
      dtO.setDate(dtO.getDate() +1); //+1 day //is DST handled here by js date ?
    }

    return dtO;
  } //g_fromHTimeToDateObj()

  function err(err_str) {
    if (preview_flag) return; //-->
    jm.error('Alarm time error caused by<br>' +err_str +'<br><br>Your raw input: <b class="E">' +input_str +'</b>', err_cb);
    //multiple errors are not returned, only the first error encountered
  }

  function valid_moDa(mD_str) {
    var raw_month_str;
    var DoW_str;
    if (mD_str.includes("/")) {
      var month, day;
      [month, day]= mD_str.split("/");

      month*= 1;
      if (isNaN(month) || month<1 || month>12) {
        raw_month_str= "?"; //month wildcard
        month= time_dtO.getMonth() +1; //no month? assume this month
      }

      day*= 1;
      if (isNaN(day) || day<1 || day>31) day= 1; //not verifying against number of days in month

    } else if (mD_str.search(/^[SMTWF]/) == 0) { //Day of Week
      var f2_str= mD_str.substring(0, 2);
      if (f2_str.length < 2) return; //-->
      var raw_DoW_n= DoW2_arr.indexOf(f2_str);
      if (raw_DoW_n < 0) return; //-->
      DoW_str= DoW_arr[raw_DoW_n];
      var copy_dtO= new Date(time_dtO); //lets not change time_dtO here
      var DoW_diff_n= raw_DoW_n -copy_dtO.getDay(); //.getDay(), could be called getDoW, returns 0-6 (sun-sat)
      if (DoW_diff_n) {
        if (DoW_diff_n < 0) DoW_diff_n+= 7;
        copy_dtO.setDate(copy_dtO.getDate() +DoW_diff_n); //getDate() will change month/day correctly
      }
      month= copy_dtO.getMonth() +1;
      day= copy_dtO.getDate(); //.getDate(), could be called getDay, returns 1-31
    } else {
      return; //--> fail
    }

    var o= {
      mo: month,
      da: day
    };
    if (DoW_str) o.DoW= DoW_str;
    if (raw_month_str) o.r_mo= raw_month_str;

    //success
    return o;
  } //valid_moDa()

} //proc_alarmTimeText()

function setAlarm(aI_el) {
  var flag= !!aI_el; //to boolean
  if (flag) {
    var alarm_str= aI_el.ELO.aTime.textContent;
    var alarm_obj= proc_alarmTimeText(alarm_str);
    if (!alarm_obj) flag= false;

    if (flag) {
      var alm_ctdn_ms= alarm_obj.ms -new Date(); //is DST handled here by js date ?
      if (alm_ctdn_ms < 60000) alm_ctdn_ms= 60000; //minimum of 1 minute
      alarm_ctdn_m= Math.ceil(alm_ctdn_ms /60000);
      checkAlarm();
    } //flag w good proc_alarmTimeText
  } //flag

  if (active_aI_el) { //prev alarm off
    active_aI_el.classList.remove("alarm-active");
  }

  if (flag) { //alarm on
    alarm_flag= true;
    active_aI_el= aI_el;
    aI_el.classList.add("alarm-active");
    aI_el.after(alarmStatus_el);
    alarmStatus_el.style.display= "block";
    alarmCountdown_el.style.display= "block";
    drawMarker(alarm_ctdn_m < 1440);
    play_sound("beep");
    if (!wakeLockObj) setWakeLock(); //on

  } else { //alarm off
    alarm_ctdn_m= 0;

    alarm_flag= false;
    active_aI_el= undefined;
    stopRinger(); //if needed
    alarmStatus_el.style.display= "none";
    drawMarker(false);
    play_sound("slam");
    if (wakeLockObj) setWakeLock(); //off
  }

  if (!auto_mode) {
    saveAlarms();
  } else if (autoProcPending_flag) {
    autoProcPending_flag= false;
    auto_procAlarms();
  }

} //setAlarm()

function drawMarker(flag) {
  if (flag == false) {
    clockMarker_el.style.display= "none";
  } else {
    clockMarker_el.style.display= "block";
    clockMarker_el.style.transform= "translate(-50%, -50%) rotate(" +(30*hTimO.h +0.5*hTimO.m) +"deg)";
    clockMarker_el.classList[(alarm_ctdn_m<720?"add":"remove")]("on");
  }
} //drawMarker()

function checkAlarm() {
  if (alarm_ctdn_m < 1) { //end alarm countdown
    alarm_flag= false;
    alarmCountdown_el.style.display= "none";
    startRinger();
  } else {
    alarmCountdown_el.textContent= g_untilStr(alarm_ctdn_m);
    if (alarm_ctdn_m==719 || alarm_ctdn_m==1439) drawMarker();
  }
} //checkAlarm()


function get_aIList() {
  return alarmsCont_el.querySelectorAll("div.alarmInstance");
} //get_aIList()

function saveAlarms() {
  var alarms_arr= [];
  var a_obj;
  var info_str;
  get_aIList().forEach(aI_el => {
    a_obj= {t: aI_el.ELO.aTime.textContent};
    if (info_str= aI_el.ELO.aInfo.innerHTML) a_obj.i= info_str;
    if (aI_el.classList.contains("alarm-active")) a_obj.a= 1;
    alarms_arr.push(a_obj);
  });
  localStorage.setItem("alarms", JSON.stringify(alarms_arr));
} //saveAlarms()

function sortAlarms(evt) {
  if (evt.ctrlKey) {
    exec_sortAlarms();

  } else {
    jm.confirm('Sort alarms by date/time?', resp => {
      if (resp) exec_sortAlarms();
    });
  }
} //sortAlarms()

function exec_sortAlarms() {
  var aI_nL= get_aIList();
  var t_str, alarm_obj, ms;
  aI_nL.forEach(aI_el => { //pop .tmp_ms for each alarm
    ms= 0;
    if (t_str= aI_el.ELO.aTime.textContent) {
      if (alarm_obj= proc_alarmTimeText(aI_el.ELO.aTime.textContent, "preview")) ms= alarm_obj.ms;
    }
    aI_el.tmp_ms= ms; //breakin the law, unsanctioned attribute
  });

  var aI_arr= [...aI_nL]; //to plain js array
  aI_arr.sort((a, b) => a.tmp_ms > b.tmp_ms ? 1 : -1)
    .forEach(aI_el => alarmsCont_el.appendChild(aI_el))
  ;
  if (active_aI_el) active_aI_el.after(alarmStatus_el);
  if (!auto_mode) saveAlarms();
  play_sound("clik");
  return aI_arr; //bonus get
} //exec_sortAlarms()

function alarmDragger() {
  //dragndrop, modded off of:
  //https://www.w3resource.com/javascript-exercises/event/javascript-event-handling-exercise-6.php

  var dragAl_el;
  var prev_dragOver_el;

  // Add event listeners for drag and drop events
  alarmsCont_el.addEventListener("dragstart", dragStart);
  document.addEventListener("dragover", dragOver);
  document.addEventListener("drop", drop); //user can drop anywhere, listening only on dragList only doesnt cut it
  document.addEventListener("click", evt => {if (dragAl_el) clear("fully"); }); //recover after a failed drop

  function dragStart(evt) {
    if (dragAl_el) clear("fully"); //recover after a failed drop

    dragAl_el= evt.target;
    dragAl_el.classList.add("dragging");
    //evt.dataTransfer.effectAllowed= "move"; //what does this even do? seems unneeded for reorder

    get_aIList().forEach((aI_el, i) => aI_el.d_index= i); //current order
  } //dragStart()

  function dragOver(evt) {
    if (!dragAl_el) return; //-->

    evt.preventDefault();
    var dragOver_el= evt.target;
    var dragOvAl_el;

    if (dragOver_el == trash_el) { //trash can
      if (dragOver_el == prev_dragOver_el) return; //-->
      if (prev_dragOver_el) clear();
      dragOver_el.classList.add("dropTrash");

      prev_dragOver_el= dragOver_el;

    } else { //not trashcan
      if (prev_dragOver_el && prev_dragOver_el == trash_el) { //trash can
        clear();
        prev_dragOver_el= undefined;
      }

      if (dragOvAl_el= dragOver_el.closest("div.alarmInstance")) { //alarm instance (reorder)
        if (prev_dragOver_el) clear();
        if (dragOvAl_el == dragAl_el) return; //-->
        //evt.dataTransfer.dropEffect= "move"; //what does this do? seems unneeded for reorder

        const boundingRect= dragOvAl_el.getBoundingClientRect();
        const offset_y= boundingRect.y +(boundingRect.height /2);
        if (evt.clientY-offset_y < 0) {
          if (dragOvAl_el.d_index-1 != dragAl_el.d_index) dragOvAl_el.classList.add("dropAbove");
        } else {
          if (dragOvAl_el.d_index+1 != dragAl_el.d_index) dragOvAl_el.classList.add("dropBelow");
        }

        prev_dragOver_el= dragOvAl_el;
      }
    }
  } //dragOver()

  function drop(evt) {
    if (!dragAl_el) return; //-->

    evt.preventDefault();
    var dropOn_el= prev_dragOver_el; //not actual the dropOn_el, but this allows user to make drop even with imprecise drop
    //.. if user drops outside of window, no drop event at all
    if (dropOn_el) {
      if (dropOn_el == trash_el) {
        alarmInst_el= dragAl_el;
        exec_deleteAlarm();

      } else if (dropOn_el.classList.contains("dropAbove") || dropOn_el.classList.contains("dropBelow")) {
        if (dropOn_el.classList.contains("dropAbove")) dropOn_el.before(dragAl_el);
        else dropOn_el.after(dragAl_el);

        if (active_aI_el) active_aI_el.after(alarmStatus_el);

        saveAlarms();
      }
    }

    clear("fully");
  } //drop()

  function clear(fully_flag) { //if not fully, just clear dragOver's class
    if (prev_dragOver_el) prev_dragOver_el.classList.remove("dropAbove", "dropBelow", "dropTrash");
    if (fully_flag) {
      if (dragAl_el) dragAl_el.classList.remove("dragging");
      dragAl_el= undefined;
      prev_dragOver_el= undefined;
    }
  } //clear()

  //dragndrop
} //alarmDragger()


var ringerButs_el= document.querySelector("div#ringerButs");
ringerButs_el.style.display= "none";

var ringerOff_el= document.querySelector("div#ringerOff")
ringerOff_el.addEventListener("click", () => stopRinger());

var ringerSnooze_el= document.querySelector("div#ringerSnooze")
ringerSnooze_el.addEventListener("click", () => stopRinger("snooze"));

var rSnzCountdown_el= document.querySelector("div#rSnzCountdown");

var ring_flag;
var ring_intimerId;
var snooze_ctdn_m;

function startRinger() {
  ring_flag= true;
  active_aI_el.scrollIntoView(true); //true, alignToTop
  play_sound("rngr");
  ringerButs_el.style.display= "block";
  body_el.classList.add("ringing", "ringingFlash");
  ring_intimerId= setInterval(() => { //recurse
    body_el.classList.toggle("ringingFlash");
    play_sound("rngr");
  }, 5000);
} //startRinger()

function stopRinger(snooze_flag) {
  if (!ring_flag) return;

  if (ring_intimerId) {
    clearInterval(ring_intimerId);
    ring_intimerId= undefined;
    body_el.classList.remove("ringing", "ringingFlash");
  }

  if (snooze_flag) {
    //note: snooze wont be exact, since it only checks/fires at top of minute
    //eg. 5 minutes will be 4-5 minutes
    snooze_ctdn_m= snooze_def_num;
    ringerSnooze_el.classList.add("but-active");

  } else { //ringer off
    if (ring_flag) play_sound("slam"); //ringer-off slam
    alarmStatus_el.style.display= "none";
    ringerButs_el.style.display= "none";
    snooze_ctdn_m= 0; //if needed
    ringerSnooze_el.classList.remove("but-active"); //if needed
    ring_flag= false;
    setAlarm(false);
  }

  drawSnooze(); //if needed
} //stopRinger()

function drawSnooze() {
  rSnzCountdown_el.textContent= snooze_ctdn_m ? g_untilStr(snooze_ctdn_m) : "";
} //drawSnooze()

function checkSnooze() {
  drawSnooze();
  if (!snooze_ctdn_m) { //end snooze
    ringerSnooze_el.classList.remove("but-active");
    startRinger();
  }
} //checkSnooze()

function g_untilStr(m, h) {
  if (m >= 1440) {
   str= Math.floor(m /1440) +"d";

  } else {
    var mnt_flag;
    if (h == undefined) {
      mnt_flag= true;
      if (m > 59) {
        h= Math.floor(m /60);
        m= m %60;
      }
    }
    var str= h ? (h +"h") : "";
    if (mnt_flag || m) str+= " " +m +"m";
  }

  return str || "0";
} //g_untilStr()


function play_sound(ac_key, repeat_n= 1, step_ms= 750) {
  if (repeat_n == 1) {
    audioClips[ac_key].play();
    return; //-->
  }

  var ct= 0;
  step_play(); //kickoff

  function step_play() {
    audioClips[ac_key].play();
    ct++;
    if (ct < repeat_n) setTimeout(step_play, step_ms); //recurse //-->
  }
} //play_sound()

//utils
function showEl(el, display_str= "block") {
  el.style.display= display_str
}


//jm (modal)
var jm= {
  _els: {},
  _type: 0,
  _end_cb: 0,

  init: function() {
    //pop jm._els (aliasIO is dynamically assigned)
    "div#jwmOverlay, span#jwmCloseBut, div#jwmDescription, input#jwmInput, textarea#jwmTextarea, button#jwmOkBut, button#jwmNoBut, button#jwmCancelBut".split(", ").forEach(sel_str => {
      jm._els[sel_str.split("#")[1].replace("jwm", "")]= document.querySelector(sel_str);
      //note: jid is the element id with the "jwm" removed
    });

    //modal handlers
    document.addEventListener("keyup", evt => { //capture any keyup
      if (document.body.classList.contains("jw-modal-active")) { //modal active
        if (evt.key=="Escape" || (evt.key=="Enter" && !evt.shiftKey)) jm._respond(evt.key);
        //since modal can contain textarea, no 'nav' keys should be captured (arrow, tab)
        //also shift-enter allows linebreak in textarea
        else if (jm._type == "PROMPT_BOOL") jm._prmBoolProc(evt.key); //however, this does do 'nav' keys
      }
    });

    jm._mouseHandler("Overlay_mousedown", evt => { //"click" can get accidental "click"
      if (evt.target.id == "jwmOverlay") jm._respond("Overlay Click"); //closeModal

    });

    jm._mouseHandler("OkBut", evt => {
      if (jm._type == "PROMPT_BOOL") jm._els.aliasIO.value= "OK";
      jm._respond();
    });

    jm._mouseHandler("NoBut", evt => {
      jm._els.aliasIO.value= "NO";
      jm._respond();
    });

    jm._mouseHandler("CancelBut", evt => {
      jm._respond("CANCEL");
    });

    jm._mouseHandler("CloseBut", evt => {
      jm._respond("CLOSE");
    });

  }, //init()

  dialog: function(type_str, text_str, value_str, cb) { //ck, non blocking modal
    //all types can have cb (callback)

    if (document.body.classList.contains("jw-modal-active")) { //modal active
      console.error("Modal occupied");
      return; //abort //-->
    }

    jm._displayEls("Input,Textarea,NoBut,CancelBut", "none");
    jm._classEls("OkBut,NoBut", "hilite", false);
    jm._classEls("OkBut", "toggleable", false);
    jm._els.aliasIO= jm._els.Input; //for .Input or .Textarea
    jm._els.OkBut.textContent= "OK";

    if (type_str.search(/ALERT|ERROR|CONFIRM|PROMPT_BOOL/) > -1) {
      jm._els.aliasIO.value= "OK";

      if (type_str == "PROMPT_BOOL") {
        jm._displayEls("NoBut,CancelBut", "inline");
        jm._classEls("OkBut", "toggleable");
        jm._els.OkBut.textContent= "Yes";
        var state_flag= !!value_str; //to boolean
        //.. local var
        if (!state_flag) jm._els.aliasIO.value= "NO";
        //.. actual value kept in aliasIO.value as string ("OK", "NO")
        jm._prmBoolProc(); //hilte only

      } else if (type_str == "CONFIRM") { //CONFIRM is just an ALERT with a Cancel button
        jm._displayEls("CancelBut", "inline");

      } else if (type_str == "ERROR") play_sound("buzz");

    } else if (type_str.search(/PROMPT$|PROMPT_TEXTAREA/) > -1) {
      if (type_str == "PROMPT_TEXTAREA") jm._els.aliasIO= jm._els.Textarea;
      jm._els.aliasIO.value= value_str;

      jm._displayEls("aliasIO");
      jm._displayEls("CancelBut", "inline");

    } else {
      console.error("jm.dialog, bad type_str:", type_str);
      return; //-->
    }

    jm._type= type_str;
    jm._els.Description.innerHTML= text_str;

    if (cb) {
      if (typeof(cb) == "object") { //custom hooks object
        if (cb.begin_cb && typeof(cb.begin_cb)=="function") cb.begin_cb();
        jm._customHooks(cb, true); //add listeners
      } else if (typeof(cb) != "function") { //otherwise should a fn (that is the 'end' callback)
        cb= undefined; //error, no message
      }
    }
    jm._cb= cb;

    jm.openModal("jwmModal");
    jm._els.aliasIO.select(); //highlight text //if needed
  },

  alert: function(text_str, cb) {
    jm.dialog("ALERT", text_str, "", cb); //returns true or null
  },
  error: function(text_str, cb) {
    jm.dialog("ERROR", text_str, "", cb); //returns true or null
  },
  confirm: function(text_str, cb) {
    jm.dialog("CONFIRM", text_str, "", cb); //returns true or null
  },

  prompt_boolean: function(text_str, value_flag, cb) {
    jm.dialog("PROMPT_BOOL", text_str, value_flag, cb); //returns true or false or null
    //param called value_flag here, but jm.dialog will still call it value_str
  },

  prompt: function(text_str, value_str, cb) {
    jm.dialog("PROMPT", text_str, value_str, cb); //returns string or null
  },
  prompt_textarea: function(text_str, value_str, cb) {
    jm.dialog("PROMPT_TEXTAREA", text_str, value_str, cb); //returns string or null
  },

  _prmBoolProc: function(key) {
    //PROMPT_BOOL is the only dialog that has Yes/No buttons
    //they are highlightable by nav keys, and submittable by shortcut key (Y/N)
    var state_flag= jm._els.aliasIO.value == "OK"; //local var
    var submit_flag;

    if (key) { //key capture
      key= key.toUpperCase();
      if (key.search(/Y$|N$/) == 0) { //exact match "Y" or "N"
        state_flag= value= key != "N";
        submit_flag= true;
      } else if (key.indexOf("ARROW") == 0) {
        state_flag= !state_flag; //toggle
      }
      jm._els.aliasIO.value= state_flag ? "OK" : "NO";
    }

    //highlight Y/N Button
    liteBut("OkBut", state_flag);
    liteBut("NoBut", !state_flag);
    function liteBut(jid, flag) {
      jm._els[jid].classList[flag?"add":"remove"]("hilite");
    }

    if (submit_flag) jm._respond(); //btw, closes modal
  },

  _respond: function(act_code= "") {
    if (jm._type=="ALERT" && act_code=="Escape") return; //-->
    //hacky - but dont allow esc key for ALERT, because it wont satisfy browser restriction for sound to play

    jm.closeModal();

    var cb= jm._cb;
    if (!cb) return; //-->

    var resp= true;

    if (act_code.search(/Overlay Click|Escape|CANCEL|CLOSE/) > -1) {
      resp= null;
    } else if (jm._type.includes("PROM")) {
      resp= jm._els.aliasIO.value;
      if (jm._type == "PROMPT_BOOL") resp= (resp == "OK"); //to boolean
    }

    if (typeof(cb) == "object") {
      jm._customHooks(cb, false); //remove listeners
      if (cb.end_cb) cb.end_cb(resp);
    } else {
      cb(resp);
    }

  }, //_respond

  _customHooks: function(cbO, add_flag) {
    var el_jid, el, evt_key;
    Object.keys(cbO).forEach(ce_code => {
      [el_jid, evt_key]= ce_code.split("_");
      if (evt_key) {
        if (el= jm._els[el_jid]) {
          if (add_flag) el.addEventListener(evt_key, cbO[ce_code]);
          else el.removeEventListener(evt_key, cbO[ce_code]);
        }
      }
    });

    //possible 'e_codes':
      //begin_cb, returns nothing
      //end_cb, returns resp
      //(handler on any event on any jm._els item, returns event)
        //eg. "Input_keyup" is 'keyup' event on input#jwmInput
        //eg. "OkBut_mouseover" is 'mouseover' event on button#jwmOkBut

  }, //_customHooks

  //utils
  _mouseHandler: function(el, clk_cb) { //default is "click", but can cutomize, eg. "Overlay_mousedown"
    var act_str;
    if (typeof(el) == "string") {
      [el, act_str]= el.split("_"); //eg. "Overlay" and "mousedown"
      el= jm._els[el];
    }
    if (el) el.addEventListener(act_str || "click", clk_cb);
  },

  _displayEls: function(jids, display_str) {
    jm._iterEls(jids, el => showEl(el, display_str) );
  },

  _classEls: function(jids, class_str, flag= true) {
    jm._iterEls(jids, el => el.classList[flag?"add":"remove"](class_str) );
  },

  _iterEls: function(jids, itr_cb) {
    var el;
    jids.split(",").forEach(jid => {
      if (el= jm._els[jid]) itr_cb(el);
    });
  },

  //orig: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example
  openModal: function(id) { //open modal by id
    document.body.classList.add("jw-modal-active");
    var el;
    if (el= document.getElementById(id)) el.classList.add("open");
  },
  closeModal: function() { //close currently open modal
    document.body.classList.remove("jw-modal-active");
    jm._els.Overlay.querySelector(".open").classList.remove("open");
  }
}; //jm
jm.init();


//INIT
var init_dtO= new Date();
console.log("INIT", init_dtO.toLocaleString());

var fClick_flag= true;
urlImportALarm(window.location.search);
if (fClick_flag) { //satisfy browser requirement to allow play-sound
  jm.alert("Click to start", () => {
    startClock(); startAlarms();
  });
}


function urlImportALarm(q_str) { //import from pC via url querystring, stores "importedAlarm" in localstorage
  //.. this is a url based endpoint, not really a webpage, self closes
  if (!q_str) return; //-->
  var usp= new URLSearchParams(q_str);
  var pcDrft_str= usp.get("pc_draft"); // ?pc_draft=New%20York%20Yankees|123|WED|5/5|12:34pm
  if (pcDrft_str && pcDrft_str.split("|").length==5) { //cursory test
    fClick_flag= false;

    var prev_pcDrft_str= localStorage.getItem("importedAlarm"); //allow multiple
    if (prev_pcDrft_str) {
      if (prev_pcDrft_str.includes(pcDrft_str)) pcDrft_str= ""; //dupe, ignore
      else pcDrft_str= prev_pcDrft_str +"\n" +pcDrft_str; //append
    }

    if (pcDrft_str) localStorage.setItem("importedAlarm", pcDrft_str);
    window.close();
  }
} //urlImportALarm()

</script>

</body>
</html>
