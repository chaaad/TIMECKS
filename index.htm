<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<link rel="icon" href="./favicon.ico"/>

<title>TIMECKS</title>

<link href="https://fonts.cdnfonts.com/css/seven-segment" rel="stylesheet" crossorigin="anonymous">

<style type="text/css">

/*prereq css begin*/
/*https://codepen.io*/
body {
  font-family: "Lato", sans-serif;
  font-size: 100%;
  font-style: normal;
  font-weight: 300;
}
ul {list-style: none; }
/*prereq css end*/

i {
  font-style: normal;
  font-weight: bold;
  font-size: 24px;
}

.button {
  color: lightgray;
  background: #eee;
  border-radius: 8px;
  border: 2px solid chartreuse;
  cursor: pointer;
  user-select: none;

  &.squareButton {
    font-size: larger;
    margin: 8px;
    padding: 8px;
    color: gray;
    width: 20px;
    height: 20px;
    text-align: center;
  }

  &:hover {
    background: #ddd;
  }
}

/*adapted from: https://codepen.io/ndeniche/pen/rNPjmg
*/
.closeButton {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 30px;
  float: right;
  margin-left: 8px;
  margin-top: 2px;
  &:hover {
    &::before,
    &::after {
      background: red; /*bgcolor*/
    }
  }
  &::before,
  &::after {
    content: "";
    position: absolute;
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: darkgray; /*bgcolor*/
    border-radius: 5px; /*rounded*/
    height: 6px; margin-top: -3px; /*heavy*/
  }
  &::before {
    transform: rotate(45deg);
  }
  &::after {
    transform: rotate(-45deg);
  }

  &.big { /*test*/
    transform: scale(3);
    background: pink;

  }

  &.small {
    transform: scale(0.66);
  }

} /*closeButton*/


/*adapted from: https://getcssscan.com/css-checkboxes-examples
*/
.checkbox-wrapper-18 {
  position: relative;

  /*timecks.. */
  top: 4px;
  display: inline-block;
  margin-right: 8px;
}
.checkbox-wrapper-18 label {
  background-color: #fff; /*circle*/
  border: 2px solid #ccc;
  border-radius: 50%;
  cursor: pointer;
  height: 28px;
  width: 28px;
  display: block;
}

.checkbox-wrapper-18 label:after {
  border: 2px solid #fff; /*check mark drawn with borders, then rotated*/
  border-top: none;
  border-right: none;
  content: "";
  height: 6px;
  left: 8px;
  opacity: 0;
  position: absolute;
  top: 9px;
  transform: rotate(-45deg);
  width: 12px;
}

.checkbox-wrapper-18 input[type="checkbox"] {
  visibility: hidden;
  display: none;
  opacity: 0;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label {
  background-color: #66bb6a;
  border-color: #66bb6a;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label:after {
  opacity: 1;
}
/*checkbox*/

div.textBox {
  max-width: 290px;
  overflow: auto;
  font-size: medium;
  font-weight: 600;
  background: #eee;
  padding: 8px;
  border-radius: 8px;
  margin-bottom: 8px;
  opacity: 50%;
  letter-spacing: 0.5px;
}


div#topButtons {
  position: fixed;

  div {
    line-height: 22px;
  }

  .on {
    color: chartreuse;
  }

  .down {
    background: chartreuse;
  }

  div#trashCan {
    font-size: xx-large;
    line-height: 20px;
    border-color: lightgray;
    cursor: default;
    background: white;

    &.dropTrash {
      background: cyan;
    }
  }
}

div#wakeLockEnable {
  line-height: 24px;
  position: fixed;
  right: 4px;
  bottom: 4px;

  &.on {
    background-color: lightskyblue;
  }
}

div#msgContainer {
  position: fixed;
  left: 70px;
  top: 14px;
  width: 300px;
  z-index: 1;

  div.msgInstance {
    background: gold;
  }
}

div#templates {
  display: none;
}

div#ringerOverlay {
  display: none; /*hidden by default */
  position: fixed; /* fixed across whole screen */
  inset: 0;
  z-index: 3; /* zindex higher than rest of page */
  opacity: 0.30;
  background: lightblue;
  transition: background-color 2s;
  padding: 40px;

  &.flash {
    background: pink;
  }
}

div#alarmsContainer {
  float: right;
  font-size: larger;
  padding: 8px;
  position: relative;
  margin-bottom: 40px; /*so its possible for wakelock button to not overlay anything */

  div.alarmInstance {
    margin-bottom: 20px;
    border-radius: 8px;
    transition: background-color 1s ease-out;

    * {
      cursor: pointer;
      user-select: none;
    }

    div.alarmInfo {

      .PC_tid {
        color: orangered;
      }
    }

    span.alarmActivate {
      color: lightgray;
    }

    span.alarmT {
      width: 200px;
      padding: 4px;
      border-radius: 2px;
      opacity: 25%;
      text-align: right;
    }

    span.alarmTime {
      letter-spacing: 2px;
      display: inline-block;
      font: bold 28px "Seven Segment", sans-serif;
      color: greenyellow;
      background: black;
    }

    span.alarmCountdown {
      display: none;
      font-size: larger;
      font-weight: 800;
      color: darkolivegreen;
      opacity: 50%;
      padding-top: 1px; /*compensate for the fonts being slightly diff height*/
    }

    &.soon {
      div.alarmInfo {
        background: #ddf;
        opacity: 100%;
      }
      span.alarmTime {
        opacity: 50%;
      }
    }

    &.alarmActive {
      div.alarmInfo {
        background: black;
        color:white;
        opacity: 100%;
      }
      span.alarmActivate {
        color: chartreuse;
      }
      span.alarmTime {
        opacity: 100%;
      }
    }

    /*drag n drop*/
    &.dragging {
      opacity: 0.5;
    }

    &.dropAbove {
      border-top: 100px solid lightcyan;
      border-bottom: "";
    }
    &.dropBelow {
      border-top: "";
      border-bottom: 100px solid lightcyan;
    }

    &.expired {
      background: pink;
    }
  }

  div.disablableContainer {
    div.alarmInfo {
      color: white;
      background: #666;
      opacity: 100%;
    }

    .soon div.alarmInfo {
      background: darkblue;
    }

    div.disabledInstance {
      div.alarmInfo {
        color: gray;
        background: #eee;
      }
    }
  }

  div#activeCountdown {}

  div#activeStatus {
    display: none;
    margin-bottom: 16px;

    div#ringerCont {
      display: none;
      z-index: 3;
      position: relative;
      margin-top: 16px;

      div#ringerSnooze,
      div#ringerOff {
        width: 100%;
        height:60px;
        line-height:60px;
        text-align: center;
        margin-top: 12px;
        color: white;
        font-weight: bold;
        font-size: 24px;
      }
      div#ringerOff {
        background: chartreuse;
        color: black;

        &:hover {
          background: lightgray;
        }
      }
      div#ringerSnooze {
        background: gray;

        &:hover {
          color: chartreuse;
        }

        &.but-active {
          color: chartreuse;
        }

        div { /*snooze numbers*/
          margin-top: -3px; /*weird but works*/
          span {
            color: lightgray;

            &:hover {
              color: limegreen;
            }
          }
        }
      }
    }

    div#rSnzCountdown {}
  }

  .countdown {
    text-align: right;
    color:gray;
    margin-top: 8px;
    font-size: larger;
    font-weight: 800;
    color: cornflowerblue;
  }

} /*alarm*/

body.ringing {
  div#ringerSnooze {
    span {
      color: white !important;
    }
  }
}

div#clockFace {
  width: 272px;
  height: 272px;
  background: #FDFAF7;
  border: 12px solid lightgray;
  border-radius: 100%;
  position: absolute;
  left: 30%;
  top: 50%;
  transform: translate(-50%, -50%);
  user-select: none;
  z-index: -1;

  div.hands,
  div.marker {
    position: absolute; top: 50%; left: 50%;
    transform-origin: 50% 50%;
  }

  div.hands::before {
    content: "";
    position: absolute;
    bottom: 50%;
    background: black;
    opacity: 33%;
    border-radius: 3px;
    transform: translateX(-50%);
  }

  div.hands.throt::before {
    background: blue;
  }
  div.hands.slept::before {
    background: red;
  }

  div#minuteHand {
    transition: transform 1s linear;
  }
  div#minuteHand::before {
    width: 6px;
    height: 110px;
  }

  div#hourHand::before {
    width: 10px;
    height: 70px;
  }

  div.marker {
    height: 118%;
    font-size: xx-large;
    color: white;
    &.on {
      color: black;
    }
  }

  div#spindle {
    width: 7px;
    height: 7px;
    background: #FDFAF7;
    border: 2px solid darkgray;
    border-radius: 100%;
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }

  span { /*tickmarks //each span has 2 tickmarks, uses ::before and ::after to create left and right, so only 30*/
    display: block;
    width: 1px;
    height: 95%;
    position: absolute; top: 50%; left: 50%;

    &::before,
    &::after {
      content: "";
      background: #A0A1A4;
      position: absolute;
      left: 0;
      width: 100%;
      height: 10px;
    }
    &::before {
      bottom: 0;
    }
    &::after {
      top: 0;
    }

    &.fives {
      &::after,
      &::before {
        height: 20px
      }
    }
  }


  ul#hourNumbers {
    height: 38%;
    position: absolute;
    bottom: 44%; /*changed (eyeballed) from 50%*/
    left: 50%;

    li {
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 50% 100%;

      i {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
    }
  }

  h2,
  h3 {
    letter-spacing: 1px;
    font-variant: small-caps;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }
  h2 {
    font-size: 8px;
    top: 29%;
    letter-spacing: 3px;
    font-weight: bold;
  }
  h3 {
    color: darkgray;
    top: 25%;
    font-size: x-large;
  }

  div#dtDisplay {
    font-size: 32px;
    font-weight: bold;
    color: #bbb;
    background: #eee;
    padding: 6px;
    border-radius: 12px;
    text-align: center;
    position: absolute;
    left: 50%;
    bottom: 25%;
    transform: translateX(-50%);

    &.pm {
      color: #eee;
      background: #bbb;
    }
  }

} /*clockface*/


/* MODAL
adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example#styles-css
-------------------------------*/
body.jw-modal-active { /*dont edit this css*/
  overflow: hidden; /* to hide main scrollbar when modal is active */
  div#jwmOverlay {
    display: block;
  }
}

div#jwmOverlay { /*background mask and overall container*/  /*edit this css carefully*/
  display: none; /* modals are hidden by default */
  position: fixed; /* modal container fixed across whole screen */
  inset: 0;
  z-index: 2; /* zindex higher than rest of page, except ringer */
  background-color: rgba(0, 0, 0, .75); /* semi-transparent black background exposed by padding */
  padding: 40px;
  overflow: auto; /* enables scrolling for tall modals */

  .jw-modal-item { /*modal instance*/
    font-size: larger;
    width: 420px;
    padding: 4px 8px;
    background: #fff;
    margin: 0px auto; /*center horiz*/
    border-radius: 16px;

    .open { /*dont edit this css*/
      display: block;
    }

    * {
      margin:12px;
    }

    div#jwmContent {
      margin-top: 50px;
    }
    div#jwmDescription {
      line-height: 28px;

      b {
        color: cornflowerblue;
        &.E {
          color: red;
        }
      }
    }
    input#jwmInput {
      width: 360px;
      font-size: xxx-large;
      padding: 4px;
    }
    textarea#jwmTextarea {
      width: 360px;
      height: 100px;
      padding: 8px;
      font-size: x-large;
    }

    /*button
    https://getcssscan.com/css-buttons-examples
    button-71
    */
    button {
      background-color: #0078d0;
      border: 0;
      border-radius: 56px;
      color: #fff;
      cursor: pointer;
      display: inline-block;
      font-family: system-ui,-apple-system,system-ui,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",sans-serif;
      font-size: 20px;
      letter-spacing: 1px;
      font-weight: 600;
      outline: 0;
      padding: 16px 21px;
      position: relative;
      text-align: center;
      text-decoration: none;
      transition: all .3s;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      min-width: 160px; /*timecks addition*/
    }

    button:before {
      background-color: initial;
      background-image: linear-gradient(#fff 0, rgba(255, 255, 255, 0) 100%);
      border-radius: 125px;
      content: "";
      height: 50%;
      left: 4%;
      opacity: .5;
      position: absolute;
      top: 0;
      transition: all .3s;
      width: 92%;
    }

    button:hover {
      box-shadow: rgba(255, 255, 255, .2) 0 3px 15px inset, rgba(0, 0, 0, .1) 0 3px 5px, rgba(0, 0, 0, .1) 0 10px 13px;
      transform: scale(1.05);
    }

    @media (min-width: 768px) {
      button {
        padding: 16px 48px;
      }
    }
    /*button-71*/

    button.toggleable {
      background: chocolate;
      opacity: 40%
    }
    button.hilite {
      opacity: 100%;
    }

    button#jwmCancelBut {
      opacity: 50%
    }
  }

} /*jwmOverlay*/

</style>
</head>

<body>

<div id="templates">

  <div class="alarmInstance" draggable="true">
    <div class="textBox alarmInfo" title="Edit info"></div>
    <span class="alarmActivate button squareButton" title="On/Off">‚èπ</span>
    <span class="alarmT alarmTime" title="Edit time (LONG PRESS to change default view)">@</span>
    <span class="alarmT alarmCountdown" title="Edit time (LONG PRESS to change default view)"></span>
    <span class="alarmDeleteBut closeButton" title="Delete"></span>
  </div>

  <div class="textBox msgInstance">
    <span class="msgDeleteBut closeButton small" title="Delete msessage"></span>
    <div class="msgInfo"></div>
  </div>

</div>

<div id="topButtons">
  <div id="editStgsBut" class="button squareButton" title="Settings (snooze duration)">Ô∏ô</div>
  <div id="diasablerModeBut" class="button squareButton" title="Disabler Mode">D</div>
  <div id="autsrtModeBut" class="button squareButton" title="AutoSort Mode">A</div>
  <div id="sortBut" class="button squareButton" title="Sort alarms (ctrl-click to skip confirm)">‚Æù</div>
  <div id="addAlarmBut" class="button squareButton" title="Add new alarm">‚úö</div>
  <div id="trashCan" class="button squareButton" title="Trash (drop unwanted alarm here)">üóë</div>
</div>

<div id="msgContainer"></div>

<div id="ringerOverlay"></div>

<div id="alarmsContainer">
  <div id="activeStatus">
    <div id="activeCountdown" class="countdown"></div>
    <div id="ringerCont">
      <div id="ringerOff" class="button">OFF</div>
      <div id="ringerSnooze" class="button">
        SNOOZE
        <div>
          <span>1</span>
          <span>5</span>
          <span>10</span>
          <span>15</span>
          <span>20</span>
          <span>30</span>
        </div>
      </div>
      <div id="rSnzCountdown" class="countdown">&nbsp;</div>
    </div>
  </div>
</div>


<div id="wakeLockEnable" class="button squareButton" title="Wake Lock">üîí</div>


<div id="clockFace">
  <h2>TIMECKS</h2>
  <h3></h3>

  <div id="dtDisplay"></div>

  <ul id="hourNumbers"></ul>

  <div id="minuteHand" class="hands"></div>
  <div id="hourHand" class="hands"></div>
  <div id="spindle"></div>

  <div id="alarmMarker" class="marker">‚Ä¢</div>
</div>


<div id="jwmOverlay">
  <div id="jwmModal" class="jw-modal-item">
    <span id="jwmCloseBut" class="closeButton"></span>
    <div id="jwmContent">
      <div id="jwmDescription"></div>
      <input id="jwmInput"/>
      <textarea id="jwmTextarea"></textarea>
      <button id="jwmOkBut">OK</button>
      <button id="jwmNoBut" class="toggleable">No</button>
      <button id="jwmCancelBut">Cancel</button>
    </div>
  </div>
</div>

</body>

<script>
//clock
//adapted from: https://codepen.io/opheliafl/pen/RaYbvL/

//favicon
//<a href="https://www.freepik.com/icon/alarm-clock_15092469#fromView=keyword&page=1&position=21&uuid=6aee3d4d-c58a-453e-8681-22457f5c0a34">Icon by sonnycandra</a>
//https://realfavicongenerator.net/

var audioClips= {
  beep: new Audio("https://cdn.freesound.org/previews/426/426892_7913959-lq.mp3"),
  bell: new Audio("https://cdn.freesound.org/previews/173/173000_2193194-lq.mp3"),
  buzz: new Audio("https://cdn.freesound.org/previews/696/696600_14786418-lq.mp3"),
  //oops: new Audio("https://cdn.freesound.org/previews/124/124897_1707984-lq.mp3"),
  slam: new Audio("https://cdn.freesound.org/previews/421/421472_3387258-lq.mp3"),
  trsh: new Audio("https://cdn.freesound.org/previews/655/655617_13805813-lq.mp3"),
  clik: new Audio("https://cdn.freesound.org/previews/668/668985_14100561-lq.mp3"),
  snoz: new Audio("https://cdn.freesound.org/previews/425/425727_760420-lq.mp3"),
  rngr: new Audio("https://cdn.freesound.org/previews/246/246332_4486188-lq.mp3")
};


var clockFace_EL= document.querySelector("DIV#clockFace");

var cf_handH_EL= clockFace_EL.querySelector("div#hourHand");
var cf_handM_EL= clockFace_EL.querySelector("div#minuteHand");

var cf_dow_EL= clockFace_EL.querySelector("h3");
var cf_monthDay_EL= clockFace_EL.querySelector("div#dtDisplay");

var cf_marker_EL= clockFace_EL.querySelector("div.marker");
showEl(cf_marker_EL, false);

function clock_draw() {
  var rotate_n= 0;
  for (var i=0; i<30; i++) {
    let span_EL= document.createElement("span");
    if (!(i%5)) span_EL.className= "fives";
    span_EL.style.transform= "translate(-50%,-50%) rotate(" +rotate_n +"deg)";
    clockFace_EL.appendChild(span_EL);
    rotate_n+= 6;
  }

  //createHourNumbers
  rotate_n= 0;
  var hr_n= 12;
  var ul_EL= document.querySelector("UL#hourNumbers");
  for (i=0; i<12; i++) {
    let li_EL= document.createElement("li");
    if (rotate_n) li_EL.style.transform= "rotate(" +rotate_n +"deg)";
    ul_EL.appendChild(li_EL);

    let i_EL= document.createElement("i");
    i_EL.textContent= hr_n;
    if (rotate_n) i_EL.style.transform= "translateX(-50%) rotate(-" +rotate_n +"deg)";
    li_EL.appendChild(i_EL);

    rotate_n+= 30;
    hr_n++;
    if (hr_n > 12) hr_n= 1;
  }
} //clock_draw()


var cf_degO;
var cf_h_inc= 360 /720; //0.5deg
var cf_m_inc= 360 /60; //6deg

var start_dtO;
var clock_hr24;
var clock_elapse_ms; //what we want the time to be, when compared to Date.now() we get sync_diff_ms
var clock_ctdn_m;
var inc_ms= 60000; //default 1 minute (flex)

var clockMarker_n;

function clock_drawHands(o =cf_degO) {
  cf_handH_EL.style.transform= "rotate(" +o.hr +"deg)";
  cf_handM_EL.style.transform= "rotate(" +o.mn +"deg)";
} //clock_drawHands()

function clock_drawSyncHands() { //temp hands positions based on sync_diff_ms, cf_degO uneffected
  var diff_m= sync_diff_ms /60000;
  clock_drawHands({ //draw mn hand at precise mn position (not usual whole mn)
    hr: cf_degO.hr -cf_h_inc *diff_m,
    mn: cf_degO.mn -cf_m_inc *diff_m
  }); //sleep/throttle actually makes mn hand more accurate lol
  if (sync_diff_ms < 0) return; //clock was behind //-->

  //clock was ahead
  setTimeout(() => {
    clock_drawHands(); //now, can draw mn hand at the 'original' whole mn
    classEl(cf_handM_EL, "throt", false);
  }, sync_diff_ms);
} //clock_drawSyncHands()

/*///////////////
var dbg_m, dbg_h;
function dbgdate() {
  var dtO= new Date();
  if (dbg_m) dtO.setMinutes(dtO.getMinutes() +dbg_m);
  if (dbg_h) dtO.setHours(dtO.getHours() +dbg_h);
  return dtO;
}
*////////////////

function clock_start() {
  start_dtO= new Date();
  //start_dtO= dbgdate();

console.log("clock_start", start_dtO.toLocaleTimeString());
  sound_play("clik");

  clock_elapse_ms= start_dtO.getTime();

  clock_hr24= start_dtO.getHours();
  var minutes= start_dtO.getMinutes(); //0-59
  clock_ctdn_m= 60 -minutes; //60-1

  cf_degO= {
    hr: 30 *clock_hr24  +cf_h_inc *minutes,
    mn: cf_m_inc *minutes
  };
  clock_drawHands();

  tzoc_start();

  var minute_ms= start_dtO.getSeconds()*1000 +start_dtO.getMilliseconds();
  var topOfMinute_ms= 60000 -minute_ms;
  setTimeout(() => {
    clock_elapse_ms+= topOfMinute_ms;//inc (1st min)
    clock_advance(); //1st

    mainloop(); //kickoff

    function mainloop() { //self-recursing
      setTimeout(() => {
        clock_elapse_ms+= 60000; //inc (fixed)
        if (clock_advance()) return; //abort mainloop //-->

        data_load("importedAlarm", dataO => {
          var imported_str= dataO.importedAlarm;
          if (imported_str) alarms_import(imported_str);
        });
        //.. like a poll, for "importedAlarm" in localStorage

        if (active_flag) {
          if (!wakeLock_OBJ) wakeLock_toggle(); //on
        } else {
          if (wakeLock_OBJ) wakeLock_toggle(); //off
        }

        mainloop(); //recurse-->

      }, inc_ms);
    } //mainloop()

  }, topOfMinute_ms);

  clock_drawDay(start_dtO);

} //clock_start()

var monthDay_str;
function clock_drawDay(dtO) { //draw am/pm and monthday
  cf_dow_EL.textContent= dtO.toLocaleDateString("en-US", {weekday:"short"}).toUpperCase();
  //eg. "Tue" .. "TUE"
  var month_n= dtO.getMonth();
  monthDay_str= (month_n +1) +"/" +dtO.getDate(); //0-11 (+1), 1-31
  cf_monthDay_EL.textContent= monthDay_str; //monthday
  classEl(cf_monthDay_EL, "pm", clock_hr24>=12); //am/pm
} //clock_drawDay()


var sync_dtO;
var sync_ms;
var sync_diff_ms; //can debug in console

var clock_throt_flag;
var clock_jump_ct= 0;

function clock_advance() { //+1 clock minute
  sync_dtO= new Date(); //topOfMinute
  //sync_dtO= dbgdate();
  sync_ms= sync_dtO.getTime();
  sync_diff_ms= clock_elapse_ms -sync_ms;

  cf_degO.hr+= cf_h_inc;
  cf_degO.mn+= cf_m_inc;

  clock_ctdn_m--; //inc-
  if (clock_ctdn_m < 1) { //top of hr
    clock_ctdn_m= 60; //wrap (reset)
    clock_hr24= (clock_hr24+1) %24; //inc wrap
    cf_degO.mn= 0;

    if (clock_hr24 %12 == 0) { //noon or midnite
      cf_degO.hr= 0;

      var toh_dtO= clock_hr24==0 && sync_diff_ms>0 ? new Date(sync_ms +3600000) : undefined; //if midnite, and real time is behind, add 1 hr (to next day)
      //.. add hr, dont care about time here, just month/day

      clock_drawDay(toh_dtO || sync_dtO);
      tzoc_check(sync_dtO);
    }
//console.log("TOP OF HR", g_fmatDtO(sync_dtO))
  } //top of hr

  clock_drawHands();

  if (sync_diff_ms) { //not 0

    //post-sleep (possibly throttle?)
    if (sync_diff_ms <= -60000 ) { //very slow, 1 or more minute behind

      if (sync_diff_ms <= -3600000 ) { //extremely slow, 1 or more hour behind
        restart(); //clean
        return "abort_mainloop"; ////-->
        ///////////////////////
      }

      //jump 1 minute
      clock_jump_ct++;  //post-sleep stage 1/3
      clock_elapse_ms+= 60000; //add 1 clock min
      clock_advance(); //.. can be called as many times as necessary to catch up (up to an hour)

    } else if (clock_jump_ct) { //not 0
      if (clock_jump_ct > 0) { //post-sleep stage 2/3
//console.log("clock jumped ahead", clock_jump_ct, "min", g_fmatDtO(sync_dtO), g_fmatSDM()) //debug
        clock_jump_ct= -1; //stage 3
        inc_ms= 60000 +sync_diff_ms; //get back in sync
        classEl(cf_handM_EL, "slept");
        clock_drawSyncHands();
        sound_play("clik", (clock_jump_ct>3 ? 3 : clock_jump_ct), 500);

      } else { //clock_jump_ct == -1 //post-sleep stage 3/3
        inc_ms= 60000; //reest
        clock_jump_ct= 0;
        classEl(cf_handM_EL, "slept", false);
      }


    //post-throttle
    //what happens is that during throttle, the mainloop runs lil slow, so inc_ms goes lower to try to run mainloop quicker
    //when throttle ends, this low inc_ms makes the next sync actually ahead!
    } else if (sync_diff_ms>100 || clock_throt_flag) { //fast (or throt stage 2)
      if (!clock_throt_flag) { //post-throt stage 1/2
//console.log("clock throt", g_fmatDtO(sync_dtO), g_fmatSDM()) //debug
        clock_throt_flag= true; //stage 2
        inc_ms= 60000 +sync_diff_ms; //get back in sync
        classEl(cf_handM_EL, "throt");
        clock_drawSyncHands();
        sound_play("clik", 2, 500);

      } else { //post-throt stage 2/2
        clock_throt_flag= false;
        //classEl(cf_handM_EL, "throt", false);
        inc_ms= 60000; //reset
      }


    //normal
    } else { //tweak inc_ms
      inc_ms+= sync_diff_ms; //tiny swerves, always trying to achieve sync_diff_ms of 0
      if (inc_ms < 1000) inc_ms= 1000; //not too small, nrn
    }

    //when browser throttled, mainloop 'minute' can be slow (over 7 secs seen), also screen rendering paused
    //https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#reasons_for_delays_longer_than_specified

    //when system sleeps, everything stops

//console.log("advanced Clock",  g_fmatDtO(sync_dtO), g_fmatSDM(), inc_ms )
  } //sync_diff_ms

  alarms_update(-1);

} //clock_advance()

function clock_checkMarker() {
  var marker_n= Math.floor(active_ctdn_m /720); //0 1 2+
  if (marker_n > 2) marker_n= 2;
  if (marker_n == clockMarker_n) return; //-->

  if (cf_marker_EL.mkr_val == undefined) { //init
    cf_marker_EL.style.transform= "translate(-50%, -50%) rotate(" +(30*active_hTimO.h +0.5*active_hTimO.m) +"deg)";
  }
  showEl(cf_marker_EL, active_ctdn_m<1440 ? "block" : false); //within 24hrs
  classEl(cf_marker_EL, "on", active_ctdn_m<720); //within 12hrs
  clockMarker_n= marker_n;
} //clock_checkMarker()


function restart() { //post long sleep
  var elapsed_minutes= Math.floor(sync_diff_ms /60000); //negative
  [...aI_NL].forEach(aI_EL  => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in disabler_mode all are visible)
      aI_EL.$D.ctdn_m+= elapsed_minutes; //negative
      if (aI_EL.$D.ctdn_m < 1) alrm_expireMsg(aI_EL);
    } //skip not visible
  });

  ringer_stop(); //if needed
  clock_start();
  if (autsrt_mode) alrm_clear();
  alarms_start();
} //restart()


//debug utils (console.log)
function g_fmatDtO(dtO =new Date()) { //formatted time string, eg. "@11:48:22.005" //shows ms
  return "@" +(dtO.getHours()%12||12) +":" +dtO.toISOString().substring(14, 23);
  //.. toISOString(), eg. "2011-10-05T14:48:22.005Z"
} //g_fmatDtO()
function g_fmatSDM() { //formatted sync_diff_ms string, eg. "dif+12"
  var str= "dif";
  if (sync_diff_ms > 0) str+= "+";
  return str +sync_diff_ms;
} //g_fmatSDM()
function aId(aI_EL) { //not really an id, but good for debugging
  return aI_EL.$E.Info.textContent +" " +aI_EL.$E.Ctdn.textContent;
} //aId()
function log_aIs(str ="") {
  var arr= [];
  [...aI_NL].forEach(aI_EL  => arr.push(aId(aI_EL)));
  console.log(str, arr)
} //log_aIs()

var body_EL= document.querySelector("body");

var topButs_EL= document.querySelector("div#topButtons");
//var editStgs_EL= topButs_EL.querySelector("div#editStgsBut");
var disblabler_EL= topButs_EL.querySelector("div#diasablerModeBut");
var autoSort_EL= topButs_EL.querySelector("div#autsrtModeBut");
var sort_EL= topButs_EL.querySelector("div#sortBut");
//var add_EL= topButs_EL.querySelector("div#addAlarmBut");
var trash_EL= topButs_EL.querySelector("div#trashCan");

var wlEnable_EL= document.querySelector("div#wakeLockEnable");

var msgCont_EL= document.querySelector("div#msgContainer");

var templates_EL= document.querySelector("div#templates");
var template_msgInst_EL= templates_EL.querySelector("div.msgInstance");
var template_alarmInst_EL= templates_EL.querySelector("div.alarmInstance");

//alarms
var alarmsCont_EL= document.querySelector("div#alarmsContainer");
var alarmInst_EL;
var active_aI_EL;

var activeStatus_EL= alarmsCont_EL.querySelector("div#activeStatus");
var activeCountdown_EL= activeStatus_EL.querySelector("div#activeCountdown");


var snooze_def_num;

document.addEventListener("keyup", evt => { //capture any keyup
  if (!document.body.classList.contains("jw-modal-active")) { //modal inactive
    if (ring_intimerId) { //keys to silence ringer
      if (evt.key == " ") ringer_stop("snooze");
      else if (evt.key.search(/Enter|Escape/) > -1) ringer_stop("off");
    //} else if (evt.key == "-") { //useful for testing, remove
      //alarmInst_EL= alarmsCont_EL.querySelector("div.alarmInstance"); //always the standard (1st) alarm
      //alrm_editTime();
    }
  }
});

topButs_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL.id == "editStgsBut") {
    timecksStgs_edit();
  } else if (targ_EL == disblabler_EL) {
    disablerMode_toggle();
  } else if (targ_EL == autoSort_EL) {
    autosortMode_set();
  } else if (targ_EL == sort_EL) {
    alarms_sort(evt);
  } else if (targ_EL.id == "addAlarmBut") {
    alrm_add();
  }
});


//create Message Header
var msgHeader_EL= message_add("Messages");
msgHeader_EL.classList.remove("msgInstance"); //no longer a commoner
//msgHeader_EL.style.cssText= "background:slategrey; color:white; ";
showEl(msgHeader_EL, false);

var msgDelAllBut_EL= msgHeader_EL.querySelector("span.msgDeleteBut");
msgDelAllBut_EL.title= "Delete all messages";

//message
msgCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL == msgDelAllBut_EL) {
    //////add a confirm? ////tbd
    msgCont_EL.querySelectorAll("div.msgInstance").forEach(m_el => message_remove(m_el));
    showEl(msgHeader_EL, false);
    //hide header

  } else if (targ_EL.classList.contains("msgDeleteBut")) {
    message_remove(targ_EL.closest("div.msgInstance"));
    targ_EL.closest("div.msgInstance").remove();
    if (!msgCont_EL.querySelectorAll("div.msgInstance").length) showEl(msgHeader_EL, false);
  }
});


//long press
var longPress_flag;
var longPress_timerId;

function longPress_timerStop() {
  if (!longPress_timerId) return; //-->

  clearTimeout(longPress_timerId);
  longPress_timerId= undefined;
}

//longpress
alarmsCont_EL.addEventListener("mousedown", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    longPress_timerStop();
    longPress_flag= false;
    longPress_timerId= setTimeout(function() { //startPressTimer
      var c_alarmInst_EL= targ_EL.closest("div.alarmInstance");
      longPress_flag= true; //this will prevent regular click handler
      alarmInst_EL= c_alarmInst_EL;
      alrm_setTorC(alarmInst_EL, !alarmInst_EL.$D.vu_cd, "persist"); //toggle
      sound_play("clik");
      alarms_save();
    }, 1000);
  }
});


//timehover
alarmsCont_EL.addEventListener("mouseover", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (aI_EL==active_aI_EL || aI_EL.$D.t_hov) return; //active or already hovered, skip //-->

    alrm_setTorC(aI_EL, !aI_EL.$D.vu_cd); //toggle, but only temporary
    aI_EL.$D.t_hov= true; //hover on
  }
});

alarmsCont_EL.addEventListener("mouseout", evt => {
  //longpress
  longPress_timerStop();

  //timehover
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (!aI_EL.$D.t_hov) return; //already unhovered, skip //-->

    alrm_setTorC(aI_EL, aI_EL.$D.vu_cd); //untoggle, was temporary anyway
    aI_EL.$D.t_hov= false; //hover off
  }
});

//alarm //longpress
alarmsCont_EL.addEventListener("dragstart", () => {
  longPress_timerStop();
});

//alarm (for alarmT, longpress)
alarmsCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;

  if (targ_EL.closest("div#ringerSnooze")) {
    var n;
    if (targ_EL.tagName == "SPAN") n= targ_EL.textContent *1;
    ringer_stop("snooze", n);

  } else if (targ_EL.closest("div#ringerOff")) {
    ringer_stop("off");

  } else {
    var _alarmInst_EL;
    if (_alarmInst_EL= targ_EL.closest("div.alarmInstance")) {
      alarmInst_EL= _alarmInst_EL;

      if (targ_EL.classList.contains("expired")) classEl(alarmInst_EL, "expired", false);

      if (targ_EL.classList.contains("alarmActivate")) {
        alrm_set(alarmInst_EL==active_aI_EL?false:alarmInst_EL, "button"); //toggle

      } else if (targ_EL.closest("div.alarmInfo")) {
        if (targ_EL.classList.contains("PC_tid")) PClink(targ_EL);
        else alrm_editInfo();

      } else if (targ_EL.classList.contains("alarmT")) {
        longPress_timerStop();
        if (longPress_flag) return; //-->

        alrm_editTime();

      } else if (targ_EL.classList.contains("alarmDeleteBut")) {
        alrm_delete();

      } else if (targ_EL.tagName == "INPUT") { //disabler checkbox (there can only 1 input el in alarmInstance)
        classEl(alarmInst_EL, "disabledInstance", !targ_EL.checked);
        alarms_save();
      }
    }
  }
});


wlEnable_EL.addEventListener("click", wakeLock_toggle);

//https://developer.chrome.com/blog/new-in-chrome-79/#wake-lock
var wakeLock_OBJ;
async function wakeLock_request() {
  if (document.hidden) return; //-->

	try {
		wakeLock_OBJ= await navigator.wakeLock.request();
    classEl(wlEnable_EL, "on");

  	wakeLock_OBJ.addEventListener("release", () => {
  		wakeLock_OBJ= undefined; //clear global
      classEl(wlEnable_EL, "on", false);
  	});
	} catch (err) {console.log(err.message); }
} //wakeLock_request()

async function wakeLock_release() { //note: minimizing of browser, or unfocus of browser tab, will automatically release wakeLock
	if (!wakeLock_OBJ) return; //-->

  try {await wakeLock_OBJ.release(); }
	catch (err) {console.log(err.message); }
} //wakeLock_release()


async function wakeLock_toggle() {
	if (wakeLock_OBJ) await wakeLock_release(); //off
	else await wakeLock_request(); //on
} //wakeLock_toggle()


function timecksStgs_edit() { //just snooze duration
  jm.prompt("Snooze duration (minutes, 1-30)", snooze_def_num, resp => {
    if (resp == null) return; //-->

    var v_num= resp *1;
    if (v_num == snooze_def_num) return; //same, do nothing //-->

    if (isNaN(v_num) || v_num<1 || v_num>30) {
      jm.error('Snooze must be 1-30 minutes<br><br>Your input:<b class="E">' +resp +'</b>', () => {
        timecksStgs_edit(); //try again
      });
    } else {
      snooze_def_num= v_num;
      data_save("snooze_num", snooze_def_num);
    }
  });
} //timecksStgs_edit()


var active_flag;
var active_ctdn_m;
var active_hTimO;

var aI_NL; //from .getElementsByClassName(), dynamic nodeList
var vis_ct;

function alarms_start() {
  disblr_ct= 0;
  vis_ct= 0;
  alarmsCont_EL.innerHTML= "";
  alarmInst_EL= undefined;

  //var alarms_json= localStorage.getItem("alarms");
  data_load(["active_id", "alarms"], dataO => {
    var active_id= (dataO.active_id || 0) *1; //default 0
    var alarms_json= dataO.alarms;
    var storedAl_arr= [{t:"12:00 AM"}]; //default if empty
    if (alarms_json) try {storedAl_arr= JSON.parse(alarms_json); } catch (err) {}

    //storedAl_arr is closest thing to a data model in this app
    //is totally temporary, rest of the time, data is solely in the DOM

    storedAl_arr.forEach(a_obj => {
      aInst_EL= template_alarmInst_EL.cloneNode(true); //clone
      alarmsCont_EL.appendChild(aInst_EL); //add
      alrm_addHelpers(aInst_EL, a_obj.id);
      aInst_EL.$E.Info.innerHTML= a_obj.i || ""; //alarm info
      aInst_EL.$E.Time.textContent= a_obj.t; //alarm time
      alrm_setCountdown(aInst_EL);
      if (a_obj.id == active_id) alarmInst_EL= aInst_EL; //alarm active
      if (a_obj.c) alrm_setTorC(aInst_EL, true, "persist"); //init alarm countdown view

      if (disabler_mode) alrm_drawDisablerMode(aInst_EL, a_obj.d); //disabler mode
      else if (a_obj.d) showEl(aInst_EL, false); //alarm disabled
      else vis_ct++;
    });

    aI_NL= alarmsCont_EL.getElementsByClassName("alarmInstance");

    if (autsrt_mode) autosortMode_execSet();
    else if (alarmInst_EL && !disabler_mode) alrm_set(alarmInst_EL); //active on init
  });
} //alarms_start()


var disabler_mode;
var preserved_autsrt_mode;
var disblr_ct; //for css checkbox label to work

function disablerMode_toggle() {
  if (!disabler_mode) { //turn disabler mode on}
    showEl(autoSort_EL, false);
    if (autsrt_mode) {
      preserved_autsrt_mode= true;
      autsrt_mode= false;
      autosortMode_execSet();
      alrm_clear();
    }

    if (wakeLock_OBJ) wakeLock_toggle(); //off
    showEl(wlEnable_EL, false);

  } else { //turn disabler mode off
    showEl(autoSort_EL);
    if (preserved_autsrt_mode) {
      preserved_autsrt_mode= undefined;
      autsrt_mode= true;
      //autosortMode_execSet(); //alarms_start() will do this
    }

    showEl(wlEnable_EL);
  }

  disabler_mode= !disabler_mode; //toggle
  classEl(disblabler_EL, "down", disabler_mode);
  classEl(alarmsCont_EL, "disablableContainer", disabler_mode);
  alarms_start();

} //disablerMode_toggle()



var autsrt_mode; //= localStorage.getItem("autsrt_mode") == "true"; //localStorage, will be string "true", "false"

function autosortMode_set() { //from UI
  jm.state(
    'Auto Sort Mode?<br>No manual reordering of alarms, the alarm list will automatically be sorted by deadline. Also, if no alarm is active, the first alarm will self-activate',
    autsrt_mode,
    resp => {
      if (resp==null || resp==autsrt_mode) return; //-->

      autsrt_mode= resp;
      autosortMode_execSet();
      //localStorage.setItem("autsrt_mode", autsrt_mode);
      data_save("autsrt_mode", autsrt_mode);
    }
  );
} //autosortMode_set()

function autosortMode_execSet() { //on or off
  var displ_v= autsrt_mode ? false : undefined;
  showEl(sort_EL, displ_v);
  classEl(autoSort_EL, "on", autsrt_mode);
  if (autsrt_mode) {
    alarms_execSort();
    alrm_autoActivate();
  }
} //autosortMode_execSet()


function alarmsDrag_start() {
  //dragndrop
  //adapted from: https://www.w3resource.com/javascript-exercises/event/javascript-event-handling-exercise-6.php

  var dragAl_EL;
  var prev_dragOver_EL;

  // Add event listeners for drag and drop events
  alarmsCont_EL.addEventListener("dragstart", dragStart);
  document.addEventListener("dragover", dragOver);
  document.addEventListener("drop", drop); //user can drop anywhere, listening only on dragList doesnt cut it

  //global stop drag
  document.addEventListener("click", evt => {
    if (dragAl_EL) clear("fully");
  }); //recover after a failed drop

  function dragStart(evt) {
    if (dragAl_EL) clear("fully"); //recover after a failed drop

    dragAl_EL= evt.target;
    classEl(dragAl_EL, "dragging");
    //evt.dataTransfer.effectAllowed= "move"; //what does this even do? unnecessary for this reorder functionality

    var ct= 0;
    [...aI_NL].forEach(aI_EL => {if (aI_EL.checkVisibility()) aI_EL.$D.drag_i= ct++; }); //drag index
    //.. current order, set .drag_i for each alarm
    // .drag_i is only accurate up until the drop, it must be popped upon every dragStart
  } //dragStart()

  function dragOver(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dragOver_EL= evt.target;
    var dragOvAl_EL;

    if (dragOver_EL == trash_EL) { //trash can
      if (dragOver_EL == prev_dragOver_EL) return; //-->

      if (prev_dragOver_EL) clear();
      classEl(dragOver_EL, "dropTrash");

      prev_dragOver_EL= dragOver_EL;

    } else { //not trashcan
      if (prev_dragOver_EL && prev_dragOver_EL == trash_EL) { //trash can
        clear();
        prev_dragOver_EL= undefined;
      }

      if (autsrt_mode) return; //-->

      if (dragOvAl_EL= dragOver_EL.closest("div.alarmInstance")) { //alarm instance (reorder)
        if (prev_dragOver_EL) clear();
        if (dragOvAl_EL == dragAl_EL) return; //-->

        //evt.dataTransfer.dropEffect= "move"; //what does this do? unneeded for reorder

        const boundingRect= dragOvAl_EL.getBoundingClientRect();
        const offset_y= boundingRect.y +(boundingRect.height /2);
        if (evt.clientY-offset_y < 0) {
          if (dragOvAl_EL.$D.drag_i-1 != dragAl_EL.$D.drag_i) classEl(dragOvAl_EL, "dropAbove");
        } else {
          if (dragOvAl_EL.$D.drag_i+1 != dragAl_EL.$D.drag_i) classEl(dragOvAl_EL, "dropBelow");
        }

        prev_dragOver_EL= dragOvAl_EL;
      }
    }
  } //dragOver()

  function drop(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dropOn_EL= prev_dragOver_EL; //not actual the dropOn_EL, but this allows user to make drop even with imprecise drop
    //.. if user drops outside of window, no drop event at all, accept this fact
    if (dropOn_EL) {
      if (dropOn_EL == trash_EL) {
        alarmInst_EL= dragAl_EL;
        alrm_execDelete();

      } else if (dropOn_EL.classList.contains("dropAbove") || dropOn_EL.classList.contains("dropBelow")) {

        //move in DOM..
        if (dropOn_EL.classList.contains("dropAbove")) dropOn_EL.before(dragAl_EL);
        else dropOn_EL.after(dragAl_EL);

        if (active_aI_EL) active_aI_EL.after(activeStatus_EL);

        alarms_save();
      }
    }

    clear("fully");
  } //drop()

  function clear(fully_flag) { //if not fully, just clear dragOver's class
    if (prev_dragOver_EL) prev_dragOver_EL.classList.remove("dropAbove", "dropBelow", "dropTrash");
    if (fully_flag) {
      if (dragAl_EL) classEl(dragAl_EL, "dragging", false);
      dragAl_EL= undefined;
      prev_dragOver_EL= undefined;
    }
  } //clear()

  //dragndrop
} //alarmsDrag_start()


function alrm_addHelpers(aI_EL, id) { //.dataset only stores strings
  //breaks html/js laws, but as far as js only goes, an element is just an object
  aI_EL.id= id;
  aI_EL.$D= {}; //like .data
  aI_EL.$E= { //pointers to sub els
    Activ: aI_EL.querySelector("span.alarmActivate"),
    Info: aI_EL.querySelector("div.alarmInfo"),
    Time: aI_EL.querySelector("span.alarmTime"),
    Ctdn: aI_EL.querySelector("span.alarmCountdown")
  };
} //alrm_addHelpers()

function alrm_genId() {
  var id_arr= [];
  var id;
  [...aI_NL].forEach(aI_EL => {
    if (id= aI_EL.id) id_arr.push(id *1);
  });
  var new_id= 1;
  while (id_arr.includes(new_id)) {
    new_id++;
  }
  return new_id;
} //alrm_genId()

function alrm_drawDisablerMode(aI_EL, dsbl_flag) {
  var checked_str= dsbl_flag ? "" : " checked";
  classEl(aI_EL, "disabledInstance", !!dsbl_flag); //in classEl(), flag of undefined will default to true

  aI_EL.$E.Activ.insertAdjacentHTML(
  "afterend",
  `<div class="checkbox-wrapper-18" title="Enable/Disable"><input type="checkbox" id="chkbx_${disblr_ct}"${checked_str}/><label for="chkbx_${disblr_ct}"></label></div>`
  );
  showEl(aI_EL.$E.Activ, false);
  disblr_ct++;
} //alrm_drawDisablerMode()

function alrm_glow(s =1, aI_EL =alarmInst_EL) {
  aI_EL.scrollIntoView(scrollParam);

  aI_EL.style.background= "aquamarine";
  setTimeout(() => {aI_EL.style.background= ""; }, s *1000);
} //alrm_glow()

var scrollParam= {behavior:"smooth", block:"center"};

function alrm_scrollTo(active_flag) {
  var chosen_EL;
  if (!active_flag) chosen_EL= alarmsCont_EL.querySelector("div.expired");
  if (!chosen_EL) chosen_EL= active_aI_EL;
  if (chosen_EL) chosen_EL.scrollIntoView(scrollParam);
} //alrm_scrollTo()


function alrm_editInfo(info_str, NEW_str) {
  var t_str= alarmInst_EL.$E.Time.textContent;
  if (!info_str) info_str= alarmInst_EL.$E.Info.innerHTML.replaceAll("<br>", "\n");
  jm.prompt_textarea('Alarm info (html allowed)<br>Time:<b>' +t_str +'</b>', info_str, resp => {
    if (!NEW_str && (resp==null || resp==info_str)) return; //-->
    //.. with NEW_str, 'save' must happen

    info_str= (resp || "").trim();
    if (info_str.length > 80) {
      jm.error(`Info length is up to 80 chars. Your text is ${info_str.length} chars`, () => {
        alrm_editInfo(info_str, NEW_str); //try again (and we dont throw away what you typed in)
      });
    } else {
      alarmInst_EL.$E.Info.innerHTML= info_str.replaceAll("\n", "<br>");
      alrm_glow(NEW_str ? 4 : 1);
      alarms_save();
    }
  });
} //alrm_editInfo()

function alrm_editTime(NEW_str) {
  var alrm_str= NEW_str ? "12:00" : alarmInst_EL.$E.Time.textContent;
  var livePreview_EL;

  function pop_prompt() {
    var alarmNow_obj= alrm_procTimeText(jm._ELs.Input.value, "preview");
    livePreview_EL.innerHTML= alarmNow_obj ? (alarmNow_obj.time +"<br>" +alarmNow_obj.ahead) : "";
  }

  var prom_str= g_promStr(NEW_str, alrm_str);
  timePrompt_fn();

  function timePrompt_fn() {
    jm.prompt(prom_str, alrm_str, {
      //jm custom hooks object

      begin_cb: () => {
        livePreview_EL= jm._ELs.Description.querySelector(".livePreview");
        pop_prompt();
      },

      Input_keyup: evt => { //or "aliasIO_keyup" would work also
        pop_prompt();
      },

      end_cb: resp => {
        if (resp==null || (resp==alrm_str && !NEW_str)) return; //-->

        var mod_alrm_str= resp;

        //proc input str
        var alarmNow_obj;
        if (alarmNow_obj= alrm_procTimeText(mod_alrm_str, timePrompt_fn)) {
          //.. passed time_prompt() as err_cb, try again

          if (NEW_str) {
            alrm_execAdd();
            sound_play("bell");
          }

          alarmInst_EL.$E.Time.textContent= alarmNow_obj.time;
          alrm_setCountdown();

          if (!disabler_mode && (!active_aI_EL || active_aI_EL==alarmInst_EL)) { //set is none active, or re-set if this is active
            alrm_set(alarmInst_EL);
          } else if (!autsrt_mode && !NEW_str) {
            alarms_save();
          }
          if (autsrt_mode) {
            alarms_execSort();
            alrm_autoActivate([alarmInst_EL]);
            if (!NEW_str) alarms_save();
          }
          if (NEW_str) alrm_editInfo(NEW_str, NEW_str);
          else alrm_glow();
        }
      }
    });
  } //time_prompt()

} //alrm_editTime()


var DoW2_arr= "SU,MO,TU,WE,TH,FR,SA".split(",");
var DoW_arr= "SUN,MON,TUE,WED,THU,FRI,SAT".split(",");

function alrm_procTimeText(input_str, param) { //returns truthy if raw_str is good
  var preview_flag= (typeof(param) == "string"); //'preview' will not alert errors
  var err_cb= (typeof(param) == "function") ? param : undefined;

  //.. geared toward keypad input, with some shortcuts baked in
  input_str= input_str.trim();
  var raw_str= input_str.toUpperCase();

  var time_dtO= new Date();
  var moDaO;
  if (raw_str.includes("/") || raw_str.search(/^[SMTWF]/)==0) {
    raw_str+= " ";
    let index= raw_str.indexOf(" ");
    let mD_str= raw_str.substring(0, index);
    raw_str= raw_str.substring(index +1);
    if (!raw_str) raw_str= "12"; //default midnite
    moDaO= proc_moDa(mD_str); if (!moDaO) return err("bad month/day or DoW"); //-->
  }

  var time_str;
  var offset_str, offsetMod_str;
  [time_str, offset_str]= raw_str.split(/\+|-/);
  if (offset_str) offsetMod_str= raw_str[time_str.length]; //1 char,  = or -

  var raw_hTimO;
  if (time_str) {
    raw_hTimO= g_procRawTime(time_str);

    if (raw_hTimO.h > 12) return err('bad hour:<b class="E">' +raw_hTimO.h +'"</b>max is 12'); //-->
    if (raw_hTimO.m > 59) return err('bad minute:<b class="E">' +raw_hTimO.m +'</b>max is 59'); //-->

    raw_hTimO.p= time_str.search(/P|\*/) > -1; //chars: P *
    let rawAmPm_flag= raw_hTimO.p || time_str.search(/A/) > -1; //chars: A (AM)

    if (raw_hTimO.h == 0) { //auto-derive hr from now
        let h= time_dtO.getHours(); //0-23
        if (!rawAmPm_flag) raw_hTimO.p= (h >= 12);
        let m= time_dtO.getMinutes();
        if (raw_hTimO.m <= m) { //if rawminutes less than nowminutes, goto next hour
          h++; //inc
          if (h == 24) h= 0; //wrap
          raw_hTimO.h= h;
          proc_24to12(raw_hTimO);
        }
    }

  } else {
    raw_hTimO= {
      h: time_dtO.getHours(), //0-23
      m: time_dtO.getMinutes()
    };
    proc_24to12(raw_hTimO);
  }

  if (moDaO) raw_hTimO.MD= moDaO;

  time_dtO= g_fromHTimeToDateObj(raw_hTimO);

  var ahead_str= "";

  var ofsO;
  if (offset_str) {
    ofsO= g_procRawTime(offset_str);
    if (ofsO.h +ofsO.m < 1) return err("0 hour+minute (offset mode)"); //-->

    var time_ms= time_dtO.getTime();
    var sgn_num= offsetMod_str=="+" ? 1 : -1;

    if (ofsO.m) {
      if (ofsO.m > 59) return err(`ahead minutes:<b>${ofsO.m}</b>max is 59`); //-->
      time_ms+= sgn_num *ofsO.m *60000; //60*1000 //add mns
    }
    if (ofsO.h) {
      let max_h= ofsO.m ? 23 : 24; //max 24 hrs ahead
      if (ofsO.h > max_h) return err(`ahead hours:<b>${ofsO.h}</b>max is ${max_h}`); //-->
      time_ms+= sgn_num *ofsO.h *3600000; //60*60*1000 //add hrs
    }

    ahead_str= "(OFFSET: ";
    ahead_str+= get_fmatHTime_str(raw_hTimO) + " ";
    ahead_str+= offsetMod_str +g_untilStr(ofsO.m, ofsO.h) +")";

    time_dtO= new Date(time_ms);
    //DST handled here by js date ?

  } else { //no offset given, derive for ahead_str
    let ahead_ms= time_dtO -new Date();
    ahead_str= `(in: ${g_untilStr(Math.ceil(ahead_ms /60000))})`;
  }

  function g_procRawTime(str) {
    var h= m= 0;

    var split_arr= str.split(/:|\./);
    if (split_arr.length > 1) { //contains ":" or ".", explicit hrs and mns
      h= get_nstr(split_arr[0]) *1;
      m= get_nstr(split_arr[1]) *1;

    } else { //special shorthand
      var hm_str= get_nstr(str);
      var L= hm_str.length;
      if (hm_str[0]=="0" || L<=2) { //1-2 digits, or starts with "0"
        if (hm_str[0] == "0") { //starts with "0"
          //minutes mode, eg. "01" is 1 mn, "012" is 12 mns
          //just mns, hr 0
          m= hm_str *1;
        } else { //1-2 digits
          let n= hm_str *1;
          if (n <= 12) h= n; //just hr, mn 0
          else m= n; //just mn, hr 0
        }
      } else { //3-4 digits
        //.. w "*" for 'pm', eg. 1220 .. 12:20am, or 420* .. 4:20pm
        h= hm_str.substring(0, L -2) *1; //begining, up to last 2 digits
        m= hm_str.substring(L -2) *1; //last 2 digits
      }
    }
    return {h:h, m:m};
  } //g_procRawTime()

  var hTimO= {
    h: time_dtO.getHours(), //0-23
    m: time_dtO.getMinutes()
  };
  proc_24to12(hTimO);
  if (moDaO) hTimO.MD= moDaO;

  //success
  return {
    time: get_fmatHTime_str(hTimO),
    ahead: ahead_str,
    ms: time_dtO.getTime(),
    hTimO: hTimO
  };


  function get_nstr(str) {
    return (str.match(/\d+/) || ["0"])[0]; //gets 'first' number, ignores rest //if none, will return "0"
    //note: "0" is truth-y
  }

  function get_fmatHTime_str(tO) {
    var str= "";
    if (tO.MD) str= (tO.MD.DoW ? tO.MD.DoW : ((tO.MD.mW || tO.MD.mo) +"/" +tO.MD.da)) +" ";
    return str +tO.h +":" +String(tO.m).padStart(2, "0")  +(tO.p?" PM":" AM"); //human time
  } //get_fmatHTime_str()

  function proc_24to12(tO) { //to human
    tO.p= tO.h >= 12;
    var h= tO.h;
    if (h > 12) h-= 12;
    else if (h == 0) h= 12;
    tO.h= h;
  }

  function g_fromHTimeToDateObj(htO) { //from human time 12:59am/pm, to computer time 23:59
    var dtO= new Date(); //dateobj, start as now, but most items will be re-set

    if (htO.MD) dtO.setMonth(htO.MD.mo -1, htO.MD.da); //m 0..11 //d 1..31
    //.. dont set month and date separately, because months having diff number of days, mistake can happen

    var h= htO.h;
    if (h == 12) h= 0;
    if (htO.p) h+= 12;
    dtO.setHours(h);

    dtO.setMinutes(htO.m);
    dtO.setSeconds(0);

    var diff_ms= dtO -new Date();

    if (diff_ms<1 || param=="preview_forceTurnover") { //if reqTime less than nowTime
      if (htO.MD) {
        if (htO.MD.DoW) dtO.setDate(dtO.getDate() +7); //+1 week //DayOfWeek
        else if (htO.MD.mW) dtO.setMonth(dtO.getMonth() +1); //+1 month //mon_wildcard_str
        else dtO.setFullYear(dtO.getFullYear() +1); //+1 year
      } else {
        dtO.setDate(dtO.getDate() +1); //+1 day
      }
      //DST handled here by js date ?
    }

    return dtO;
  } //g_fromHTimeToDateObj()

  function err(err_str) {
    if (preview_flag) return; //-->

    jm.error('Alarm time error caused by<br>' +err_str +'<br><br>Your raw input: <b class="E">' +input_str +'</b>', err_cb);
    //multiple errors are not returned, only the first error encountered
  }

  function proc_moDa(mD_str) { //if success, returns obj
    var mon_wildcard_str;
    var DoW_str;
    if (mD_str.includes("/")) { //mon/day
      var month, day;
      [month, day]= mD_str.split("/");

      month*= 1;
      if (isNaN(month) || month<1 || month>12) {
        mon_wildcard_str= "?"; //month wildcard
        month= time_dtO.getMonth() +1; //no month? assume this month
      }

      day*= 1;
      if (isNaN(day) || day<1 || day>31) day= 1; //not verifying against number of days in month

    } else if (mD_str.search(/^[SMTWF]/) == 0) { //Day of Week
      var f2_str= mD_str.substring(0, 2); //"SU" is ok, "S" is not
      if (f2_str.length < 2) return; //-->

      var raw_DoW_n= DoW2_arr.indexOf(f2_str);
      if (raw_DoW_n < 0) return; //-->

      DoW_str= DoW_arr[raw_DoW_n];

      var copy_dtO= new Date(time_dtO); //lets not change time_dtO here
      var DoW_diff_n= raw_DoW_n -copy_dtO.getDay(); //.getDay(), could be called getDoW, returns 0-6 (sun-sat)
      if (DoW_diff_n) {
        if (DoW_diff_n < 0) DoW_diff_n+= 7;
        copy_dtO.setDate(copy_dtO.getDate() +DoW_diff_n); //getDate() will change month/day correctly
      }
      month= copy_dtO.getMonth() +1;
      day= copy_dtO.getDate(); //.getDate(), could be called getDay, returns 1-31

    } else {
      return; //fail //-->
    }

    var o= {
      mo: month,
      da: day
    };
    if (DoW_str) o.DoW= DoW_str;
    if (mon_wildcard_str) o.mW= mon_wildcard_str;

    //success
    return o;
  } //proc_moDa()

} //alrm_procTimeText()


function alrm_setTorC(aI_EL, flag, persist_flag) {
  if (aI_EL == active_aI_EL) jm.alert('Default view stored, will be displayed when this is not the active alarm');
  else alrm_setCtdnView(aI_EL, flag);

  if (persist_flag) aI_EL.$D.vu_cd= flag;
} //alrm_setTorC()

function alrm_setCtdnView(aI_EL, flag) {
  showEl(aI_EL.$E.Ctdn, flag ? "inline-block" : false);
  showEl(aI_EL.$E.Time, !flag ? "inline-block" : false);
} //alrm_setCtdnView()

function alrm_setCountdown(aI_EL =alarmInst_EL, preview_str ="preview") {
  var alarmNow_obj= alrm_procTimeText(aI_EL.$E.Time.textContent, preview_str);
  if (alarmNow_obj) {
    var ms= alarmNow_obj.ms -new Date();
    if (ms < 60000) ms= 60000; //minimum of 1 minute
    aI_EL.$D.ctdn_m= Math.ceil(ms /60000);
    aI_EL.$E.Ctdn.textContent= g_untilStr(aI_EL.$D.ctdn_m);
    alrm_checkSoon(aI_EL);
  }
} //alrm_setCountdown()

function alrm_checkSoon(aI_EL) {
  var soon_flag= aI_EL.$D.ctdn_m < 720;
  if (aI_EL.$D.soon == soon_flag) return; //-->

  classEl(aI_EL, "soon", soon_flag);
  aI_EL.$D.soon= soon_flag; //.$D.soon, 'soon', session var, not saved
} //alrm_checkSoon()


function alrm_add() { //from UI
  alrm_editTime("NEW");
} //alrm_add()

function alrm_execAdd() { //add 1
  var clAlrmInst_EL= template_alarmInst_EL.cloneNode(true); //clone
  alrm_addHelpers(clAlrmInst_EL, alrm_genId());
  alarmsCont_EL.appendChild(clAlrmInst_EL); //add to DOM
  if (disabler_mode) alrm_drawDisablerMode(clAlrmInst_EL);
  alarmInst_EL= clAlrmInst_EL;
} //alrm_execAdd()

function alrm_delete() { //from UI
  var prom_str= g_promStr();
  jm.agree('Delete?<br>' +prom_str, 0, resp => {
    if (resp != true) return; //null or false //-->

    alrm_execDelete();
  });
} //deleteAlarm()

function alrm_execDelete() { //delete 1
  alrm_exeDel();
  alarms_save();
  sound_play("trsh");
} //alrm_execDelete()

function alrm_exeDel() {
  if (!alarmInst_EL) return; //-->

  alarmInst_EL.remove(); //from DOM
  if (alarmInst_EL == active_aI_EL) alrm_set(false); //if alarm was on, turn off
  alarmInst_EL= undefined;
} //alrm_exeDel()


function g_promStr(str, t_str) {
  var alStrO;
  if (!str || !t_str) alStrO= g_alStrO(alarmInst_EL);
  return `Alarm info:<b>${str || alStrO.inf}</b><br>Time:<b class="livePreview">${t_str || alStrO.tim}</b>`;
} //g_promStr()

function g_alStrO(aI_EL) {
  var str= aI_EL.$E.Info.innerHTML.replaceAll("<br>", " | ");
  var tmp_doc= new DOMParser().parseFromString(str, 'text/html');
  str= (tmp_doc.body.textContent || "").substring(0, 40);
  return {
    inf: str,
    tim: aI_EL.$E.Time.textContent
  };
} //g_alStrO()


function alrm_clear() { //use this to clear, alrm_set(false) does more than just clear
  action_flag= undefined;
  active_aI_EL= undefined;
} //alrm_clear()

function alrm_set(aI_EL, button_flag) {
//console.trace("alrm_set", aI_EL?aId(aI_EL):aI_EL)
  var flag= !!aI_EL; //to boolean
  if (flag) {
    var alrm_str= aI_EL.$E.Time.textContent;
    var alarmNow_obj= alrm_procTimeText(alrm_str); //nrn, final check of alrm_str
    if (!alarmNow_obj) {
      flag= false;
console.log("bad alarm time", alrm_str)
    }
  } //flag
  if (active_aI_EL) { //prev alarm off
    classEl(active_aI_EL, "alarmActive", false);
    classEl(active_aI_EL, "expired", false);
    alrm_setCtdnView(active_aI_EL, active_aI_EL.$D.vu_cd);
  }

  if (flag) { //alarm on
    active_flag= true;
    active_aI_EL= aI_EL;
    active_ctdn_m= aI_EL.$D.ctdn_m;
    active_hTimO= alarmNow_obj.hTimO;
    activeCountdown_EL.textContent= g_untilStr(active_ctdn_m);

    classEl(aI_EL, "alarmActive");
    aI_EL.after(activeStatus_EL);
    showEl(activeStatus_EL);
    showEl(activeCountdown_EL);
    alrm_setCtdnView(aI_EL, false); //if needed

    clockMarker_n= undefined;
    clock_checkMarker();

    sound_play("beep");

    alrm_scrollTo();
    if (!wakeLock_OBJ) wakeLock_toggle(); //on

  } else { //alarm off
    active_flag= false;
    active_aI_EL= undefined;
    active_ctdn_m= 0;

    showEl(activeStatus_EL, false);
    showEl(cf_marker_EL, false);

    sound_play("slam");

    if (autsrt_mode && !button_flag) alrm_autoActivate();
  }

  if (!autsrt_mode) data_save("active_id", active_aI_EL ? active_aI_EL.id*1 : 0); //active_id save
} //alrm_set()

function alrm_expireMsg(aI_EL) {
  var alStrO= g_alStrO(aI_EL);
  var msg_EL= message_add("Alarm expired: " +alStrO.tim +" | " +alStrO.inf, "pink");
  msg_EL.$exp_aI_EL= aI_EL;
} //alrm_expireMsg()


function alarms_update(mnt_n) {
  sysAlarm_check(sync_ms);

  if (!vis_ct) return; //-->

  var autoTurnover_flag;
  var until_str;
  [...aI_NL].forEach(aI_EL => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in disabler_mode all are visible)
      aI_EL.$D.ctdn_m+= mnt_n;
      if (active_flag && aI_EL==active_aI_EL) active_ctdn_m= aI_EL.$D.ctdn_m;

      alrm_checkSoon(aI_EL);

      if (aI_EL.$D.ctdn_m < 1) {
        classEl(aI_EL, "expired");
        alrm_setCountdown(aI_EL, "preview_forceTurnover");
        if (aI_EL != active_aI_EL) alrm_expireMsg(aI_EL);
        if (autsrt_mode) autoTurnover_flag= true;
      }

      until_str= g_untilStr(aI_EL.$D.ctdn_m);
      if (until_str != aI_EL.$E.Ctdn.textContent) aI_EL.$E.Ctdn.textContent= until_str;
      //.. alarms 1+ days, dont need to re-render every minute

    } //skip not visible
  });

  if (active_flag) {
    if (active_ctdn_m < 1) { //end alarm countdown
      active_flag= false;
      showEl(activeCountdown_EL, false);
      ringer_start();
    } else {
      activeCountdown_EL.textContent= g_untilStr(active_ctdn_m);
      clock_checkMarker();
    }

  } else if (snooze_ctdn_m) {
    snooze_ctdn_m--; //inc-
    snooze_check();
  }

  if (autoTurnover_flag) alarms_execSort();
} //alarms_update()

function alrm_autoActivate(override_arr =[]) { //auto-activate top alarm
  if (!vis_ct) return; //-->

  var topAI_EL= [...aI_NL].find(aI_EL => aI_EL.checkVisibility()); //skip disabled
  if (topAI_EL && topAI_EL!=active_aI_EL && (!active_aI_EL || override_arr.includes(topAI_EL))) {
  //  obvious     redundant                 dont override active, unless its in override_arr
    alrm_set(topAI_EL);
  }
} //alrm_autoActivate()

function alarms_sort(evt) { //from UI
  if (evt.ctrlKey) {
    alarms_execSort();

  } else {
    jm.confirm('Sort alarms by date/time?', resp => {
      if (resp) alarms_execSort();
    });
  }
} //alarms_sort()

function alarms_execSort() {
  if (!vis_ct) return; //-->

  [...aI_NL]
    .sort((a, b) => a.$D.ctdn_m > b.$D.ctdn_m ? 1 : -1)
    .forEach(aI_EL => alarmsCont_EL.appendChild(aI_EL)) //reorder in DOM
  ;
  if (active_aI_EL) active_aI_EL.after(activeStatus_EL);

  alrm_scrollTo();

  if (!autsrt_mode) alarms_save();
  sound_play("clik");
} //alarms_execSort()

function alarms_import(imported_str) {
  //localStorage.setItem("importedAlarm", "");
  data_save("importedAlarm", "");

  var action_str;
  var spl_ar;
  var time_str, tSpl_ar;
  var alarmNow_obj;
  var html_str;
  var k_str; //keeper
  var add_arr= []; //for sound only
  var del_arr= []; //for sound only
  imported_str.split("\n").forEach(item_str => {
    spl_ar= item_str.split("|");
    //external|WED 5/5 12:34pm|PC|New%20York%20Yankees|K|123-1 //to test, can paste right into console "Local storage"
    //0        1               2  3                    4 5
    action_str= spl_ar[0]; //external, externalDelete
//console.log(action_str,"item_str",item_str,"split",spl_ar);
    if (spl_ar[2] == "PC") { //qualify
      if (action_str == "external") {
        time_str= spl_ar[1]; //WED 5/5 12:34pm
        tSpl_ar= time_str.split(" ");
        if (alarmNow_obj= alrm_procTimeText(`${tSpl_ar[1]} ${tSpl_ar[2]} -20`, "preview")) { // -20 minutes
          alrm_execAdd();

          k_str= spl_ar[4] ? " (K)" : "";
          html_str= `${tSpl_ar[0]}<br><b>${spl_ar[3]}</b>${k_str} <b class="PC_tid" title="?">${spl_ar[5]}</b>`;
          alarmInst_EL.$E.Info.innerHTML= html_str;

          alarmInst_EL.$E.Time.textContent= alarmNow_obj.time;
          alrm_setCountdown();
          alrm_glow(4);
          add_arr.push(alarmInst_EL); //for sound only
        }

      } else if (action_str == "externalDelete") {
        //externalDelete|123-1|PC
        //0              1   2
        let tid= spl_ar[1];
        let delTid_EL= [...alarmsCont_EL.querySelectorAll("b.PC_tid")]
          .find(EL => EL.textContent == tid)
        ;
console.log("externalDelete tid",tid, "delTid_EL",delTid_EL) //debug
        if (delTid_EL) { //if multiple alarms with this tid, only 1st alarm deleted //so edge its silly
          del_arr.push(delTid_EL); //for sound only
          alarmInst_EL= delTid_EL.closest("div.alarmInstance");
          alrm_exeDel();
        } else {
          message_add("External-delete of " +tid +" failed");
        }

      } //action_str
    } //PC
  });

  sound_play("bell", add_arr, 1500); //1400, bell is longish clip
  sound_play("trsh", del_arr, 1000);
  //when both add and de, sounds prob mess up

  if (add_arr.length || del_arr.length) {
    if (autsrt_mode) {
      alarms_execSort();
      alrm_autoActivate(add_arr);
    }
    alarms_save();
  }
} //alarms_import()

function alarms_save() {
  vis_ct= 0;
  var saveAl_arr= []; //another temporary data model
  if (aI_NL.length) {
    var a_obj;
    var info_str;
    [...aI_NL].forEach(aI_EL => {
      a_obj= {id:aI_EL.id *1, t:aI_EL.$E.Time.textContent}; //id, time
      if (info_str= aI_EL.$E.Info.innerHTML) a_obj.i= info_str;
      if (aI_EL.$D.vu_cd) a_obj.c= 1; //countdown view

      if (disabler_mode ? !aI_EL.querySelector("input").checked : !aI_EL.checkVisibility()) a_obj.d= 1; //disabled
      else vis_ct++;

      saveAl_arr.push(a_obj);
    });
  }
//console.trace("alarms_save",savestoredAl_arr)
  //localStorage.setItem("alarms", JSON.stringify(saveAl_arr));
  data_save("alarms", JSON.stringify(saveAl_arr));
} //alarms_save()


var ringerOverlay_EL= document.querySelector("div#ringerOverlay");
ringerOverlay_EL.addEventListener("click", () => {
  ringer_stop(); //snooze
});

var ringerCont_EL= document.querySelector("div#ringerCont");
var ringerSnooze_EL= ringerCont_EL.querySelector("div#ringerSnooze")
var rSnzCountdown_EL= ringerCont_EL.querySelector("div#rSnzCountdown");

var ring_flag;
var ring_intimerId;
var snooze_ctdn_m;

function ringer_start() {
  ring_flag= true;
  alrm_scrollTo("activeAlarm");
  sound_play("rngr");
  showEl(ringerOverlay_EL);
  showEl(ringerCont_EL);
  ring_intimerId= setInterval(() => { //recurse
    ringerOverlay_EL.classList.toggle("flash");
    sound_play("rngr");
  }, 5000);
} //ringer_start()

//note: for ringer start, if these are 'in progress'...
//longPress, should be ok, process normally
//drag, will be just be an unsuccessful drop
//modal, as if it was 'paused'

function ringer_stop(flag, snooze_n) { //without flag, default is 'snooze'
  if (!ring_flag) return; //-->

  if (ring_intimerId) {
    clearInterval(ring_intimerId);
    ring_intimerId= undefined;
    ringerOverlay_EL.classList.remove("flash");
  }

  if (flag == "off") {
    sound_play("slam"); //ringer-off slam
    showEl(activeStatus_EL, false);
    showEl(ringerOverlay_EL, false);
    showEl(ringerCont_EL, false);
    snooze_ctdn_m= 0; //if needed
    classEl(ringerSnooze_EL, "but-active", false); //if needed
    ring_flag= false;
    alrm_set(false);

  } else { //snooze
    //note: snooze wont be exact, since it only checks/fires at top of minute
    //eg. 5 minutes will be 4-5 minutes
    snooze_ctdn_m= snooze_n || snooze_def_num;
    classEl(ringerSnooze_EL, "but-active");
    sound_play("snoz");
  }

  snooze_draw(); //if needed
} //ringer_stop()

function snooze_draw() {
  rSnzCountdown_EL.innerHTML= snooze_ctdn_m ? g_untilStr(snooze_ctdn_m) : "&nbsp;";
} //snooze_draw()

function snooze_check() {
  snooze_draw();
  if (!snooze_ctdn_m) { //end snooze
    classEl(ringerSnooze_EL, "but-active", false);
    ringer_start();
  }
} //snooze_check()

function g_untilStr(m, h) {
  if (m >= 1440) {
   str= Math.floor(m /1440) +"d";

  } else {
    var mnt_flag;
    if (h == undefined) {
      mnt_flag= true;
      if (m > 59) {
        h= Math.floor(m /60);
        m= m %60;
      }
    }
    var str= h ? (h +"h") : "";
    if (mnt_flag || m) str+= " " +m +"m";
  }

  return str || "0";
} //g_untilStr()


var bC= new BroadcastChannel("bc0");
bC.postMessage("init");

var bC_dupe_flag;
bC.onmessage= evt => {
//console.log("bC", evt)
  if (evt.data == "init") bC.postMessage("dupe");
  else if (evt.data == "dupe") bC_dupe_flag= true;
};


function PClink(tid_EL) {
  var tid= tid_EL.textContent;
  var lgid= tid.split("-")[0];
  var tname= tid_EL.closest("div.alarmInfo").querySelector("b").textContent; //tree up then down
  //div.alarmInfo will contain 2 <b>, 1st will be teamname, 2nd will be tid with <b class="PC_tid">
  jm.alert(`PennantChase<br>lg${lgid} ${tname}<a href="https://www.pennantchase.com/lgTeamLineup.aspx?tid=${tid}&lgid=${lgid}" target="_blank">Lineup</a>`);
} //PClink()


function message_add(str, bgColor_str) {
  showEl(msgHeader_EL);
  msg_EL= template_msgInst_EL.cloneNode(true); //clone
  msgCont_EL.appendChild(msg_EL); //add
  msg_EL.querySelector("div.msgInfo").innerHTML= str;
  if (bgColor_str) msg_EL.style.background= bgColor_str;
  return msg_EL; //bonus get
} //smessage_add()

function message_remove(msg_EL) {
  var exp_aI_EL;
  if (exp_aI_EL= msg_EL.$exp_aI_EL) classEl(exp_aI_EL, "expired", false);

  msg_EL.remove();
} //message_remove()


var sysAlarms_arr= [];
var sysAlarms_lu= {};

function sysAlarm_addOrDel(name_str, ms, handler) {
  var sAO;
  if (ms != undefined) { //add
    sAO= {n:name_str, ms:ms, handler:handler};
    sysAlarms_arr.push(sAO);
    sysAlarms_lu[name_str]= sAO;

  } else { //del
    sAO= sysAlarms_lu[name_str];
    sysAlarms_arr.splice(sysAlarms_arr.indexOf(sAO), 1);
    delete sysAlarms_lu[name_str];
  }
} //sysAlarm_addOrDel()

function sysAlarm_check(ms) {
  if (!sysAlarms_arr.length) return; //-->

  sysAlarms_arr.forEach(sAO => {
    if (ms >= sAO.ms) {
      if (sAO.handler) { //handler goes first
        if (sAO.handler(sAO, ms)) return; //handler can abort sAO removal //-->
      }

      message_add(sAO.n);
      sysAlarm_addOrDel(sAO.n); //delete sysAlarm
    }
  });
} //sysAlarm_check();


var clock_TZ= Intl.DateTimeFormat().resolvedOptions().timeZone;
//timezone change can happen any minute, so not going to check for it, user needs to manually do browser reload
var clock_tzo;
var tzoc_arr;

function tzoc_start() { //runs upon startup
  clockFace_EL.title= clock_TZ;

  clock_tzo= start_dtO.getTimezoneOffset();
  var year_n= start_dtO.getFullYear();
  var tzYear_key= clock_TZ +"_" +year_n;
  data_load("tzoc", dataO => proc_tzoc(dataO.tzoc));

  function proc_tzoc(tz_str) {
    if (!tz_str) tz_str= ""; //param default only works if undeined
    var tz_ar= tz_str.split(",");
    if (tz_ar[0] != tzYear_key) { //init (annually if no travel)
      //.. if user never turns off this app, wont reset annually, edge
      var raw_arr= tzoc_getDates(year_n);
//console.log(raw_arr)
      if (raw_arr[0] == year_n) { //nrn
        raw_arr[0]= tzYear_key;

        message_add("Timezone offset changes for " +raw_arr.join(", "));

        tz_str= raw_arr.join(",");
        data_save("tzoc", tz_str);

        tz_ar= raw_arr;
      }
    }

    tzoc_arr= [];
    var alarmNow_obj, ms;
    tz_ar.forEach((str, i) => {
      if (i == 0) { //tzYear_key
        tzoc_arr[0]= str;
      } else {
        alarmNow_obj= alrm_procTimeText(str, "preview");
        ms= alarmNow_obj ? alarmNow_obj.ms : 0;
        tzoc_arr[i]= {t:str, ms:ms};
      }
    });

    tzoc_check(start_dtO);

  } //proc_tzoc()

} //tzoc_start()

function tzoc_check(dtO) { //noon and midnite
  if (tzoc_arr.length <= 1) return; //just tzYear_key, no dates //-->

  var now_ms= dtO.getTime();
  var until_ms= now_ms +43200000; //12hr
  var ms;
  tzoc_arr.forEach((tzO, i) => {
    if (i) { //skip tzYear_key
      ms= tzO.ms;
      if (ms >= now_ms && ms <= until_ms) add_sysAlm(tzO);
    }
  });

  function add_sysAlm(tzO) {
    var name_str= "Time zone offset change: " +tzO.t;
    if (sysAlarms_lu[name_str]) return; //skip, already added //-->

    sysAlarm_addOrDel( //add
      name_str,
      tzO.ms,
      function(sAO, ms) { //handler
        var dtO= new Date();
        var tzo= dtO.getTimezoneOffset(); //est 300, dst 240
        var diff_tzo= clock_tzo -tzo; //0, +- 60
        if (!diff_tzo) return "abort_sAO_removal"; //-->
        //.. can happen if clock is slighly ahead
        //.. will try again next minute

        clock_tzo= tzo;
        var diff_hr= Math.sign(diff_tzo); // +- 1

        //https://www.timeanddate.com/time/dst/transition.html
        console.log("TZO change", diff_hr, g_fmatDtO(sync_dtO)); //DST change -1 @3:00:00.013

        //becomes 3am (forward) or 1am (back) ..
        cf_degO.hr+= diff_hr *cf_h_inc *60;
        clock_drawHands();

        clock_hr24= dtO.getHours(); //reset

        sound_play("clik");
      } //handler
    );
  } //add_sysAlm()

} //tzoc_check()

function tzoc_getDates(year_n) { //determine time zone offset changes for current year
  //based on the time/location settings of computer, so should work anywhere
  //generate dates once a year (after new year)
  var arr= [year_n];
  var dtO= new Date(year_n, 0);

  //month: 0-11, 0 indexed
  var first_month_i= 0;
  var last_month_i= 11;
  var ftzo_obj;
  var date_str;

  var first_i= first_month_i;
  var prev_tzo;
  do {
    dtO.setDate(1); dtO.setHours(0); //reset
    ftzo_obj= find_tzoChg(first_i , last_month_i, "setMonth", prev_tzo);
    //note: if tzo changes on and off within a month, we wont catch it, edge or non-issue
    date_str= ftzo_obj ? find_tzoChgInMonth(year_n, ftzo_obj.i) : ""; //date_str also acts as success flag
    if (date_str) {
      arr.push(date_str);
      if (ftzo_obj.i >= last_month_i) {
        date_str= undefined; //break
      } else {
        first_i= ftzo_obj.i +1;
        prev_tzo= ftzo_obj.tzo;
        //next
      }
    }
  } while (date_str)

  return arr;
  //end


  function find_tzoChg(first_i, last_i, dFn_key, prev_tzo) { //note: param 2 is last_i, not .length
    var tzo;
    //Loop through every month of the current year
    for (var i=first_i; i<=last_i; i++) {
      dtO[dFn_key](i); //set month or day
      tzo= dtO.getTimezoneOffset();
//console.log(dFn_key,first_i,i,tzo,dtO)
      if (prev_tzo!=undefined && tzo!=prev_tzo) return {i:i -1, tzo:tzo}; //success //-->
      //.. i -1, change occurs in the previos unit (hr, day, month)

      prev_tzo= tzo;
    }
  } //find_tzoChg()

  function find_tzoChgInMonth(year, month) {
    var ftzo_obj;
    dtO.setMonth(month);
    var daysInMonth= new Date(year, month+1, 0).getDate(); //use the 'next' month, minus 1 day (day 0) //month is 0 indexed, day is 1 indexed
    ftzo_obj= find_tzoChg(1, daysInMonth, "setDate");
    if (!ftzo_obj) return; //-->

    var day= ftzo_obj.i;
    dtO.setDate(day);
    ftzo_obj= find_tzoChg(0, 23, "setHours");
    if (!ftzo_obj) return; //-->

    var hour= ftzo_obj.i;

    //to human read
    month++;
    hour++;
    var amPm_str= hour>=12 ? "PM" : "AM";
    hour= hour%12;
    if (hour == 0) hour= 12;
    return month +"/" +day +" " +hour +":00" +amPm_str;
  } //find_tzoChgInMonth()

} //tzoc_getDates()



// Brwswer-app SyncStorage (eg. chrome.storage.sync)
var bssExt_id= "godombgbodbkfgippjbjjfdamclabjij";
var bssExt_flag;
var useBssExt_flag;

if (chrome.runtime) {
  chrome.runtime.sendMessage(bssExt_id, {action:"get_version"}, resp => {
//console.log("resp", resp);
    if (chrome.runtime.lastError) {
      console.log("c.r.err", chrome.runtime.lastError);
    } else if (resp && resp.vers) {
      console.log("bssExt", resp.vers);
      bssExt_flag= true;
useBssExt_flag= true; /////make into a setting //tbd
    }
  });
}

function data_load(key, cb) {
  var keys_arr= Array.isArray(key) ? key : [key];
  var dataO;
  if (useBssExt_flag) {
    chrome.runtime.sendMessage(bssExt_id, {action:"get", reqDataO:keys_arr}, resp => {
//console.log("load bss", key, "resp", resp);
      dataO= resp;
      if (cb) cb(dataO);
    });

  } else {
    dataO= {};
    keys_arr.forEach(k => dataO[k]= localStorage.getItem(k) );
//console.log("load LS", key, "dataO", dataO);
    if (cb) cb(dataO);
  }
} //data_load()

function data_save(key, data, cb) { //can only save 1 item per call
  //.. note: alarms is always all alarms, no such thing as saving 1 alarm

  localStorage.setItem(key, data); //always save to localStorage, even if useBssExt_flag

  if (useBssExt_flag) {
    var dataO= {};
    dataO[key]= data;
    chrome.runtime.sendMessage(bssExt_id, {action:"set", reqDataO:dataO}, resp => {
//console.log("save bss", key, "resp", resp);
      if (cb) cb(resp);
    });

  } else {
//console.log("save LS", key, "data", data);
    if (cb) cb("set");
  }
} //data_save()

/*
//localStorage doesnt have 'getKeys'
function getAllLocalStorageKeys() {
  const keys = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    keys.push(key);
  }
  return keys;
}
const allKeys = getAllLocalStorageKeys();
console.log(allKeys);


// console test
//actions:
// set (reqDataO is a hash)
// get
// remove
// getBytesInUse (reqDataO can be null to get all)
// getKeys (reqDataO not needed)

var bssExt_id= "godombgbodbkfgippjbjjfdamclabjij";
chrome.runtime.sendMessage(bssExt_id, {action:"remove", reqDataO:"testV"}, (resp) => {
  console.log("resp", resp);
});
*/


function sound_play(ac_key, repeat_n =1, step_ms =750) {
  if (typeof(repeat_n) == "object") repeat_n= repeat_n.length; //repeat_n. passed in an arr
  if (!repeat_n) return; //-->

  if (repeat_n == 1) {
    audioClips[ac_key].play();
    return; //-->
  }

  var ct= 0;
  step_play(); //kickoff

  function step_play() {
    audioClips[ac_key].play();
    ct++;
    if (ct < repeat_n) setTimeout(step_play, step_ms); //recurse //-->
  }
} //sound_play()

//utils
function showEl(el, display_str ="block") {
  if (el) el.style.display= display_str==false ? "none" : display_str;
}
function classEl(el, class_str, flag =true) {
  if (el) el.classList[flag?"add":"remove"](class_str);
}


//jm (modal)
var jm= {
  _ELs: {},
  _type: 0,
  _end_cb: 0,

  init: function() {
    //pop jm._ELs (aliasIO is dynamically assigned)
    "div#jwmOverlay, span#jwmCloseBut, div#jwmDescription, input#jwmInput, textarea#jwmTextarea, button#jwmOkBut, button#jwmNoBut, button#jwmCancelBut".split(", ").forEach(sel_str => {
      jm._ELs[sel_str.split("#")[1].replace("jwm", "")]= document.querySelector(sel_str);
      //note: jid is the element id with the "jwm" removed
    });

    //modal handlers
    document.addEventListener("keyup", evt => { //capture any keyup
      if (document.body.classList.contains("jw-modal-active")) { //modal active
        if (evt.key=="Escape" || (evt.key=="Enter" && !evt.shiftKey)) jm._respond(evt.key);
        //since modal can contain textarea, no 'nav' keys should be captured (arrow, tab)
        //also shift-enter allows linebreak in textarea
        else if (jm._type.includes("BOOLEAN")) jm._booleanProc(evt.key); //however, this does do 'nav' keys
      }
    });

    jm._mouseHandler("Overlay_mousedown", evt => { //"click" can get accidental "click"
      if (evt.target.id == "jwmOverlay") jm._respond("Overlay Click"); //closeModal

    });

    jm._mouseHandler("OkBut", evt => {
      if (jm._type.includes("BOOLEAN")) jm._ELs.aliasIO.value= "OK";
      jm._respond();
    });

    jm._mouseHandler("NoBut", evt => {
      jm._ELs.aliasIO.value= "NO";
      jm._respond();
    });

    jm._mouseHandler("CancelBut", evt => {
      jm._respond("CANCEL");
    });

    jm._mouseHandler("CloseBut", evt => {
      jm._respond("CLOSE");
    });

  }, //init()

  dialog: function(type_str, text_str, value_str, cb) { //ck, non blocking modal
    //all types can have cb (callback)

    if (document.body.classList.contains("jw-modal-active")) { //modal active
      console.error("Modal occupied");
      return; //abort //-->
    }

    jm._displayEls("Input,Textarea,NoBut,CancelBut", false);
    jm._classEls("OkBut,NoBut", "hilite", false);
    jm._classEls("OkBut", "toggleable", false);
    jm._ELs.aliasIO= jm._ELs.Input; //for .Input or .Textarea
    jm._ELs.OkBut.textContent= "OK";

    if (typeHas(/ALERT|ERROR|CONFIRM|BOOLEAN/)) {
      jm._ELs.aliasIO.value= "OK";

      if (typeHas("BOOLEAN_")) {
        jm._displayEls("NoBut,CancelBut", "inline");
        jm._classEls("OkBut", "toggleable");
        jm._ELs.OkBut.textContent= typeHas("AGREE") ? "Yes" : "On";
        jm._ELs.NoBut.textContent= typeHas("AGREE") ? "No" : "Off";
        var state_flag= !!value_str; //to boolean
        //.. local var
        if (!state_flag) jm._ELs.aliasIO.value= "NO";
        //.. actual value kept in aliasIO.value as string ("OK", "NO")
        jm._booleanProc(); //hilte only

      } else if (typeHas("CONFIRM")) { //CONFIRM is just an ALERT with a Cancel button
        jm._displayEls("CancelBut", "inline");

      } else if (typeHas("ERROR")) sound_play("buzz");

    //} else if (type_str.search(/PROMPT$|PROMPT_TEXTAREA/) > -1) {
    } else if (typeHas("PROMPT_")) {
      if (typeHas("PROMPT_TEXTAREA")) jm._ELs.aliasIO= jm._ELs.Textarea;

      jm._ELs.aliasIO.value= value_str;

      jm._displayEls("aliasIO");
      jm._displayEls("CancelBut", "inline");

    } else {
      console.error("jm.dialog, bad type_str:", type_str);
      return; //-->
    }

    function typeHas(v) { //v can be string or regEx
      return (typeof(v)=="string" ? type_str.indexOf(v) : type_str.search(v)) > -1;
    }

    jm._type= type_str;
    jm._ELs.Description.innerHTML= text_str;

    if (cb) {
      if (typeof(cb) == "object") { //custom hooks object
        if (cb.begin_cb && typeof(cb.begin_cb)=="function") cb.begin_cb();
        jm._customHooks(cb, true); //add listeners
      } else if (typeof(cb) != "function") { //otherwise should a fn (that is the 'end' callback)
        cb= undefined; //error, no message
      }
    }
    jm._cb= cb;

    jm.openModal("jwmModal");

    if (typeHas("PROMPT_INPUT")) jm._ELs.aliasIO.select();
    else jm._ELs.aliasIO.focus(); //for textarea, if all text is highlighted, enter key will delete the text!
  },

  alert: function(text_str, cb) {
    jm.dialog("ALERT", text_str, "", cb); //returns true or null
  },
  error: function(text_str, cb) {
    jm.dialog("ERROR", text_str, "", cb); //returns true or null
  },
  confirm: function(text_str, cb) {
    jm.dialog("CONFIRM", text_str, "", cb); //returns true or null
  },

  agree: function(text_str, value_flag, cb) {
    jm.dialog("BOOLEAN_AGREE", text_str, value_flag, cb); //returns true or false or null
    //param called value_flag here, but jm.dialog will still call it value_str
  },

  state: function(text_str, value_flag, cb) {
    jm.dialog("BOOLEAN_STATE", text_str, value_flag, cb); //returns true or false or null
    //param called value_flag here, but jm.dialog will still call it value_str
  },

  prompt: function(text_str, value_str, cb) {
    jm.dialog("PROMPT_INPUT", text_str, value_str, cb); //returns string or null
  },
  prompt_textarea: function(text_str, value_str, cb) {
    jm.dialog("PROMPT_TEXTAREA", text_str, value_str, cb); //returns string or null
  },

  _booleanProc: function(key) {
    //boolean dialogs have 2 buttons (Yes/No or On/Off) and Cancel
    //they are highlightable by nav keys, and is submittable by shortcut key (Y/N)
    var state_flag= jm._ELs.aliasIO.value == "OK"; //local var
    var submit_flag;

    if (key) { //key capture
      key= key.toUpperCase();
      if (key=="Y" || key=="N") {
        state_flag= value= key=="Y";
        submit_flag= true;
      } else if (key.indexOf("ARROW") == 0) {
        state_flag= !state_flag; //toggle
      }
      jm._ELs.aliasIO.value= state_flag ? "OK" : "NO";
    }

    //highlight Y/N Button
    liteBut("OkBut", state_flag);
    liteBut("NoBut", !state_flag);
    function liteBut(jid, flag) {
      classEl(jm._ELs[jid], "hilite", flag);
    }

    if (submit_flag) jm._respond(); //btw, closes modal
  },

  _respond: function(act_code ="") {
    if (jm._type=="ALERT" && act_code=="Escape") return; //-->
    //hacky - but dont allow esc key for ALERT, because it wont satisfy browser restriction for sound to play

    jm.closeModal();

    var cb= jm._cb;
    if (!cb) return; //-->

    var resp= true;
    if (act_code.search(/Overlay Click|Escape|CANCEL|CLOSE/) > -1) {
      resp= null;
    } else if (jm._type.includes("PROMPT_")) {
      resp= jm._ELs.aliasIO.value;
    } else if (jm._type.includes("BOOLEAN_")) {
      resp= (jm._ELs.aliasIO.value == "OK"); //to boolean
    }

    if (typeof(cb) == "object") {
      jm._customHooks(cb, false); //remove listeners
      if (cb.end_cb) cb.end_cb(resp);
    } else {
      cb(resp);
    }

  }, //_respond

  _customHooks: function(cbO, add_flag) {
    var el_jid, el, evt_key;
    Object.keys(cbO).forEach(ce_code => {
      [el_jid, evt_key]= ce_code.split("_");
      if (evt_key) {
        if (el= jm._ELs[el_jid]) {
          if (add_flag) el.addEventListener(evt_key, cbO[ce_code]);
          else el.removeEventListener(evt_key, cbO[ce_code]);
        }
      }
    });

    //possible 'e_codes':
      //begin_cb, returns nothing
      //end_cb, returns resp
      //(handler on any event on any jm._ELs item, returns event)
        //eg. "Input_keyup" is 'keyup' event on input#jwmInput
        //eg. "OkBut_mouseover" is 'mouseover' event on button#jwmOkBut

  }, //_customHooks

  //jm utils
  _mouseHandler: function(el, clk_cb) { //default is "click", but can cutomize, eg. "Overlay_mousedown"
    var act_str;
    if (typeof(el) == "string") {
      [el, act_str]= el.split("_"); //eg. "Overlay" and "mousedown"
      el= jm._ELs[el];
    }
    if (el) el.addEventListener(act_str || "click", clk_cb);
  },

  _displayEls: function(jids, display_v) {
    jm._iterEls(jids, el => showEl(el, display_v) );
  },

  _classEls: function(jids, class_str, flag= true) {
    jm._iterEls(jids, el => classEl(el, class_str, flag) );
  },

  _iterEls: function(jids, itr_cb) {
    var el;
    jids.split(",").forEach(jid => {
      if (el= jm._ELs[jid]) itr_cb(el);
    });
  },

  //adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example
  openModal: function(id) { //open modal by id
    document.body.classList.add("jw-modal-active");
    var el;
    if (el= document.getElementById(id)) el.classList.add("open");
  },
  closeModal: function() { //close currently open modal
    document.body.classList.remove("jw-modal-active");
    jm._ELs.Overlay.querySelector(".open").classList.remove("open");
  }
}; //jm
jm.init();


//INIT
var init_dtO= new Date();
console.log("INIT", init_dtO.toLocaleString());

var fClick_flag= true;
alarms_urlImport(window.location.search);
if (fClick_flag) { //satisfy browser requirement to allow play-sound

  data_load(["snooze_num", "autsrt_mode"], dataO => {
    snooze_def_num= (dataO.snooze_num || 5) *1; //default 5
    autsrt_mode= dataO.autsrt_mode=="true" || dataO.autsrt_mode==true; //localStorage stores strings
  });

  setTimeout(() => {
    jm.alert(bC_dupe_flag ? "TIMECKS is already running in another window or tab, close this tab" : "Click to start", () => {
      if (bC_dupe_flag) {
        window.close();
      } else {
        clock_draw();
        alarmsDrag_start();
        clock_start();
        alarms_start();
      }
    });
  }, 100); //aloow 1st data_load and bC to complete
}


function alarms_urlImport(q_str) { //import from via url querystring, stores "importedAlarm" in localstorage
  //.. this is a url based endpoint, not really a webpage, self closes
  if (!q_str) return; //-->

  var usp= new URLSearchParams(q_str);
  var action_str, external_str;

  //for local testing// file:///C:/Users/chaaad/Documents/GitHub/TIMECKS/index.htm
  findQS("export");  // ?export=WED 5/5 12:34pm|PC|New%20York%20Yankees|K|123-1
  findQS("exportDelete"); //?exportDelete=123-1|PC

  function findQS(act_str) {
    var exp_str= usp.get(act_str);
    if (exp_str) {
      var split_arr= exp_str.split("|");
      if (split_arr[1] == "PC") {
        //.. qualify //only PC can import
        action_str= act_str.replace("export", "external");
        external_str= exp_str;
      }
    }
  }

  if (action_str && external_str) {
    fClick_flag= false;

    setTimeout(() => { //let bssExt get set first
      external_str= action_str +"|" +external_str;

      data_load("importedAlarm", dataO => {
        var prevImport_str= dataO.importedAlarm;
        if (prevImport_str) { //allow multiple
          if (prevImport_str.includes(external_str)) external_str= ""; //dupe, ignore
          else external_str= prevImport_str +"\n" +external_str; //append
        }

        if (external_str) {
          data_save("importedAlarm", external_str, resp => {
            window.close();
          });
        } else window.close();
      }); //data_load

    }, 10);
  }

} //alarms_urlImport()


</script>

</html>
