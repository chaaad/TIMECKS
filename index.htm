<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<link rel="icon" href="./favicon.ico"/>

<title>TIMECKS</title>

<link href="https://fonts.cdnfonts.com/css/seven-segment" rel="stylesheet" crossorigin="anonymous">

<style type="text/css">

.css_hidden { /*can toggle show/hide*/
  display: none;
}

/*prereq css begin*/
/*https://codepen.io*/
body {
  font-family: "Lato", sans-serif;
  font-size: 100%;
  font-style: normal;
  font-weight: 300;
}
ul {list-style: none; }
/*prereq css end*/

.squareButton {
  color: lightgray;
  background: #eee;
  border-radius: 8px;
  border: 2px solid chartreuse;
  cursor: pointer;
  user-select: none;
  font-size: larger;
  margin: 8px;
  padding: 8px;
  color: gray;

  width: 20px;
  height: 20px;
  text-align: center;

  &:hover {
    background: #ddd;
  }
}

/*adapted from: https://codepen.io/ndeniche/pen/rNPjmg
*/
.closeButton {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 30px;
  float: right;
  margin-left: 8px;
  margin-top: 2px;
  &:hover {
    &::before,
    &::after {
      background: red; /*bgcolor*/
    }
  }
  &::before,
  &::after {
    content: "";
    position: absolute;
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: darkgray; /*bgcolor*/
    border-radius: 5px; /*rounded*/
    height: 6px; margin-top: -3px; /*heavy*/
  }
  &::before {
    transform: rotate(45deg);
  }
  &::after {
    transform: rotate(-45deg);
  }

  &.big { /*test*/
    transform: scale(3);
    background: pink;

  }

  &.small {
    transform: scale(0.66);
  }

} /*closeButton*/


/*adapted from: https://getcssscan.com/css-checkboxes-examples
*/
.checkbox-wrapper-18 {
  position: relative;

  /*timecks.. */
  top: 4px;
  display: inline-block;
  margin-right: 8px;
}
.checkbox-wrapper-18 label {
  background-color: #fff; /*circle*/
  border: 2px solid #ccc;
  border-radius: 50%;
  cursor: pointer;
  height: 28px;
  width: 28px;
  display: block;
}

.checkbox-wrapper-18 label:after {
  border: 2px solid #fff; /*check mark drawn with borders, then rotated*/
  border-top: none;
  border-right: none;
  content: "";
  height: 6px;
  left: 8px;
  opacity: 0;
  position: absolute;
  top: 9px;
  transform: rotate(-45deg);
  width: 12px;
}

.checkbox-wrapper-18 input[type="checkbox"] {
  visibility: hidden;
  display: none;
  opacity: 0;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label {
  background-color: #66bb6a;
  border-color: #66bb6a;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label:after {
  opacity: 1;
}
/*checkbox*/

div.textBox {
  max-width: 340px;
  overflow: auto;
  font-size: medium;
  font-weight: 600;
  background: #eee;
  padding: 8px;
  border-radius: 8px;
  margin-bottom: 8px;
  opacity: 90%;
  letter-spacing: 0.5px;
}


div#topButtons {
  position: fixed;

  div {
    line-height: 22px;
  }

  .on {
    color: chartreuse;
  }

  .down {
    background: chartreuse;
  }

  div#trashCan {
    font-size: xx-large;
    line-height: 20px;
    border-color: lightgray;
    cursor: default;
    background: white;

    &.dropTrash {
      background: cyan;
    }
  }
}

div#wakeLockIndicator {
  line-height: 24px;
  position: fixed;
  right: 4px;
  bottom: 4px;
  cursor: default;

  &.on {
    background-color: lightskyblue;
  }
}

div#stgContainer {
  position: fixed;
  left: 58px;
  top: 8px;
  display: none;

  div { /*squareButton*/
    font-size: small;
    font-weight: bolder;
    width: auto;
    padding: 4px;
    padding-bottom: 0;
  }
}

div#msgContainer {
  position: fixed;
  left: 16px;
  top: 220px;
  width: 300px;
  z-index: 4;

  div.msgInstance {
    background: gold;
  }
}

div#templates {
  display: none;
}

div#alarmsContainer {
  float: right;
  font-size: larger;
  padding: 8px;
  position: relative;

  div.alarmInstance {
    margin-bottom: 20px;
    border-radius: 8px;
    transition: background-color 1s ease-out;

    * {
      cursor: pointer;
      user-select: none;
    }

    span.alarmActivate {
      color: lightgray;
      margin-right: 0;
    }

    span.alarmEoM {
      color: orange;
      display: inline-block;
      min-width: 16px;
      cursor: default;
    }

    span.alarmLoc {
      display: inline-block;
      min-width: 20px;
      cursor: default;
      font-size: 16px;
      vertical-align: top;
    }

    span.alarmT {
      width: 200px;
      padding: 4px;
      border-radius: 2px;
      opacity: 25%;
      text-align: right;
    }

    span.alarmTime {
      letter-spacing: 2px;
      display: inline-block;
      font: bold 28px "Seven Segment", sans-serif;
      color: greenyellow;
      background: black;

      &.dt_adjusted {
        color: orange;
      }
    }

    span.alarmCountdown {
      display: none;
      font-size: larger;
      font-weight: 800;
      color: darkolivegreen;
      opacity: 50%;
      padding-top: 1px; /*compensate for the fonts being slightly diff height*/
    }

    &.soon {
      div.alarmName {
        background: #ddf;
        opacity: 100%;
      }
      span.alarmTime {
        opacity: 50%;
      }
    }

    &.alarmActive {
      div.alarmName {
        background: black;
        color:white;
        opacity: 100%;
      }
      span.alarmActivate {
        color: chartreuse;
      }
      span.alarmTime {
        opacity: 100%;
      }
    }

    /*drag n drop*/
    &.dragging {
      opacity: 0.5;
    }

    &.expired {
      background: pink;
    }
  }

  div.disablableContainer {
    div.alarmName {
      color: white;
      background: #666;
      opacity: 100%;
    }

    .soon div.alarmName {
      background: darkblue;
    }

    div.disabledInstance {
      div.alarmName {
        color: gray;
        background: #eee;
      }
    }
  }


  div#activeDiv {
    display: none;
    margin-bottom: 16px;

    div#activeCountdown {}

    div#ringDiv {
      display: none;
      margin-top: 16px;

      div#ringSnoozeBut,
      div#ringOffBut {
        width: 100%;
        height:60px;
        line-height:60px;
        text-align: center;
        margin-top: 12px;
        color: white;
        font-weight: bold;
        font-size: 24px;
        border-radius: 8px;
        cursor: pointer;
        opacity: 50%;

        &:hover {
          opacity: 100%;
        }
      }
      div#ringOffBut {
        background: #0078d0;
      }
      div#ringSnoozeBut {
        background: chocolate;

        div { /*snooze numbers*/
          margin-top: -3px; /*weird but works*/
          span {
            color: chocolate;
            cursor: pointer;
            opacity: 50%;

            &:hover {
              opacity: 100%;
            }
          }
        }
      }
    }

    div#ringSnzCountdown {}
  }

  .countdown {
    text-align: right;
    color:gray;
    margin-top: 8px;
    font-size: larger;
    font-weight: 800;
    color: cornflowerblue;
  }

} /*alarm*/


div#clockFace {
  width: 272px;
  height: 272px;
  background: #FDFAF7;
  border: 12px solid lightgray;
  border-radius: 100%;
  position: absolute;
  left: 30%;
  top: 50%;
  transform: translate(-50%, -50%);
  user-select: none;
  z-index: -1;

  div.hands,
  div.marker {
    position: absolute; top: 50%; left: 50%;
    transform-origin: 50% 50%;
  }

  div.hands::before {
    content: "";
    position: absolute;
    bottom: 50%;
    background: black;
    opacity: 33%;
    border-radius: 3px;
    transform: translateX(-50%);
  }

  div.hands.throt::before {
    background: blue;
  }
  div.hands.slept::before {
    background: red;
  }

  div#minuteHand {
    transition: transform 1s linear;
  }
  div#minuteHand::before {
    width: 6px;
    height: 110px;
  }

  div#hourHand::before {
    width: 10px;
    height: 70px;
  }

  div.marker {
    height: 118%;
    font-size: xx-large;
    color: white;
    &.on {
      color: black;
    }
  }

  div#spindle {
    width: 7px;
    height: 7px;
    background: #FDFAF7;
    border: 2px solid darkgray;
    border-radius: 100%;
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }

  span { /*tickmarks //each span has 2 tickmarks, uses ::before and ::after to create left and right, so only 30*/
    display: block;
    width: 1px;
    height: 95%;
    position: absolute; top: 50%; left: 50%;

    &::before,
    &::after {
      content: "";
      background: #A0A1A4;
      position: absolute;
      left: 0;
      width: 100%;
      height: 10px;
    }
    &::before {
      bottom: 0;
    }
    &::after {
      top: 0;
    }

    &.fives {
      &::after,
      &::before {
        height: 20px
      }
    }
  }


  ul#hourNumbers {
    height: 38%;
    position: absolute;
    bottom: 44%; /*changed (eyeballed) from 50%*/
    left: 50%;

    li {
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 50% 100%;

      i { /*comandeer i*/
        font-style: normal;
        font-weight: bold;
        font-size: 24px;

        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
    }
  }

  h2,
  h3 {
    letter-spacing: 1px;
    font-variant: small-caps;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }
  h2 {
    font-size: 8px;
    top: 29%;
    letter-spacing: 3px;
    font-weight: bold;
  }
  h3 {
    color: darkgray;
    top: 25%;
    font-size: x-large;
  }

  div#dtDisplay {
    font-size: 32px;
    font-weight: bold;
    color: #bbb;
    background: #eee;
    padding: 6px;
    border-radius: 12px;
    text-align: center;
    position: absolute;
    left: 50%;
    bottom: 25%;
    transform: translateX(-50%);

    &.pm {
      color: #eee;
      background: #bbb;
    }
  }

} /*clockface*/


div#localeContainerDiv {
  margin-bottom: 24px;

  div#localeBut, span#localeLocalSpan, span#lLocaleNameSpan, span#localeDeleteBut {
    cursor: pointer;
  }

  span#localeLocalSpan {
    color: lightgray;
    font-weight: 600;
  }

  span#lLocaleNameSpan {
    font-weight: 800;
  }

  span#localeDeleteBut {
    font-size: medium;
  }

  select {
    margin-top: 24px;
    font-size: large;
  }

} /*localeContainerDiv*/


/* MODAL
adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example#styles-css
-------------------------------*/
body.jw-modal-active { /*dont edit this css*/
  overflow: hidden; /* to hide main scrollbar when modal is active */
  div#jwmOverlay {
    display: block;
  }
}

div#jwmOverlay { /*background mask and overall container*/  /*edit this css carefully*/
  display: none; /* modals are hidden by default */
  position: fixed; /* modal container fixed across whole screen */
  inset: 0;
  z-index: 2; /* zindex higher than rest of page, except ringer */
  padding: 40px;
  overflow: auto; /* enables scrolling for tall modals */

  background-color: rgba(0, 0, 0, .75); /* semi-transparent black background exposed by padding */
  transition: background-color 5s;
  &.flash {
    background-color: rgba(255, 127, 127, .75); /*pink*/
  }

  .jw-modal-item { /*modal instance*/
    font-size: larger;
    width: 430px;
    padding: 24px;
    background: #fff;
    margin: 0px auto; /*center horiz*/
    border-radius: 16px;

    .open { /*dont edit this css*/
      display: block;
    }

    &.wide {
      width: auto;
    }

    div#jwmContent {
      margin-top: 8px;
    }

    div#jwmDescription {
      margin-bottom: 12px;
      line-height: 28px;

      b {
        font-weight: 600;
      }

      i {
        color: cornflowerblue;
        &.E {
          color: red;
        }
        span.adjusted_tm {
          color: darkorange;
        }
      }

      p { /*stronger*/
        margin: 0 0 4px 0;
        font-size: x-large;
        font-weight: bold;
        color: #0078d0;

        .i {
          color: darkorange;
        }
      }

      pre {
        line-height: normal;
        margin: 0;
      }

    }
    input#jwmInput {
      margin-bottom: 12px;
      width: 360px;
      font-size: xx-large;
      padding: 4px;
      background: cornsilk;
    }
    textarea#jwmTextarea {
      margin-bottom: 12px;
      width: 360px;
      height: 100px;
      padding: 8px;
      font-size: x-large;
      background: cornsilk;
    }

    /*button
    https://getcssscan.com/css-buttons-examples
    button-71
    */
    button {
      background-color: #0078d0;
      border: 0;
      border-radius: 56px;
      color: #fff;
      cursor: pointer;
      display: inline-block;
      font-family: system-ui,-apple-system,system-ui,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",sans-serif;
      font-size: 20px;
      letter-spacing: 1px;
      font-weight: 600;
      outline: 0;
      padding: 16px 21px;
      position: relative;
      text-align: center;
      text-decoration: none;
      transition: all .3s;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      min-width: 160px; /*timecks addition*/
      margin: 12px 24px 12px 0;
    }

    button:before {
      background-color: initial;
      background-image: linear-gradient(#fff 0, rgba(255, 255, 255, 0) 100%);
      border-radius: 125px;
      content: "";
      height: 50%;
      left: 4%;
      opacity: .5;
      position: absolute;
      top: 0;
      transition: all .3s;
      width: 92%;
    }

    button:hover {
      box-shadow: rgba(255, 255, 255, .2) 0 3px 15px inset, rgba(0, 0, 0, .1) 0 3px 5px, rgba(0, 0, 0, .1) 0 10px 13px;
      transform: scale(1.05);
    }

    @media (min-width: 768px) {
      button {
        padding: 16px 48px;
      }
    }
    /*button-71*/

    button.toggleable {
      opacity: 40%
    }
    button.hilite {
      opacity: 100%;
    }

    button#jwmCancelBut {
      background: chocolate;
      opacity: 50%
    }
  }

} /*jwmOverlay*/

</style>
</head>

<body>

<div id="templates">

  <div class="alarmInstance" draggable="true">
    <div class="textBox alarmName" title="Edit Name"></div>
    <span class="alarmActivate squareButton" title="On/Off">‚èπ</span>
    <span class="alarmEoM"></span>
    <span class="alarmT alarmTime" title="Edit time (LONG PRESS to change default view)"></span>
    <span class="alarmT alarmCountdown" title="Edit time (LONG PRESS to change default view)"></span>
    <span class="alarmLoc"></span>
    <span class="alarmDeleteBut closeButton" title="Delete"></span>
  </div>

  <div class="textBox msgInstance">
    <span class="msgDeleteBut closeButton small" title="Delete msessage"></span>
    <div class="msgInfo"></div>
  </div>

  <div id="localeContainerDiv">
    <div id="localeBut">üåêTime Zone</div>
    <span id="localeLocalSpan">LOCAL</span>
    <span id="lLocaleNameSpan" title="Locale"></span>
    <span id="localeDeleteBut" title="Remove Locale">‚ùå</span>
    <div id="localeChooserDiv">
      Choose:
      <select id="localeRegionsSel"></select>
      <select id="localePlacesSel"></select>
    </div>
  </div>

</div>

<div id="topButtons">
  <div id="editStgsBut" class="squareButton" title="Settings & Info">Ô∏ô</div>
  <div id="diasablerModeBut" class="squareButton" title="Hide-Alarms Mode">H</div>
  <div id="trashCan" class="squareButton" title="Trash (drag&drop unwanted alarm here)">üóë</div>
  <div id="addAlarmBut" class="squareButton" title="Add new alarm">‚úö</div>
</div>

<div id="msgContainer"></div>

<div id="stgContainer">
  <div id="stgdSnzBut" class="squareButton">Default Snooze</div>
  <div id="stgdATVBut" class="squareButton">Default AlarmTime View</div>
  <div id="stgRDatBut" class="squareButton">Alarms raw data</div>
  <div id="stgRdMeBut" class="squareButton">Read Me</div>
</div>

<div id="alarmsContainer">

  <div id="activeDiv">
    <div id="activeCountdown" class="countdown"></div>
    <div id="ringDiv">
      <div id="ringOffBut" class="button">OFF</div>
      <div id="ringSnoozeBut" class="button">
        SNOOZE
        <div>
          <span>1</span>
          <span>5</span>
          <span>10</span>
          <span>15</span>
          <span>20</span>
          <span>30</span>
        </div>
      </div>
      <div id="ringSnzCountdown" class="countdown">&nbsp;</div>
    </div>
  </div>

</div>


<div id="wakeLockIndicator" class="squareButton" title="Wake Lock">üîí</div>


<div id="clockFace">
  <h2>TIMECKS</h2>
  <h3></h3>

  <div id="dtDisplay"></div>

  <ul id="hourNumbers"></ul>

  <div id="minuteHand" class="hands"></div>
  <div id="hourHand" class="hands"></div>
  <div id="spindle"></div>

  <div id="alarmMarker" class="marker">‚Ä¢</div>
</div>


<div id="jwmOverlay">
  <div id="jwmModal" class="jw-modal-item">
    <span id="jwmCloseBut" class="closeButton"></span>
    <div id="jwmContent">
      <div id="jwmDescription"></div>
      <input id="jwmInput"/>
      <textarea id="jwmTextarea"></textarea>
      <button id="jwmOkBut">OK</button>
      <button id="jwmNoBut" class="toggleable">No</button>
      <button id="jwmCancelBut">Cancel</button>
    </div>
  </div>
</div>

</body>

<script>
//clock
//adapted from: https://codepen.io/opheliafl/pen/RaYbvL/

//favicon
//<a href="https://www.freepik.com/icon/alarm-clock_15092469#fromView=keyword&page=1&position=21&uuid=6aee3d4d-c58a-453e-8681-22457f5c0a34">Icon by sonnycandra</a>
//https://realfavicongenerator.net/


const TMXu= {}; //global utils
TMXu.showEl= function(el, display_param) { //display_param is truthy, unless its a string, then it true and string is used as value (eg. "inline")
  if (!el) return; //-->
  if (display_param && typeof(display_param)!="string") display_param= "block"; //truthy to block
  //TMXu.showEl(el, truthy) //on
  //TMXu.showEl(el, "inline") //on, but other than "block"
  //TMXu.showEl(el, falsy) //off
  el.style.display= display_param ? display_param : "none";
};
TMXu.classEl= function(el, class_param, flag) { //class_param can be string or array //flag is truthy
  if (!el) return; //-->
  if (Array.isArray(class_param)) el.classList[flag?"add":"remove"](...class_param);
  else el.classList[flag?"add":"remove"](class_param);
};

TMXu.message_add= function(str, bgColor_str) {
  TMXu.showEl(tmx.msgHeader_EL, true);
  var msg_EL= tmx.template_msgInst_EL.cloneNode(true); //clone
  tmx.msgCont_EL.appendChild(msg_EL); //add
  msg_EL.querySelector("div.msgInfo").innerHTML= str;
  if (bgColor_str) msg_EL.style.background= bgColor_str;
  return msg_EL; //bonus get
}; //TMXu.message_add()
TMXu.message_remove= function(msg_EL) {
  msg_EL.remove();
  if (!tmx.msgCont_EL.querySelectorAll("div.msgInstance").length) TMXu.showEl(tmx.msgHeader_EL, false);
  var exp_aI_EL; if (exp_aI_EL= msg_EL.$exp_aI_EL) TMX.alrm_unexpire(exp_aI_EL);
}; //TMXu.message_remove()

TMXu.createCssRule= function(css_str) {
  const styleSheet= document.createElement("style");
  styleSheet.type= "text/css";
  styleSheet.innerHTML= css_str;
  document.head.appendChild(styleSheet);
}; //TMXu.createCssRule()
TMXu.loadScript= function(src_str, cb) {
  const script= document.createElement("script");
  script.src= src_str;
  script.onload= () => {
    console.log("script loaded:", src_str);
    if (cb) cb();
  };
  script.onerror= () => {
    console.error("script NOT loaded:", src_str);
  };
  document.head.appendChild(script);
}; //TMXu.loadScript()

TMXu.parseJSON= function(str) {
  var json_dat;
  try {json_dat= JSON.parse(str); } catch (err) {console.error(err); }
  return json_dat;
};

TMXu.ls= function(key, v) { //localStorage: get, set, v="" to rem
  if (v != undefined) {
    if (v == "") window.localStorage.removeItem(key); //ls rem
    else window.localStorage.setItem(key, v); //ls set
  } else {
    return window.localStorage.getItem(key); //ls get
  }
}; //TMXu.ls()

TMXu.browserRemoveQuerystring= function() {
  history.replaceState("", document.title, window.location.pathname);
}; //TMXu.browserRemoveQuerystring()

TMXu.txtFile_fetch= async function(url_str, cb) {
  var resp;
  try {
    resp= await fetch(url_str); //no local testing with file:///...
//console.log("resp:", resp);
    if (resp.ok) {
      var str= await resp.text();
      cb(str);
    } else {
      console.error("Fetch error2:", resp.statusText); cb();
    }
  } catch (err) {
    console.error("Fetch error1:", err); cb();
  }
}; //TMXu.txtFile_fetch()


const TMX= {}; //global fns
const tmx= {}; //global vars

tmx.hookers= {};

TMX.HOOK= function(hook_key, v) {
  var hook_fn;
  if (hook_fn= tmx.hookers[hook_key]) return hook_fn(v); //sends only 1 arg, v
}; //TMX.HOOK()


tmx.audioClips= {};

(() => { //IIFE
  //init_audio
  var nvO= {
    beep: "426892_7913959",
    bell: "173000_2193194",
    clik: "668985_14100561",
    buzz: "696600_14786418",
    knoc: "425727_760420",
    oops: "124897_1707984",
    rngr: "246332_4486188",
    slam: "421472_3387258",
    trsh: "655617_13805813"
  };
  var val_str;
  Object.keys(nvO).forEach(key => {
    val_str= nvO[key];
    tmx.audioClips[key]= new Audio("https://cdn.freesound.org/previews/" +val_str.substring(0, 3) +"/" +val_str +"-lq.mp3");
    //beep= new Audio("https://cdn.freesound.org/previews/426/426892_7913959-lq.mp3")
  });
})(); //IIFE

tmx.clockFace_EL= document.querySelector("DIV#clockFace");

tmx.cf_handH_EL= tmx.clockFace_EL.querySelector("div#hourHand");
tmx.cf_handM_EL= tmx.clockFace_EL.querySelector("div#minuteHand");

tmx.cf_dow_EL= tmx.clockFace_EL.querySelector("h3");
tmx.cf_monthDay_EL= tmx.clockFace_EL.querySelector("div#dtDisplay");

tmx.cf_marker_EL= tmx.clockFace_EL.querySelector("div.marker");

TMXu.showEl(tmx.cf_marker_EL, false);

TMX.clock_draw= function() {
  var rotate_n= 0;
  var span_EL;
  for (var i=0; i<30; i++) {
    span_EL= document.createElement("span");
    if (!(i%5)) span_EL.className= "fives";
    span_EL.style.transform= "translate(-50%,-50%) rotate(" +rotate_n +"deg)";
    tmx.clockFace_EL.appendChild(span_EL);
    rotate_n+= 6;
  }

  //createHourNumbers
  rotate_n= 0;
  var hr_n= 12;
  var ul_EL= document.querySelector("UL#hourNumbers");
  var li_EL, i_EL;
  for (i=0; i<12; i++) {
    li_EL= document.createElement("li");
    if (rotate_n) li_EL.style.transform= "rotate(" +rotate_n +"deg)";
    ul_EL.appendChild(li_EL);

    i_EL= document.createElement("i");
    i_EL.textContent= hr_n;
    if (rotate_n) i_EL.style.transform= "translateX(-50%) rotate(-" +rotate_n +"deg)";
    li_EL.appendChild(i_EL);

    rotate_n+= 30;
    hr_n++;
    if (hr_n > 12) hr_n= 1;
  }
}; //TMX.clock_draw()


tmx.cf_degO;
tmx.cf_h_inc= 360 /720; //0.5deg
tmx.cf_m_inc= 360 /60; //6deg

tmx.start_dtO;
tmx.clock_hr24;
tmx.clock_elapse_ms; //what we want the time to be, when compared to Date.now() we get tmx.sync_diff_ms
tmx.clock_ctdn_m;
tmx.inc_ms= 60000; //default 1 minute (flex)

tmx.clockMarker_n;

TMX.clock_drawHands= function(o =tmx.cf_degO) {
  tmx.cf_handH_EL.style.transform= "rotate(" +o.hr +"deg)";
  tmx.cf_handM_EL.style.transform= "rotate(" +o.mn +"deg)";
}; //TMX.clock_drawHands()

TMX.clock_drawSyncHands= function() { //temp hands positions based on tmx.sync_diff_ms, tmx.cf_degO uneffected
  var diff_m= tmx.sync_diff_ms /60000;
  TMX.clock_drawHands({ //draw mn hand at precise mn position (not usual whole mn)
    hr: tmx.cf_degO.hr -tmx.cf_h_inc *diff_m,
    mn: tmx.cf_degO.mn -tmx.cf_m_inc *diff_m
  }); //sleep/throttle actually makes mn hand more accurate lol
  if (tmx.sync_diff_ms < 0) return; //clock was behind //-->

  //clock was ahead
  setTimeout(() => {
    TMX.clock_drawHands(); //now, can draw mn hand at the 'original' whole mn
    TMXu.classEl(tmx.cf_handM_EL, "throt", false);
  }, tmx.sync_diff_ms);
}; //TMX.clock_drawSyncHands()

TMX.clock_start= function() {
  tmx.start_dtO= new Date();

console.log("TMX.clock_start", tmx.start_dtO.toLocaleTimeString());
  TMX.sound_play("oops");

  tmx.clock_elapse_ms= tmx.start_dtO.getTime();

  tmx.clock_hr24= tmx.start_dtO.getHours();
  var minutes= tmx.start_dtO.getMinutes(); //0-59
  tmx.clock_ctdn_m= 60 -minutes; //60-1

  tmx.cf_degO= {
    hr: 30 *tmx.clock_hr24  +tmx.cf_h_inc *minutes,
    mn: tmx.cf_m_inc *minutes
  };
  TMX.clock_drawHands();

  TMX.tzoc_start();

  var minute_ms= tmx.start_dtO.getSeconds()*1000 +tmx.start_dtO.getMilliseconds();
  var topOfMinute_ms= 60000 -minute_ms;
  setTimeout(() => {
    tmx.clock_elapse_ms+= topOfMinute_ms; //inc (1st min)
    TMX.clock_advance(); //1st

    mainloop(); //kickoff

    function mainloop() { //self-recursing
      setTimeout(() => {
        tmx.clock_elapse_ms+= 60000; //inc (fixed)
        if (TMX.clock_advance()) return; //abort mainloop //-->

        TMX.data_load("externalAlarms", dataO => {
          var external_str= dataO.externalAlarms;
          if (external_str) TMX.alarms_external(external_str);
        });
        //.. like a poll, for "externalAlarms" in localStorage

        mainloop(); //recurse-->

      }, tmx.inc_ms);
    } //mainloop()

  }, topOfMinute_ms);

  TMX.clock_drawDay(tmx.start_dtO);

}; //TMX.clock_start()

tmx.monthDay_str;
TMX.clock_drawDay= function(dtO) { //draw am/pm and monthday
  tmx.cf_dow_EL.textContent= dtO.toLocaleDateString("en-US", {weekday:"short"}).toUpperCase();
  //eg. "Tue" .. "TUE"
  var month_n= dtO.getMonth();
  tmx.monthDay_str= (month_n +1) +"/" +dtO.getDate(); //0-11 (+1), 1-31
  tmx.cf_monthDay_EL.textContent= tmx.monthDay_str; //monthday
  TMXu.classEl(tmx.cf_monthDay_EL, "pm", tmx.clock_hr24>=12); //am/pm
}; //TMX.clock_drawDay()


tmx.sync_dtO;
tmx.sync_ms;
tmx.sync_diff_ms; //can debug in console

tmx.clock_throt_flag;
tmx.clock_jump_ct= 0;

TMX.clock_advance= function() { //+1 clock minute
  tmx.sync_dtO= new Date(); //topOfMinute
  tmx.sync_ms= tmx.sync_dtO.getTime();
  tmx.sync_diff_ms= tmx.clock_elapse_ms -tmx.sync_ms;

  tmx.cf_degO.hr+= tmx.cf_h_inc;
  tmx.cf_degO.mn+= tmx.cf_m_inc;

  tmx.clock_ctdn_m--; //inc-
  if (tmx.clock_ctdn_m < 1) { //top of hr
    tmx.clock_ctdn_m= 60; //wrap (reset)
    tmx.clock_hr24= (tmx.clock_hr24+1) %24; //inc wrap
    tmx.cf_degO.mn= 0;

    if (tmx.clock_hr24 %12 == 0) { //noon or midnite
      tmx.cf_degO.hr= 0;

      var toh_dtO= tmx.clock_hr24==0 && tmx.sync_diff_ms>0 ? new Date(tmx.sync_ms +3600000) : undefined;
      //if midnite, and real time is behind, add 1 hr to toh_dtO (advance day), toh_dtO is just for month/day

      TMX.clock_drawDay(toh_dtO || tmx.sync_dtO);
      TMX.tzoc_check(tmx.sync_dtO);
    }
  } //top of hr

  TMX.clock_drawHands();

  if (tmx.sync_diff_ms) { //not 0

    //post-sleep (possibly throttle?)
    if (tmx.sync_diff_ms <= -60000 ) { //very slow, 1 or more minute behind

      if (tmx.sync_diff_ms <= -3600000 ) { //extremely slow, 1 or more hour behind
        TMX.restart(); //clean
        return "abort_mainloop"; ////-->
        ///////////////////////
      }

      //jump 1 minute
      tmx.clock_jump_ct++;  //post-sleep stage 1/3
      tmx.clock_elapse_ms+= 60000; //add 1 clock min
      TMX.clock_advance(); //.. can be called as many times as necessary to catch up (up to an hour)

    } else if (tmx.clock_jump_ct) { //not 0
      if (tmx.clock_jump_ct > 0) { //post-sleep stage 2/3
        tmx.clock_jump_ct= -1; //stage 3
        tmx.inc_ms= 60000 +tmx.sync_diff_ms; //get back in sync
        TMXu.classEl(tmx.cf_handM_EL, "slept", true);
        TMX.clock_drawSyncHands();
        TMX.sound_play("clik", (tmx.clock_jump_ct>3 ? 3 : tmx.clock_jump_ct), 500);

      } else { //tmx.clock_jump_ct == -1 //post-sleep stage 3/3
        tmx.inc_ms= 60000; //reest
        tmx.clock_jump_ct= 0;
        TMXu.classEl(tmx.cf_handM_EL, "slept", false);
      }


    //post-throttle
    //what happens is that during throttle, the mainloop runs lil slow, so tmx.inc_ms goes lower to try to run mainloop quicker
    //when throttle ends, this low tmx.inc_ms makes the next sync actually ahead!
    } else if (tmx.sync_diff_ms>100 || tmx.clock_throt_flag) { //fast (or throt stage 2)
      if (!tmx.clock_throt_flag) { //post-throt stage 1/2
        tmx.clock_throt_flag= true; //stage 2
        tmx.inc_ms= 60000 +tmx.sync_diff_ms; //get back in sync
        TMXu.classEl(tmx.cf_handM_EL, "throt", true);
        TMX.clock_drawSyncHands();
        TMX.sound_play("clik", 2, 500);

      } else { //post-throt stage 2/2
        tmx.clock_throt_flag= false;
        //TMXu.classEl(tmx.cf_handM_EL, "throt", false);
        tmx.inc_ms= 60000; //reset
      }


    //normal
    } else { //tweak tmx.inc_ms
      tmx.inc_ms+= tmx.sync_diff_ms; //tiny swerves, always trying to achieve tmx.sync_diff_ms of 0
      if (tmx.inc_ms < 1000) tmx.inc_ms= 1000; //not too small, nrn
    }

    //when browser throttled, mainloop 'minute' can be slow (over 7 secs seen), also screen rendering paused
    //https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#reasons_for_delays_longer_than_specified

    //when system sleeps, everything stops

  } //tmx.sync_diff_ms

  TMX.alarms_minuteUpdate();

}; //TMX.clock_advance()

TMX.clock_checkMarker= function() {
  var marker_n= Math.floor(tmx.active_ctdn_m /720); //0 1 2+
  if (marker_n > 2) marker_n= 2;
  if (marker_n == tmx.clockMarker_n) return; //-->

  if (tmx.cf_marker_EL.mkr_val == undefined) { //init
    tmx.cf_marker_EL.style.transform= "translate(-50%, -50%) rotate(" +(30*tmx.active_hTimO.h +0.5*tmx.active_hTimO.m) +"deg)";
  }
  TMXu.showEl(tmx.cf_marker_EL, tmx.active_ctdn_m<1440 ? "block" : false); //within 24hrs
  TMXu.classEl(tmx.cf_marker_EL, "on", tmx.active_ctdn_m<720); //within 12hrs
  tmx.clockMarker_n= marker_n;
}; //TMX.clock_checkMarker()


TMX.restart= function() { //post long sleep
  var elapsed_minutes= Math.floor(tmx.sync_diff_ms /60000); //negative
  [...tmx.aI_NL].forEach(aI_EL  => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in tmx.disabler_mode all are visible)
      aI_EL.$D.ctdn_m+= elapsed_minutes; //negative
      if (aI_EL.$D.ctdn_m < 1) TMX.alrm_silentExpire(aI_EL);
    } //skip not visible
  });

  TMX.clock_start();

  TMX.ringer_stop("off"); //if needed
  tmx.active_aI_EL= undefined; //allows aa
  TMX.alarms_start();
}; //TMX.restart()


//debug utils
const dbg= {
  g_fmatDtO: function(dtO =new Date()) { //formatted time string, eg. "@11:48:22.005" //shows ms
    return "@" +(dtO.getHours()%12||12) +":" +dtO.toISOString().substring(14, 23);
    //.. toISOString(), eg. "2011-10-05T14:48:22.005Z"
  }
};

tmx.body_EL= document.querySelector("body");

tmx.topButs_EL= document.querySelector("div#topButtons");
tmx.stgCont_EL= document.querySelector("div#stgContainer");

tmx.disabler_EL= tmx.topButs_EL.querySelector("div#diasablerModeBut");
//add_EL= tmx.topButs_EL.querySelector("div#addAlarmBut");
tmx.trash_EL= tmx.topButs_EL.querySelector("div#trashCan");

tmx.wakeLock_EL= document.querySelector("div#wakeLockIndicator");

tmx.msgCont_EL= document.querySelector("div#msgContainer");

tmx.templates_EL= document.querySelector("div#templates");
tmx.template_msgInst_EL= tmx.templates_EL.querySelector("div.msgInstance");
tmx.template_alarmInst_EL= tmx.templates_EL.querySelector("div.alarmInstance");

//alarms
tmx.alarmsCont_EL= document.querySelector("div#alarmsContainer");
tmx.alarmInst_EL;
tmx.active_aI_EL;

tmx.activeDiv_EL= tmx.alarmsCont_EL.querySelector("div#activeDiv");
tmx.activeCountdown_EL= tmx.activeDiv_EL.querySelector("div#activeCountdown");


tmx.snooze_def_num;
tmx.timeview_def_flag;

document.addEventListener("keyup", evt => { //capture any keyup
  if (!document.body.classList.contains("jw-modal-active")) { //modal inactive
    if (tmx.ring_intimerId) { //keys to silence ringer
      if (evt.key == " ") TMX.ringer_stop("snooze");
      else if (evt.key.search(/Enter|Escape/) > -1) TMX.ringer_stop("off");
    }
  }
});

tmx.topButs_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL.id == "editStgsBut") {
    TMX.stgs.tog(targ_EL);
  } else if (targ_EL == tmx.disabler_EL) {
    TMX.disablerMode_toggle();
  } else if (targ_EL.id == "trashCan") {
    TMX.trash_clicked();
  } else if (targ_EL.id == "addAlarmBut") {
    TMX.alrm_add();
  }
});

tmx.stgCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL.id == "stgdSnzBut") {
    TMX.stgs.defSnz();
  } else if (targ_EL.id == "stgdATVBut") {
    TMX.stgs.defATV();
  } else if (targ_EL.id == "stgRDatBut") {
    TMX.stgs.rawDat();
  } else if (targ_EL.id == "stgRdMeBut") {
    TMX.stgs.readMe();
  }
});



//create Message Header
tmx.msgHeader_EL= TMXu.message_add("Messages");
tmx.msgHeader_EL.classList.remove("msgInstance"); //no longer a commoner
TMXu.showEl(tmx.msgHeader_EL, false);

tmx.msgDelAllBut_EL= tmx.msgHeader_EL.querySelector("span.msgDeleteBut");
tmx.msgDelAllBut_EL.title= "Delete all messages";

//message
tmx.msgCont_EL.addEventListener("click", evt => {
  tmx.alrmExpChange_flag= false;
  var targ_EL= evt.target;
  if (targ_EL == tmx.msgDelAllBut_EL) {
    tmx.msgCont_EL.querySelectorAll("div.msgInstance").forEach(m_el => TMXu.message_remove(m_el));
  } else if (targ_EL.classList.contains("msgDeleteBut")) {
    TMXu.message_remove(targ_EL.closest("div.msgInstance"));
  }
  if (tmx.alrmExpChange_flag) TMX.alarms_sort();
});


//long press
tmx.longPress_flag;
tmx.longPress_timerId;

TMX.longPress_timerStop= function() {
  if (!tmx.longPress_timerId) return; //-->

  clearTimeout(tmx.longPress_timerId);
  tmx.longPress_timerId= undefined;
};

//longpress
tmx.alarmsCont_EL.addEventListener("mousedown", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    TMX.longPress_timerStop();
    tmx.longPress_flag= false;
    tmx.longPress_timerId= setTimeout(function() { //startPressTimer
      var c_alarmInst_EL= targ_EL.closest("div.alarmInstance");
      tmx.longPress_flag= true; //this will prevent regular click handler
      tmx.alarmInst_EL= c_alarmInst_EL;
      TMX.alrm_setTorC(tmx.alarmInst_EL, !tmx.alarmInst_EL.$D.vu_cd, "persist"); //toggle
      TMX.sound_play("clik");
      TMX.alarms_save();
    }, 1000);
  }
});


//timehover
tmx.alarmsCont_EL.addEventListener("mouseover", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (aI_EL==tmx.active_aI_EL || aI_EL.$D.t_hov) return; //active or already hovered, skip //-->

    TMX.alrm_setTorC(aI_EL, !aI_EL.$D.vu_cd); //toggle, but only temporary
    aI_EL.$D.t_hov= true; //hover on
  }
});

tmx.alarmsCont_EL.addEventListener("mouseout", evt => {
  //longpress
  TMX.longPress_timerStop();

  //timehover
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (!aI_EL.$D.t_hov) return; //already unhovered, skip //-->

    TMX.alrm_setTorC(aI_EL, aI_EL.$D.vu_cd); //untoggle, was temporary anyway
    aI_EL.$D.t_hov= false; //hover off
  }
});

//alarm //longpress
tmx.alarmsCont_EL.addEventListener("dragstart", () => {
  TMX.longPress_timerStop();
});

//alarm (for alarmT, longpress)
tmx.alarmsCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;

  if (targ_EL.closest("div#ringSnoozeBut")) {
    var n;
    if (targ_EL.tagName == "SPAN") n= targ_EL.textContent *1;
    TMX.ringer_stop("snooze", n);

  } else if (targ_EL.closest("div#ringOffBut")) {
    TMX.ringer_stop("off");

  } else {
    var _al_EL;
    if (_al_EL= targ_EL.closest("div.alarmInstance")) {
      tmx.alarmInst_EL= _al_EL;
      var t_cl= targ_EL.classList; //alias

      if (_al_EL.classList.contains("expired")) {
        var msg_EL= _al_EL.$exp_msg_EL; //TMX.alrm_unexpire() will clear .$exp_msg_EL
        TMX.alrm_unexpire(_al_EL);
        TMX.alarms_sort();
        if (msg_EL) TMXu.message_remove(msg_EL);
        //expired alarm, so only unexpire it, ignore other commands

      } else if (t_cl.contains("alarmActivate")) {
        var toggleOff_flag= _al_EL==tmx.active_aI_EL;
        if (tmx.ring_aI_EL) {
          TMX.ringer_stop("off");
          if (!toggleOff_flag) TMX.alrm_activate(_al_EL);
        } else {
          TMX.alrm_activate(toggleOff_flag ? false : _al_EL);
        }

      } else if (targ_EL.closest("div.alarmName")) {
        if (!TMX.HOOK("alarmNameClick", targ_EL)) TMX.alrm_editName();

      } else if (t_cl.contains("alarmT")) {
        TMX.longPress_timerStop();
        if (tmx.longPress_flag) return; //-->

        TMX.alrm_editTime();

      } else if (t_cl.contains("alarmDeleteBut")) {
        TMX.alrm_delete();

      } else if (t_cl.contains("alarmLoc")) {
        TMX.alrm_editTime();

      } else if (t_cl.contains("alarmEoM")) {
        var html_str= `<b>${_al_EL.$E.Name.textContent}</b><br>${_al_EL.$D.hTime_str}<p>${targ_EL.title}</p>`;
        jm.alert(html_str);

      } else if (targ_EL.tagName == "INPUT") { //disabler checkbox (there can only 1 input el in alarmInstance)
        TMXu.classEl(_al_EL, "disabledInstance", !targ_EL.checked);
        TMX.alarms_save();
      }
    }
  }
});


tmx.wakeLock_EL.addEventListener("click", evt => {
  jm.alert("<b>Wake Lock</b> prevents computer from going into sleep mode. However, Wake Lock won't work if this page totally is hidden.");
});

//https://developer.chrome.com/blog/new-in-chrome-79/#wake-lock
tmx.wakeLock_OBJ;

TMX.wakeLock_set= function(flag) { //on, off, click-evt (toggle)
	if (flag == "on") {
    if (!tmx.wakeLock_OBJ) wakeLock_on();
  } else if (flag == "off") {
    if (tmx.wakeLock_OBJ) wakeLock_off();
  }

  async function wakeLock_on() {
    if (document.hidden) return; //-->
  	try {
  		tmx.wakeLock_OBJ= await navigator.wakeLock.request();
      TMXu.classEl(tmx.wakeLock_EL, "on", true);

    	tmx.wakeLock_OBJ.addEventListener("release", () => {
        TMX.sound_play("knoc");
    		tmx.wakeLock_OBJ= undefined; //clear global
        TMXu.classEl(tmx.wakeLock_EL, "on", false);
    	});
  	} catch (err) {console.log(err.message); }
  } //wakeLock_on()

  async function wakeLock_off() { //note: minimizing of browser, or unfocus of browser tab, will automatically release wakeLock
  	if (!tmx.wakeLock_OBJ) return; //-->
    try {await tmx.wakeLock_OBJ.release(); }
  	catch (err) {console.log(err.message); }
  } //wakeLock_off()

}; //TMX.wakeLock_set()

document.addEventListener("visibilitychange", function() {
  //wakeLock auto
  if (!document.hidden) TMX.wakeLock_set("on"); //on "wake" or "show"
  //else (on sleep, browser minimized or tab switch, another window covers this window), do nothing
});


tmx.stg_mode;
TMX.stgs= {};

TMX.stgs.tog= function(but_EL) {
  tmx.stg_mode= !tmx.stg_mode;
  TMXu.showEl(tmx.stgCont_EL, tmx.stg_mode ? true : false);
  TMXu.classEl(but_EL, "down", tmx.stg_mode, true);
}; //TMX.stgs.tog()

TMX.stgs.defSnz= function(key) {
  jm.prompt("<p>Default Snooze duration</p>(minutes, 1-30)", tmx.snooze_def_num, resp => {
    if (resp == null) return; //-->

    var v_num= resp *1;
    if (v_num == tmx.snooze_def_num) return; //same, do nothing //-->

    if (isNaN(v_num) || v_num<1 || v_num>30) {
      jm.error('<p class="bad">Snooze must be 1-30 minutes</p>Your input:<i class="E">' +resp +'</i>', () => {
        timecksStgs_edit(); //try again
      });
    } else {
      tmx.snooze_def_num= v_num;
      TMX.data_save("snooze_num", tmx.snooze_def_num);
    }
  }, "highlight");
}; //TMX.stgs.defSnz()

TMX.stgs.defATV= function(key) {
  jm.boolean("<p>Default AlarmTime View</p>", tmx.timeview_def_flag, {
    //jm custom cb object
    custButText: {OkBut: "Countdown", NoBut: "Time"},
    end_cb: resp => {
      if (resp==null || resp==tmx.timeview_def_flag) return; //cancel or same, do nothing //-->
      tmx.timeview_def_flag= resp;
      TMX.data_save("timeview_flag", tmx.timeview_def_flag);
    }
  });
}; //TMX.stgs.defATV()

TMX.stgs.rawDat= function() {
  TMX.data_load("alarms", dataO => {
    var json_str= dataO.alarms;
    var json_dat= TMXu.parseJSON(json_str);
//console.log("json_dat:", json_dat);
    if (!json_dat) json_str= "";

    jm.prompt_textarea("<p>Alarms raw data (JSON)</p>", json_str, resp => {
      if (resp == null) return; //-->

      json_str= resp;
      json_dat= TMXu.parseJSON(json_str);
      if (json_dat) {
        TMX.data_save("alarms", json_str);
        TMX.alarms_start();
        TMXu.message_add("Alarms raw data (JSON) saved", "lightblue");
      } else {
        TMXu.message_add("Saving Alarms raw data (JSON) failed");
      }
    }); //jm.prompt_textarea()

  }); //TMX.data_load()
}; //TMX.stgs.rawDat()

TMX.stgs.readMe= function() {
  var url_str= "readme.txt";
  TMXu.txtFile_fetch(url_str, str => {
    if (str) {
      var modal_EL= document.getElementById("jwmModal");
      jm.alert("<p>Read Me</p><pre>" +str +"<pre>", {
        //jm custom cb object
        begin_cb: () => {TMXu.classEl(modal_EL, "wide", true); },
        end_cb: () => {TMXu.classEl(modal_EL, "wide", false); }
      });

    } else {
      TMXu.message_add("Reading " +url_str +" failed");
    }
  });
}; //TMX.stgs.readMe()


TMX.trash_clicked= function() {
  jm.alert("You can delete an alarm by Dragging and Dropping it onto the <b>Trash</b> icon");
}; //TMX.trash_clicked()

tmx.activeCountdown_flag;
tmx.active_ctdn_m;
tmx.active_hTimO;

tmx.aI_NL; //from .getElementsByClassName(), dynamic nodeList
tmx.vis_ct;

TMX.alarms_start= function(al_arr) {
  if (al_arr) {
    render(al_arr);

  } else {
    TMX.data_load("alarms", dataO => {
      var json_str= dataO.alarms;
      var storedAl_arr= TMXu.parseJSON(json_str);
      if (!storedAl_arr) storedAl_arr= [{t:"12:00 AM"}]; //default if empty
      render(storedAl_arr);
    });
  }

  function render(al_arr) {
    //al_arr is almost a data model, but is temporary
    //rest of the time, data is solely in the DOM

    tmx.disblr_ct= 0;
    tmx.vis_ct= 0;
    tmx.alarmsCont_EL.innerHTML= ""; //clear container el
    tmx.alarmInst_EL= undefined;

    var aInst_EL;
    var t_str, aNow_obj;
    al_arr.forEach(a_obj => {
      aInst_EL= tmx.template_alarmInst_EL.cloneNode(true); //clone
      tmx.alarmsCont_EL.appendChild(aInst_EL); //add
      TMX.alrm_addHelpers(aInst_EL, a_obj.id);
      aInst_EL.$E.Name.innerHTML= a_obj.n || ""; //alarm name

      t_str= a_obj.t; //alarm time
      aInst_EL.$D.hTime_str= t_str; //alarm time
      if (a_obj.l || t_str.indexOf("/31")>0) {
        if (aNow_obj= TMX.alrm_procTimeText(t_str, a_obj.l, "preview")) {
          if (aNow_obj.hTimeA_str != t_str) t_str= aNow_obj.hTimeA_str;
        }
      }
      aInst_EL.$E.Time.textContent= t_str;

      if (a_obj.l) { //alarm loc
        aInst_EL.$D.loc= a_obj.l;
        aInst_EL.$E.Loc.title= a_obj.l;
      }
      TMX.alrm_init(aInst_EL);
      if (a_obj.c) TMX.alrm_setTorC(aInst_EL, true, "persist"); //init alarm countdown view

      if (tmx.disabler_mode) {
        tmx.vis_ct++;
        TMX.alrm_drawDisablerMode(aInst_EL, a_obj.d); //disabler mode
      } else if (a_obj.d) {
        TMXu.showEl(aInst_EL, false); //alarm disabled
      } else {
        tmx.vis_ct++;
      }
    });

    tmx.aI_NL= tmx.alarmsCont_EL.getElementsByClassName("alarmInstance");

    TMX.alarms_sort();
    TMX.wakeLock_set("on");
  } //render()

}; //TMX.alarms_start()


tmx.disabler_mode;
tmx.disblr_ct; //for css checkbox label to work

TMX.disablerMode_toggle= function() {
  tmx.disabler_mode= !tmx.disabler_mode; //toggle
  if (!tmx.disabler_mode) { //turn disabler mode off
    tmx.active_aI_EL= undefined; //so will auto-activate top alarm (TMX.alarms_sort)
  }

  TMXu.classEl(tmx.disabler_EL, "down", tmx.disabler_mode);
  TMXu.classEl(tmx.alarmsCont_EL, "disablableContainer", tmx.disabler_mode);
  TMX.alarms_start();
}; //TMX.disablerMode_toggle()


TMX.alarmsDrag_init= function() {
  //dragndrop
  //adapted from: https://www.w3resource.com/javascript-exercises/event/javascript-event-handling-exercise-6.php

  var dragAl_EL;
  var prev_dragOver_EL;

  // Add event listeners for drag and drop events
  tmx.alarmsCont_EL.addEventListener("dragstart", dragStart);
  document.addEventListener("dragover", dragOver);
  document.addEventListener("drop", drop); //user can drop anywhere, listening only on dragList doesnt cut it

  //global stop drag
  document.addEventListener("click", evt => {
    if (dragAl_EL) clear("fully");
  }); //recover after a failed drop

  function dragStart(evt) {
    if (dragAl_EL) clear("fully"); //recover after a failed drop

    dragAl_EL= evt.target;
    TMXu.classEl(dragAl_EL, "dragging", true);
    //evt.dataTransfer.effectAllowed= "move"; //what does this even do?
  } //dragStart()

  function dragOver(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dragOver_EL= evt.target;
    var dragOvAl_EL;

    if (dragOver_EL == tmx.trash_EL) { //trash can
      if (dragOver_EL == prev_dragOver_EL) return; //-->

      if (prev_dragOver_EL) clear();
      TMXu.classEl(dragOver_EL, "dropTrash", true);

      prev_dragOver_EL= dragOver_EL;

    } else { //not trashcan
      if (prev_dragOver_EL && prev_dragOver_EL == tmx.trash_EL) { //trash can
        clear();
        prev_dragOver_EL= undefined;
      }
    }
  } //dragOver()

  function drop(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dropOn_EL= prev_dragOver_EL; //not actual the dropOn_EL, but this allows user to make drop even with imprecise drop
    //.. if user drops outside of window, no drop event at all, accept this fact
    if (dropOn_EL) {
      if (dropOn_EL == tmx.trash_EL) {
        tmx.alarmInst_EL= dragAl_EL;
        TMX.alrm_execDelete();
      }
    }

    clear("fully");
  } //drop()

  function clear(fully_flag) { //if not fully, just clear dragOver's class
    if (prev_dragOver_EL) prev_dragOver_EL.classList.remove("dropAbove", "dropBelow", "dropTrash");
    if (fully_flag) {
      if (dragAl_EL) TMXu.classEl(dragAl_EL, "dragging", false);
      dragAl_EL= undefined;
      prev_dragOver_EL= undefined;
    }
  } //clear()

  //dragndrop
}; //TMX.alarmsDrag_init()


TMX.alrm_addHelpers= function(aI_EL, id) { //.dataset only stores strings
  //breaks html/js laws, but as far as js only goes, an element is just an object
  aI_EL.id= id;

  //because .dataset only stores strings
  aI_EL.$D= {};
  aI_EL.$E= { //pointers to sub els
    Activ: aI_EL.querySelector("span.alarmActivate"),
    Name: aI_EL.querySelector("div.alarmName"),
    Time: aI_EL.querySelector("span.alarmTime"),
    Ctdn: aI_EL.querySelector("span.alarmCountdown"),
    EoM: aI_EL.querySelector("span.alarmEoM"),
    Loc: aI_EL.querySelector("span.alarmLoc")
  };
}; //TMX.alrm_addHelpers()

TMX.alrm_drawDisablerMode= function(aI_EL, dsbl_flag) {
  var checked_str= dsbl_flag ? "" : " checked";
  TMXu.classEl(aI_EL, "disabledInstance", !!dsbl_flag); //in TMXu.classEl(), flag of undefined will default to true

  aI_EL.$E.Activ.insertAdjacentHTML(
  "afterend",
  `<div class="checkbox-wrapper-18" title="Enable/Disable"><input type="checkbox" id="chkbx_${tmx.disblr_ct}"${checked_str}/><label for="chkbx_${tmx.disblr_ct}"></label></div>`
  );
  TMXu.showEl(aI_EL.$E.Activ, false);
  tmx.disblr_ct++;
}; //TMX.alrm_drawDisablerMode()

TMX.alrm_glow= function(s =1, aI_EL =tmx.alarmInst_EL, color_str ="aquamarine") {
  aI_EL.scrollIntoView(tmx.scrollParam);

  aI_EL.style.background= color_str;
  setTimeout(() => {aI_EL.style.background= ""; }, s *1000);
}; //TMX.alrm_glow()

tmx.scrollParam= {behavior:"smooth", block:"center"};

TMX.alrm_scrollTo= function(noExp_flag) {
  var chosen_EL;
  if (!noExp_flag) chosen_EL= tmx.alarmsCont_EL.querySelector("div.expired");
  if (!chosen_EL) chosen_EL= tmx.active_aI_EL;
  if (chosen_EL) chosen_EL.scrollIntoView(tmx.scrollParam);
}; //TMX.alrm_scrollTo()


TMX.alrm_editName= function(NEW_flag) { //if new, NEW_flag is "NEW"
  var name_str= NEW_flag || tmx.alarmInst_EL.$E.Name.innerHTML.replaceAll("<br>", "\n"); //autoreplace "<br>"s
  var orig_name_str= name_str;
  var prom_str= "<b>Name</b> for " +(NEW_flag?"new ":"") +'alarm:' +TMX.g_promStr(name_str, NEW_flag?"?":"") +'<br>80 chars max, shift-enter for linebreak<br>(html allowed)'
  namePrompt_fn(); //so can be reused as err cb

  function namePrompt_fn() {
    jm.prompt_textarea(prom_str, name_str, resp => {
      if (resp==null || (resp==orig_name_str && !NEW_flag)) return; //-->

      name_str= (resp || "").trim();
      if (name_str.length > 80) {
        jm.error(`<p class="bad">Name length is up to 80 chars</p>Your text is ${name_str.length} chars`, () => {
          namePrompt_fn();
        });
      } else {
        name_str= name_str.replaceAll("\n", "<br>"); //autoreplace "\n"s
        if (NEW_flag) {
          TMX.alrm_editTime(name_str || "*"); //so NEW_str not empty
        } else {
          tmx.alarmInst_EL.$E.Name.innerHTML= name_str;
          TMX.alrm_glow();
          TMX.alarms_save();
        }
      }
    }, NEW_flag); //NEW_flag as highlight
  } //namePrompt_fn()

}; //TMX.alrm_editName()

TMX.alrm_editTime= function(NEW_str) { //if new, NEW_str is alarm name
  var orig_time_str= NEW_str ? "12:00" : tmx.alarmInst_EL.$D.hTime_str;
  var time_str= orig_time_str;

  var orig_loc_str= tmx.alarmInst_EL.$D.loc;
  var loc_str= orig_loc_str;

  var prom_str= "<b>Time</b> for " +(NEW_str?"new ":"") +"alarm:" +TMX.g_promStr(NEW_str, time_str);
  var pvLive_EL;
  timePrompt_fn();

  function timePrompt_fn() { //also reused as err fn
    jm.prompt(prom_str, time_str, {
      //jm custom cb object

      begin_cb: () => {
        pvLive_EL= jm._ELs.Description.querySelector(".pvLive");
        insertLocaleControls(pvLive_EL);
      },

      //custom hook
      Input_keyup: evt => { //or "aliasIO_keyup" would work also
        if (time_str != jm._ELs.Input.value) pop_prompt();
        //ignore many unwanted keys like "Shift"
      },

      end_cb: resp => {
        jm._ELs.locale_container.remove(); //not altogether, just from DOM

        if (resp == null) return; //-->

        var mod_time_str= resp;
        var mod_loc_str= jm._ELs.locale_name.textContent;
        if (mod_time_str==orig_time_str && mod_loc_str==orig_loc_str && !NEW_str) return; //-->

        //proc input str
        var alarmNow_obj;
        if (alarmNow_obj= TMX.alrm_procTimeText(mod_time_str, mod_loc_str, timePrompt_fn)) { //timePrompt_fn as err_cb
          if (NEW_str) {
            TMX.alrm_execAdd();
            TMX.sound_play("bell");
            tmx.alarmInst_EL.$E.Name.innerHTML= NEW_str;
          }

          tmx.alarmInst_EL.$D.hTime_str= alarmNow_obj.hTime_str;
          tmx.alarmInst_EL.$E.Time.textContent= alarmNow_obj.hTimeA_str || alarmNow_obj.hTime_str;

          tmx.alarmInst_EL.$D.loc= alarmNow_obj.loc;
          tmx.alarmInst_EL.$E.Loc.title= alarmNow_obj.loc || "";

          TMX.alrm_init(tmx.alarmInst_EL);
          if (tmx.active_aI_EL == tmx.alarmInst_EL) tmx.activeCountdown_EL.textContent= tmx.alarmInst_EL.$E.Ctdn.textContent;
          TMX.alarms_sort([tmx.alarmInst_EL]);

          TMX.alarms_save();
          TMX.alrm_glow(NEW_str ? 4 : 1);
        }
      }
    }, NEW_str); //NEW_str as highlight
  } //time_prompt()

  function pop_prompt() {
    loc_str= jm._ELs.locale_name.textContent;
    var aNow_obj= TMX.alrm_procTimeText(jm._ELs.Input.value, loc_str, "previewLive");
    var pl_str= "";
    if (aNow_obj) {
      pl_str= aNow_obj.hTime_str;
      pl_str+= "<br>" +aNow_obj.plUntil;
      if (aNow_obj.hTimeA_str) {
        pl_str+= '<br><span class="adjusted_tm">Local: ' +aNow_obj.hTimeA_str;
        var md= aNow_obj.hTimO.MD;
        if (md && md.EoM) pl_str+= ", MonthEnd=" +md.EoM;
        pl_str+= "</span>";
      }
    }
    pvLive_EL.innerHTML= pl_str;
  } //pop_prompt()

  function insertLocaleControls(pvLv_el) {
    if (!jm._ELs.locale_container) { //auto-init
      var cont_el= document.querySelector("div#localeContainerDiv");
      jm._ELs.locale_container= cont_el;
      //is in template div, but not really a template, just an easy place to hide it
      //single instance that gets embedded into modal when needed

      jm._ELs.locale_name= cont_el.querySelector("span#lLocaleNameSpan");
      jm._ELs.locale_chooser= cont_el.querySelector("div#localeChooserDiv");

      cont_el.querySelector("div#localeBut").addEventListener("click", evt => toggle_localeChooser() ); //üåê
      jm._ELs.locale_name.addEventListener("click", evt => toggle_localeChooser(true) );

      var localeLocalEl= cont_el.querySelector("span#localeLocalSpan"); //"LOCAL"
      localeLocalEl.addEventListener("click", evt => toggle_localeChooser(true) );

      var locales_ARR, regions_ARR;

      function toggle_localeChooser(flag) { //not just toggle, flag (truthy) will show/hide
        if (flag == undefined) jm._ELs.locale_chooser.classList.toggle("css_hidden");
        else TMXu.classEl(jm._ELs.locale_chooser, "css_hidden", !flag); //!reverese flag, "css_hidden" acts reversed, hide/show

        if (!jm._ELs.locale_chooser.$D_started_flag) { //start modal session
          jm._ELs.locale_chooser.$D_started_flag= true;

          if (!locales_ARR) { //auto-init, even deeper lazy
            [locales_ARR, regions_ARR]= TMX.init_localesList();
            regions_ARR.forEach(area_str => {
              regionsSelEl.add(new Option(area_str));
            });
          }

          let l_str;
          if (l_str= jm._ELs.locale_name.textContent) {
            regionsSelEl.value= l_str.split("/")[0]; //region_str
            pop_placesSel();
            placesSelEl.value= l_str.substring(regionString_len); //locale_str

          } else {
            regionsSelEl.value= "";
            placesSelEl.options.length= 1; //clear except for 1st option (blank)
          }
        } //start modal session

      } //toggle_localeChooser()

      var regionsSelEl= cont_el.querySelector("select#localeRegionsSel");
      regionsSelEl.add(new Option("")); //1st option blank
      regionsSelEl.addEventListener("change", evt => {
        placesSelEl.options.length= 1; //clear except for 1st option (blank)
        if (regionsSelEl.value) pop_placesSel();
        else TMX.setLocaleName("");
      });

      var placesSelEl= cont_el.querySelector("select#localePlacesSel");
      placesSelEl.add(new Option("")); //1st option is blank
      placesSelEl.addEventListener("change", evt => {
        var str= placesSelEl.value;
        if (str) str= regionsSelEl.value +"/" +str;
        TMX.setLocaleName(str);
        TMXu.classEl(jm._ELs.locale_chooser, "css_hidden", true);
      });

      var regionString_len;
      function pop_placesSel() {
        var region_str= regionsSelEl.value;
        regionString_len= region_str.length +1;
        locales_ARR.forEach(locale_str => {
          if (locale_str.indexOf(region_str) == 0) {
            placesSelEl.add(new Option(locale_str.substring(regionString_len)));
          }
        });
      }

      var localeDeleteEl= cont_el.querySelector("span#localeDeleteBut");
      localeDeleteEl.addEventListener("click", evt => {
        placesSelEl.value= "";
        TMX.setLocaleName("");
      });

      TMX.setLocaleName= function(locale_str, pvLv_el) { //pvLv_el only on modal session start
        jm._ELs.locale_name.textContent= locale_str;
        TMXu.showEl(localeDeleteEl, locale_str?"inline":false);
        TMXu.showEl(localeLocalEl, locale_str?false:"inline");
        if (!locale_str) TMXu.classEl(jm._ELs.locale_chooser, "css_hidden", true);

        //bug or just weird, pvLive_EL (for pop_prompt()) is incorrectly scoped, always refers to one the from the auto-init
        //fixed by passing pvLv_el //alternatively, moving TMX.setLocaleName to higher scope might of fixed it too
        if (pvLv_el) pvLive_EL= pvLv_el;

        pop_prompt();
      } //TMX.setLocaleName();

    } //auto-init

    jm._ELs.Input.insertAdjacentElement("afterend", jm._ELs.locale_container); //cont_el
    TMXu.classEl(jm._ELs.locale_chooser, "css_hidden", true);
    delete jm._ELs.locale_chooser.$D_started_flag; //clear for modal session

    TMX.setLocaleName(loc_str, pvLv_el);

  } //insertLocaleControls()

}; //TMX.alrm_editTime()


tmx.DoW_arr= "SUN,MON,TUE,WED,THU,FRI,SAT".split(",");

TMX.alrm_procTimeText= function(input_str, loc_str, param) { //returns alarmNow_obj if raw_str is good
  var preview_flag;
  var err_cb;
  if (typeof(param) == "string") preview_flag= param; //'preview' will not alert errors
  else if (typeof(param) == "function") err_cb= param;

  //.. geared toward keypad input, with some shortcuts baked in
  var index;
  input_str= input_str.trim();
  var raw_str= input_str.toUpperCase();
  var time_dtO= new Date(); //now
  var moDaO;
  if (raw_str.includes("/") || raw_str.search(/^[SMTWF]/)==0) {
    raw_str+= " ";
    index= raw_str.indexOf(" ");
    let mD_str= raw_str.substring(0, index);
    raw_str= raw_str.substring(index +1);
    if (!raw_str) raw_str= "12"; //default midnite
    moDaO= proc_moDa(mD_str); if (!moDaO) return err("bad month/day or DoW"); //-->
  }

  var time_str;
  var offset_str, offsetMod_str;
  [time_str, offset_str]= raw_str.split(/\+|-/);
  if (offset_str) offsetMod_str= raw_str[time_str.length]; //1 char,  + or -

  var raw_hTimO;
  if (time_str) {
    raw_hTimO= g_procRawTime(time_str);

    if (raw_hTimO.h > 12) return err('bad hour:<i class="E">' +raw_hTimO.h +'"</i>max is 12'); //-->
    if (raw_hTimO.m > 59) return err('bad minute:<i class="E">' +raw_hTimO.m +'</i>max is 59'); //-->

    raw_hTimO.p= time_str.search(/P|\*/) > -1; //chars: P *
    let rawAmPm_flag= raw_hTimO.p || time_str.search(/A/) > -1; //chars: A (AM)

    if (raw_hTimO.h == 0) { //auto-derive hr from now
      let h= time_dtO.getHours(); //0-23
      if (!rawAmPm_flag) raw_hTimO.p= (h >= 12);
      let m= time_dtO.getMinutes();
      if (raw_hTimO.m <= m) { //if rawMinutes less than nowMinutes, goto next hour
        h++; //inc
        if (h == 24) h= 0; //wrap
        raw_hTimO.h= h;
        proc_24to12(raw_hTimO);
      }
    }

  } else {
    raw_hTimO= {
      h: time_dtO.getHours(), //0-23
      m: time_dtO.getMinutes()
    };
    proc_24to12(raw_hTimO);
  }

  if (moDaO) raw_hTimO.MD= moDaO;

  var plUntil_str= "";

  time_dtO= g_dtO_fromHumanDtO(raw_hTimO);
  if (offset_str) {
    var ofsO;
    ofsO= g_procRawTime(offset_str, "offset");
    if (ofsO.h +ofsO.m < 1) return err("0 hour+minute (offset mode)"); //-->

    var time_ms= time_dtO.getTime();
    var sgn_num= offsetMod_str=="+" ? 1 : -1;

    if (ofsO.m) {
      if (ofsO.m > 59) return err(`modifier minutes:<i class="E">${ofsO.m}</i>max is 59`); //-->
      time_ms+= sgn_num *ofsO.m *60000; //60*1000 //modify mns
    }
    if (ofsO.h) {
      let max_h= ofsO.m ? 23 : 24; //max 24 hrs modifier
      if (ofsO.h > max_h) return err(`modifier hours:<i class="E">${ofsO.h}</i>max is ${max_h}`); //-->
      time_ms+= sgn_num *ofsO.h *3600000; //60*60*1000 //modify hrs
    }

    if (preview_flag == "previewLive") plUntil_str= "OFFSET" +offsetMod_str +TMX.g_untilStr(ofsO.m, ofsO.h) +"<br>";

    time_dtO= new Date(time_ms);
    //DST handled here by js date ?

    if (moDaO) { //offset can change d/m/y
      moDaO= {
        mo: time_dtO.getMonth() +1,
        da: time_dtO.getDate()
      };
    }
  } //offset_str

  var hTimO= {
    h: time_dtO.getHours(), //0-23
    m: time_dtO.getMinutes()
  };
  proc_24to12(hTimO);
  if (moDaO) hTimO.MD= moDaO;


  //hTimO done with time_dtO, so time_dtO can now be adjusted for "now" purposes
  var nowDtO= time_dtO; //alias, now dto

  var EoM_flag= moDaO && moDaO.EoM;
  if (EoM_flag) nowDtO.setMonth(moDaO.mo, 0); //eg. .setMonth(2, 0) //mar 0, means feb 28

  var tzDif_m;
  if (loc_str) { //eg. "America/Los_Angeles"
    tzDif_m= Math.round((nowDtO -TMX.timezoned_date(nowDtO, loc_str)) /60000);
    if (tzDif_m) nowDtO.setMinutes(nowDtO.getMinutes() +tzDif_m); //+- minutes
  }

  //check for turnover
  var diff_ms= nowDtO -new Date();
  if (diff_ms < 1) { //less than nowTime
    //dtO to future
    if (hTimO.MD) {
      if (hTimO.MD.DoW) nowDtO.setDate(nowDtO.getDate() +7); //+1 week, DayOfWeek
      else if (hTimO.MD.mW) nowDtO.setMonth(nowDtO.getMonth() +1); //+1 month, mon_wildcard_str
      else nowDtO.setFullYear(nowDtO.getFullYear() +1); //+1 year, m/d

    } else {
      nowDtO.setDate(nowDtO.getDate() +1); //+1 day
    }

//tbd //not sure if this is right..
    if (loc_str) {
      diff_ms= nowDtO -new Date(); //passed interntional dateline?
      if (diff_ms < 1) nowDtO.setDate(nowDtO.getDate() +1); //+1 day
    }
  }

  var aNow_obj= {
    hTimO: hTimO,
    hTime_str: get_fmatHTime_str(hTimO),
    ms: nowDtO.getTime()
  };

  if (loc_str) aNow_obj.loc= loc_str;

  if (tzDif_m || EoM_flag) adjustedHTimeStr(aNow_obj, nowDtO);  //adds aNow_obj.hTimeA_str

  if (preview_flag == "previewLive") {
    diff_ms= aNow_obj.ms -new Date(); //ms
    plUntil_str+= `(in: ${TMX.g_untilStr(Math.ceil(diff_ms /60000))}) `; //ms to minutes
    aNow_obj.plUntil= plUntil_str;
  }

//console.log("aNow_obj",aNow_obj)
  return aNow_obj;

  //----//




  function get_nstr(str) {
    return (str.match(/\d+/) || ["0"])[0]; //gets 'first' number, ignores rest //if none, will return "0"
    //note: "0" is truth-y
  }

  function g_procRawTime(str, offset_flag) {
    var h= 0;
    var m= 0;

    var split_arr= str.split(/:|\./);
    if (split_arr.length > 1) { //contains ":" or ".", explicit hrs and mns
      h= get_nstr(split_arr[0]) *1;
      m= get_nstr(split_arr[1]) *1;

    } else { //special shorthand
      var hm_str= get_nstr(str);
      var L= hm_str.length;
      if (hm_str[0]=="0" || L<=2) { //1-2 digits, or starts with "0"
        if (hm_str[0] == "0") { //starts with "0"
          //minutes mode, eg. "01" is 1 mn, "012" is 12 mns
          //just mns, hr 0
          m= hm_str *1;
        } else { //1-2 digits
          let n= hm_str *1;
          var maxH_n= offset_flag ? 24 : 12;
          if (n <= maxH_n) {
            h= n; //just hr, mn 0
            if (offset_flag && h==24) m= 0;
          } else {
            m= n; //just mn, hr 0
          }
        }
      } else { //3-4 digits
        //.. with "*" for 'pm', eg. 1220 .. 12:20am, or 420* .. 4:20pm
        h= hm_str.substring(0, L -2) *1; //begining, up to last 2 digits
        m= hm_str.substring(L -2) *1; //last 2 digits
      }
    }
    return {h:h, m:m};
  } //g_procRawTime()

  function get_fmatHTime_str(htO) {
    var str= "";
    if (htO.MD) str= (htO.MD.DoW ? htO.MD.DoW : ((htO.MD.mW || htO.MD.mo) +"/" +htO.MD.da)) +" "; //DoW or m/d
    return str +htO.h +":" +String(htO.m).padStart(2, "0")  +(htO.p?" PM":" AM"); //human time
  } //get_fmatHTime_str()

  function proc_24to12(tO) { //to human
    tO.p= tO.h >= 12;
    var h= tO.h;
    if (h > 12) h-= 12;
    else if (h == 0) h= 12;
    tO.h= h;
  }

  function g_dtO_fromHumanDtO(htO) { //from human time 12:59am/pm, to computer time 23:59
    var dtO= new Date(); //dateobj, start as now, but most items will be re-set
    if (htO.MD) {
      if (htO.MD.yr) dtO.setFullYear(htO.MD.yr, htO.MD.mo -1, htO.MD.da); //y //m 0..11 //d 1..31 //near New Year day
      else dtO.setMonth(htO.MD.mo -1, htO.MD.da); //m 0..11 //d 1..31
      //.. dont set month and date separately, because months having diff number of days, mistake can happen
    }

    var h= htO.h;
    if (h == 12) h= 0;
    if (htO.p) h+= 12;

    dtO.setHours(h);
    dtO.setMinutes(htO.m);
    dtO.setSeconds(0);

    return dtO;
  } //g_dtO_fromHumanDtO()

  function err(err_str) {
    if (preview_flag) return; //-->

    jm.error('<p class="bad">Alarm time error</p>' +err_str +'<br><br>Your raw input: <i class="E">' +input_str +'</i>', err_cb);
    //multiple errors are not returned, only the first error encountered
  }

  function proc_moDa(mD_str) { //if success, returns obj
    var mon_wildcard_str;
    var EoM_num;
    var DoW_str;
    if (mD_str.includes("/")) { // m/d (month/day)
      var month, day, year;
      [month, day]= mD_str.split("/");

      month*= 1;
      if (isNaN(month) || month<1 || month>12) {
        mon_wildcard_str= "?"; // ?/d (month wildcard)
        month= time_dtO.getMonth() +1; //no month? assume this month
      }

      day*= 1;
      if (isNaN(day) || day<1 || day>31) day= 1; //not verifying against number of days in month

      //possible EoM
      if (day == 31) {
        var EoMdtO= new Date();
        //our "month" var is 1-indexed, js "monnth" is 0-indexed
        EoMdtO.setMonth(month, 0); //nextMonth 0th day, means thisMonth last day
        if (EoMdtO -new Date() < 0) {
          EoMdtO.setFullYear(EoMdtO.getFullYear() +1); //+1 year
          EoMdtO.setMonth(month, 0); //re-do, leap day handled
        }
        EoM_num= EoMdtO.getDate(); //the last day of month
        if (day <= EoM_num) EoM_num= undefined;
      }

    } else if (mD_str.search(/^[SMTWF]/) == 0) { // DoW (Day of Week)
      var match_arr= [];
      tmx.DoW_arr.forEach((str, i) => {if (str.indexOf(mD_str)==0) match_arr.push(i); });
      if (match_arr.length != 1) return; //-->

      var DoW_n= match_arr[0];
      var copy_dtO= new Date(time_dtO); //lets not change time_dtO here
      var DoW_diff_n= DoW_n -copy_dtO.getDay(); //.getDay(), could be called getDoW, returns 0-6 (sun-sat)
      if (DoW_diff_n) copy_dtO.setDate(copy_dtO.getDate() +DoW_diff_n); //getDate() will change month/day correctly

      month= copy_dtO.getMonth() +1;
      day= copy_dtO.getDate(); //.getDate(), could be called getDay, returns 1-31
      var copy_year= copy_dtO.getFullYear();
      if (copy_year != time_dtO.getFullYear()) year= copy_year; //near New Year day

      DoW_str= tmx.DoW_arr[DoW_n];

    } else {
      return; //fail //-->
    }

    var o= {
      mo: month,
      da: day
    };
    if (year) o.yr= year;

    if (DoW_str) {
      o.DoW= DoW_str;
    } else {
      if (mon_wildcard_str) o.mW= mon_wildcard_str;
      if (EoM_num) o.EoM= EoM_num;
    }

    //success
    return o;
  } //proc_moDa()

  function adjustedHTimeStr(aNow_obj, dtO) {
    var ahtO= structuredClone(aNow_obj.hTimO);
    var mdO; if (mdO= ahtO.MD) {
      mdO.mo= dtO.getMonth() +1; //0-11
      mdO.da= dtO.getDate(); //1 indexed
    }
    ahtO.h= dtO.getHours(); //0-23
    ahtO.m= dtO.getMinutes(); //0-59
    proc_24to12(ahtO);
    var hTimeA_str= get_fmatHTime_str(ahtO);
//console.log("----------hTimeA_str", hTimeA_str)
    aNow_obj.hTimeA_str= hTimeA_str; //fyi, ahtO not preserved
  } //adjustedHTimeStr()

}; //TMX.alrm_procTimeText()


TMX.alrm_setTorC= function(aI_EL, flag, persist_flag) {
  if (aI_EL == tmx.active_aI_EL) jm.alert('Default view stored, will be displayed when this is not the active alarm');
  else TMX.alrm_setCtdnView(aI_EL, flag);

  if (persist_flag) aI_EL.$D.vu_cd= flag;
}; //TMX.alrm_setTorC()

TMX.alrm_setCtdnView= function(aI_EL, flag) {
  TMXu.showEl(aI_EL.$E.Ctdn, flag ? "inline-block" : false);
  TMXu.showEl(aI_EL.$E.Time, !flag ? "inline-block" : false);
}; //TMX.alrm_setCtdnView()

TMX.alrm_init= function(aI_EL) {
  var alarmNow_obj= TMX.alrm_procTimeText(aI_EL.$D.hTime_str, aI_EL.$D.loc, "preview");
  if (alarmNow_obj) {
    var cd_ms= alarmNow_obj.ms -new Date();
    if (cd_ms < 60000) ms= 60000; //minimum of 1 minute
    aI_EL.$D.ctdn_m= Math.ceil(cd_ms /60000);
    aI_EL.$E.Ctdn.textContent= TMX.g_untilStr(aI_EL.$D.ctdn_m);
    TMX.alrm_checkSoon(aI_EL);

    //EndofMonth display
    var EoM_num= alarmNow_obj.hTimO.MD && alarmNow_obj.hTimO.MD.EoM;
    aI_EL.$E.EoM.textContent= EoM_num ? "‚ú±" :"";
    aI_EL.$E.EoM.title= EoM_num ? "MonthEnd=" +EoM_num : "";

    //loc display
    aI_EL.$E.Loc.textContent= alarmNow_obj.loc ? "üåê" : ""; //globe symbol

    TMXu.classEl(aI_EL.$E.Time, "dt_adjusted", EoM_num || alarmNow_obj.loc);
  }
}; //TMX.alrm_init()


TMX.alrm_add= function() { //from UI
  TMX.alrm_editName("NEW");
}; //TMX.alrm_add()

TMX.alrm_execAdd= function() { //add 1
  var clAlrmInst_EL= tmx.template_alarmInst_EL.cloneNode(true); //clone
  TMX.alrm_addHelpers(clAlrmInst_EL, TMX.alrm_genId());
  tmx.alarmsCont_EL.appendChild(clAlrmInst_EL); //add to DOM
  if (tmx.disabler_mode) TMX.alrm_drawDisablerMode(clAlrmInst_EL);
  tmx.alarmInst_EL= clAlrmInst_EL;
  if (tmx.timeview_def_flag) TMX.alrm_setTorC(tmx.alarmInst_EL, true, "persist");
}; //TMX.alrm_execAdd()

TMX.alrm_genId= function() { //keeps id values low by utilizing unused "slots"
  var ids_set= new Set(tmx.deletedAlrmIds_set); //shallow copy
  [...tmx.aI_NL].forEach(aI_EL => {
    ids_set.add(aI_EL.id *1);
  });
  var new_id= 1;
  while (ids_set.has(new_id)) {
    new_id++;
  }
  return new_id;
}; //TMX.alrm_genId()


TMX.alrm_delete= function() { //from alarm delete-button
  jm.confirm("<b>Delete</b> alarm:" +TMX.g_promStr(), "", {
    custButText: {OkBut:"Delete"},
    end_cb: resp => {
      if (resp != true) return; //null-->
      TMX.alrm_execDelete();
    }
  });
}; //deleteAlarm()

TMX.alrm_execDelete= function() { //from TMX.alrm_delete() or drag&drop
  TMX.alrm_exeDel();
  TMX.alarms_save();
  TMX.sound_play("trsh");
}; //TMX.alrm_execDelete()

tmx.deletedAlrmIds_set= new Set(); //TMX.alrm_genId() will "reuse" lower ids, this ensures unique ids (per session)

TMX.alrm_exeDel= function() { //from TMX.alrm_execDelete() or TMX.alarms_external()
  if (!tmx.alarmInst_EL) return; //-->
  tmx.alarmInst_EL.remove(); //from DOM
  if (tmx.alarmInst_EL == tmx.ring_aI_EL) {
    TMX.ringer_stop("off");
  } else if (tmx.alarmInst_EL == tmx.active_aI_EL) {
    TMX.alrm_activate(false);
    TMX.alarms_autoActivateOne();
  }
  tmx.deletedAlrmIds_set.add(tmx.alarmInst_EL.id *1);
  tmx.alarmInst_EL= undefined;
}; //TMX.alrm_exeDel()


TMX.g_promStr= function(n_str, t_str) {
  var alStrO;
  if (!n_str || !t_str) alStrO= TMX.g_alStrO(tmx.alarmInst_EL);
  return `<p>${n_str || alStrO.name}</p>Time:<i class="pvLive">${t_str || alStrO.time}</i>`;
}; //TMX.g_promStr()

TMX.g_alStrO= function(aI_EL) {
  var n_str= aI_EL.$E.Name.innerHTML.replaceAll("<br>", " | ");
  var tmp_doc= new DOMParser().parseFromString(n_str, 'text/html');
  n_str= (tmp_doc.body.textContent || "").substring(0, 40);

  var t_str= aI_EL.$E.Time.textContent;
  if (t_str != aI_EL.$D.hTime_str) t_str= aI_EL.$D.hTime_str +' <span class="adjusted_tm">[' +t_str +"]</span>";

  return {
    name: n_str,
    time: t_str
  };
}; //TMX.g_alStrO()


TMX.alrm_activate= function(aI_EL) {
  if (tmx.active_aI_EL) { //prev active-alarm off
    TMXu.classEl(tmx.active_aI_EL, ["alarmActive", "expired", "soon"], false);
    TMX.alrm_init(tmx.active_aI_EL);
    TMX.alrm_setCtdnView(tmx.active_aI_EL, tmx.active_aI_EL.$D.vu_cd);
    TMX.alrm_glow(4, tmx.active_aI_EL, "darkgray");
    TMX.sound_play("slam");
  }

  var on_flag= !!aI_EL; //to boolean
  if (on_flag) {
    var alarmNow_obj= TMX.alrm_procTimeText(aI_EL.$D.hTime_str, aI_EL.$D.loc, "preview"); //nrn, final check of alrm_str
    if (!alarmNow_obj) {on_flag= false; TMXu.message_add("bad alarm time: " +uTime_str +" | " +alStrO.name, "pink"); }
  }

  if (on_flag) { //alarm on
    tmx.active_aI_EL= aI_EL;
    tmx.activeCountdown_flag= true;
    tmx.active_ctdn_m= aI_EL.$D.ctdn_m;
    tmx.activeCountdown_EL.textContent= TMX.g_untilStr(tmx.active_ctdn_m);
    tmx.active_hTimO= alarmNow_obj.hTimO;

    TMXu.classEl(aI_EL, "alarmActive", true);
    aI_EL.insertAdjacentElement("afterend", tmx.activeDiv_EL);
    TMXu.showEl(tmx.activeDiv_EL, true);
    TMXu.showEl(tmx.activeCountdown_EL, true);
    TMX.alrm_setCtdnView(aI_EL, false); //if needed //shows time

    tmx.clockMarker_n= undefined;
    TMX.clock_checkMarker();

    TMX.sound_play("beep");
    TMX.alrm_scrollTo();

  } else { //alarm off
    tmx.active_aI_EL= undefined;
    tmx.activeCountdown_flag= false;
    tmx.active_ctdn_m= 0;

    TMXu.showEl(tmx.activeDiv_EL, false);
    TMXu.showEl(tmx.cf_marker_EL, false);
  }
}; //TMX.alrm_activate()

TMX.alrm_silentExpire= function(aI_EL) { //alarm not active, so no ringer
  var alStrO= TMX.g_alStrO(aI_EL);
  var msg_EL= TMXu.message_add("Alarm expired: " +alStrO.time +" | " +alStrO.name, "pink");
  msg_EL.$exp_aI_EL= aI_EL;
  aI_EL.$exp_msg_EL= msg_EL;
}; //TMX.alrm_silentExpire()

TMX.alrm_checkSoon= function(aI_EL) {
  var soon_flag= aI_EL.$D.ctdn_m < 720; //12 hrs, soon
  if (soon_flag != aI_EL.classList.contains("soon")) TMXu.classEl(aI_EL, "soon", soon_flag);
}; //TMX.alrm_checkSoon()


TMX.alarms_minuteUpdate= function() {
  TMX.sysAlarm_check(tmx.sync_ms);

  if (!tmx.vis_ct) return; //-->

  var until_str;
  [...tmx.aI_NL].forEach(aI_EL => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in tmx.disabler_mode all are visible)
      aI_EL.$D.ctdn_m-= 1; //-1 minute
      if (aI_EL==tmx.active_aI_EL && tmx.activeCountdown_flag) tmx.active_ctdn_m= aI_EL.$D.ctdn_m;

      if (aI_EL.$D.ctdn_m <1 ) { //expire
        if (!aI_EL.classList.contains("expired")) { //new expire
          TMXu.classEl(aI_EL, "expired", true);
          if (aI_EL != tmx.active_aI_EL) TMX.alrm_silentExpire(aI_EL);
        }

      } else {
        TMX.alrm_checkSoon(aI_EL);
      }

      until_str= TMX.g_untilStr(aI_EL.$D.ctdn_m);
      if (until_str != aI_EL.$E.Ctdn.textContent) aI_EL.$E.Ctdn.textContent= until_str;
      //.. alarms 1+ days, dont need to re-render every minute

    } //visible
  });

  if (tmx.activeCountdown_flag) {
    if (tmx.active_ctdn_m < 1) { //end active countdown
      tmx.activeCountdown_flag= false;
      TMXu.showEl(tmx.activeCountdown_EL, false);
      TMX.ringer_start(tmx.active_aI_EL);
    } else {
      tmx.activeCountdown_EL.textContent= TMX.g_untilStr(tmx.active_ctdn_m);
      TMX.clock_checkMarker();
    }

  } else if (tmx.snooze_ctdn_m) {
    tmx.snooze_ctdn_m--; //inc-
    TMX.snooze_check();
  }
}; //TMX.alarms_minuteUpdate()

TMX.alarms_sort= function(aa_override_arr =[]) {
  if (!tmx.vis_ct) return; //-->

  TMX.sound_play("clik");

  var arr= [...tmx.aI_NL];
  arr
    .sort((a, b) => a.$D.ctdn_m -b.$D.ctdn_m)
    .forEach(aI_EL => tmx.alarmsCont_EL.appendChild(aI_EL)) //reorder in DOM
  ;

  if (!tmx.ring_aI_EL) TMX.alarms_autoActivateOne(aa_override_arr); //no autoActivate if alarm is ringing/snoozed

  if (tmx.active_aI_EL) tmx.active_aI_EL.insertAdjacentElement("afterend", tmx.activeDiv_EL); //alarm els sorted, move tmx.activeDiv_EL under correct alarm el

  TMX.alrm_scrollTo();
}; //TMX.alarms_sort()

TMX.alarms_autoActivateOne= function(override_arr =[]) {
  //auto activate top alarm
  var topAI_EL= [...tmx.aI_NL].find(aI_EL => aI_EL.checkVisibility() && !aI_EL.classList.contains("expired")); //skip disabled, expired
  if (topAI_EL && topAI_EL!=tmx.active_aI_EL && (!tmx.active_aI_EL || override_arr.includes(topAI_EL))) {
    //exists      not same                   dont override active, unless its in aa_override_arr
    TMX.alrm_activate(topAI_EL);
  }
}; //TMX.alarms_autoActivateOne()

TMX.alarms_external= function(external_str) {
  TMX.data_save("externalAlarms", ""); //clear

  var action_str;
  var spl_ar;
  var time_str, loc_str, alarmNow_obj;
  var name_str;
  var html_str;
  var add_arr= []; //for sound only
  var del_arr= []; //for sound only
  external_str.split("\n").forEach(item_str => {
    spl_ar= item_str.split("|");
//console.log(action_str,"item_str",item_str,"split",spl_ar);

    action_str= spl_ar[0]; //external, externalDelete
    if (action_str == "external") {
      //external|5/5 12:34pm|Some Alarm
      //external|5/5 12:34pm|PC|WED|New%20York%20Yankees|K|123-1 //to test, can paste right into console "Local storage"

      time_str= spl_ar[1]; //5/5 12:34pm loc:America/Los_Angeles
      if (time_str.indexOf("loc:") >= 0) [time_str, loc_str]= time_str.split("loc:");

      if (time_str) {
        if (alarmNow_obj= TMX.alrm_procTimeText(time_str +"-020", loc_str, "preview")) { // -20 minutes
          TMX.alrm_execAdd();

          html_str= TMX.HOOK("extAddAlarm", spl_ar) || name_str;
          tmx.alarmInst_EL.$E.Name.innerHTML= html_str;

          tmx.alarmInst_EL.$D.hTime_str= alarmNow_obj.hTime_str;
          tmx.alarmInst_EL.$E.Time.textContent= alarmNow_obj.hTimeA_str || alarmNow_obj.hTime_str;

          TMX.alrm_init(tmx.alarmInst_EL);
          TMX.alrm_glow(4);
          add_arr.push(tmx.alarmInst_EL); //for sound only
        }
      }

    } else if (action_str == "externalDelete") {
      name_str= spl_ar[1];
      //externalDelete|Some Alarm
      //externalDelete|123-1|PC

      let delAlarm_EL= TMX.HOOK("extDeleteAlarm", spl_ar);
      if (!delAlarm_EL) delAlarm_EL= [...tmx.alarmsCont_EL.querySelectorAll("div.alarmName")]
        .find(EL => EL.textContent == name_str)
      ;

      if (delAlarm_EL) { //if multiple alarms with this tid, only 1st alarm deleted //so edge its silly
        del_arr.push(delAlarm_EL); //for sound only
        tmx.alarmInst_EL= delAlarm_EL;
        TMX.alrm_exeDel();
      } else {
        TMXu.message_add("External-delete of " +name_str +" failed");
      }

    } //action_str
  });

  TMX.sound_play("bell", add_arr, 1500); //1400, bell is longish clip
  TMX.sound_play("trsh", del_arr, 1000);
  //when both add and de, sounds prob mess up

  if (add_arr.length || del_arr.length) {
    TMX.alarms_sort(add_arr);
    TMX.alarms_save();
  }
}; //TMX.alarms_external()

TMX.alarms_getDataArr= function() {
  tmx.vis_ct= 0;
  var al_arr= []; //data model, temporary
  if (tmx.aI_NL.length) {
    var a_obj;
    var name_str;
    [...tmx.aI_NL].forEach(aI_EL => {
      a_obj= {id:aI_EL.id *1, t:aI_EL.$D.hTime_str}; //id, time
      if (name_str= aI_EL.$E.Name.innerHTML) a_obj.n= name_str;
      if (aI_EL.$D.vu_cd) a_obj.c= 1; //countdown view
      if (aI_EL.$D.loc) a_obj.l= aI_EL.$D.loc;

      if (tmx.disabler_mode ? !aI_EL.querySelector("input").checked : !aI_EL.checkVisibility()) a_obj.d= 1; //disabled
      else tmx.vis_ct++;

      al_arr.push(a_obj);
    });
  }
  return al_arr;
}; //TMX.alarms_getDataArr()

TMX.alarms_save= function() {
  //note: always saves all alarms, no such thing as saving 1 alarm
  var saveAl_arr= TMX.alarms_getDataArr();
//console.trace("TMX.alarms_save",saveAl_arr)
  var json_str= JSON.stringify(saveAl_arr);
  TMX.data_save("alarms", json_str);
  TMX.HOOK("alarmsSave", json_str);
}; //TMX.alarms_save()


tmx.ringDiv_EL= document.querySelector("div#ringDiv");
tmx.ringSnoozeBut_EL= tmx.ringDiv_EL.querySelector("div#ringSnoozeBut")
tmx.ringSnzCountdown_EL= tmx.ringDiv_EL.querySelector("div#ringSnzCountdown");

tmx.ring_aI_EL;
tmx.ring_intimerId;
tmx.snooze_ctdn_m;

TMX.ringer_start= function(aI_EL) {
  if (aI_EL) tmx.ring_aI_EL= aI_EL; //1st TMX.ringer_start, as opposed to snooze-end TMX.ringer_start

  TMX.alrm_scrollTo("noExp");
  TMX.sound_play("rngr");

  TMXu.showEl(tmx.ringDiv_EL, true);
  jm._ELs.Overlay.classList.add("flash");
  tmx.ring_intimerId= setInterval(() => { //recurse
    jm._ELs.Overlay.classList.toggle("flash");
    TMX.sound_play("rngr");
  }, 5000);

  jm.confirm("Alarm ring<p>" +tmx.active_aI_EL.$E.Name.textContent +"</p>", "", {
    //jm custom cb object
    custButText: {OkBut:"OFF", CancelBut:"SNOOZE"},
    end_cb: resp => {
      if (resp) resp= "off"; //true .. "off" //else snooze
      TMX.ringer_stop(resp);
    }
  });

}; //TMX.ringer_start()

//note: for ringer start, if these are 'in progress'...
//longPress, should be ok, process normally
//drag, will be just be an unsuccessful drop
//modal, as if it was 'paused'

TMX.ringer_stop= function(flag, snooze_n) { //without flag, default is 'snooze'
  if (!tmx.ring_aI_EL) return; //-->

  if (tmx.ring_intimerId) {
    clearInterval(tmx.ring_intimerId);
    tmx.ring_intimerId= undefined;
    jm._ELs.Overlay.classList.remove("flash");
  }

  if (flag == "off") {
    tmx.ring_aI_EL= undefined;
    TMXu.showEl(tmx.activeDiv_EL, false);
    TMXu.showEl(tmx.ringDiv_EL, false);
    tmx.snooze_ctdn_m= 0; //if needed

    TMX.alrm_activate(false);
    TMX.alarms_sort();

  } else { //snooze
    //note: snooze wont be exact, since it only checks/fires at top of minute
    //eg. 5 minutes will be 4-5 minutes
    tmx.snooze_ctdn_m= snooze_n || tmx.snooze_def_num;
    TMX.sound_play("knoc");
  }

  TMX.snooze_draw(); //if needed
}; //TMX.ringer_stop()

TMX.snooze_draw= function() {
  tmx.ringSnzCountdown_EL.innerHTML= tmx.snooze_ctdn_m ? TMX.g_untilStr(tmx.snooze_ctdn_m) : "&nbsp;";
}; //TMX.snooze_draw()

TMX.snooze_check= function() {
  TMX.snooze_draw();
  if (!tmx.snooze_ctdn_m) { //end snooze
    TMX.ringer_start();
  }
}; //TMX.snooze_check()

TMX.g_untilStr= function(m, h) {
  var str;
  if (m >= 1440) {
   str= Math.floor(m /1440) +"d";

  } else {
    if (h == undefined) {
      if (m > 59) {
        h= Math.floor(m /60);
        m= m %60;
      }
    }
    str= h ? (h +"h") : "";
    if (m) str+= " " +m +"m";
  }

  return str;
}; //TMX.g_untilStr()


tmx.alrmExpChange_flag;

TMX.alrm_unexpire= function(aI_EL) {
  tmx.alrmExpChange_flag= true;
  delete aI_EL.$exp_msg_EL;

  if (!aI_EL.closest("div#alarmsContainer")) { //is orphan
    //after an TMX.alarms_start() (various ways), this aI_EL is an "orphan" (not in current DOM)
    //reacquire alarm..
    let _aI_EL= tmx.alarmsCont_EL.querySelector('[id="' +aI_EL.id +'"]'); //note: els dont have .getElementById()
//console.log("TMX.alrm_unexpire, orphan:",aI_EL, "reacquire:",_aI_EL);
    if (_aI_EL) aI_EL= _aI_EL; //reacquired
    else return; //could not reacquire alarm //-->
  }

  TMXu.classEl(aI_EL, ["expired", "soon"], false);
  TMX.alrm_init(aI_EL);
  TMX.alrm_glow(2, aI_EL, "pink");
}; //TMX.alrm_unexpire()


tmx.sysAlarms_arr= [];
tmx.sysAlarms_lu= {};

TMX.sysAlarm_addOrDel= function(name_str, ms, handler) {
  var sAO;
  if (ms != undefined) { //add
    sAO= {n:name_str, ms:ms, handler:handler};
    tmx.sysAlarms_arr.push(sAO);
    tmx.sysAlarms_lu[name_str]= sAO;

  } else { //del
    sAO= tmx.sysAlarms_lu[name_str];
    tmx.sysAlarms_arr.splice(tmx.sysAlarms_arr.indexOf(sAO), 1);
    delete tmx.sysAlarms_lu[name_str];
  }
}; //TMX.sysAlarm_addOrDel()

TMX.sysAlarm_check= function(ms) {
  if (!tmx.sysAlarms_arr.length) return; //-->

  tmx.sysAlarms_arr.forEach(sAO => {
    if (ms >= sAO.ms) {
      if (sAO.handler) { //handler goes first
        if (sAO.handler(sAO, ms)) return; //handler can abort sAO removal //-->
      }

      TMXu.message_add(sAO.n);
      TMX.sysAlarm_addOrDel(sAO.n); //delete sysAlarm
    }
  });
}; //TMX.sysAlarm_check();


tmx.clock_TZ= Intl.DateTimeFormat().resolvedOptions().timeZone;
//timezone change can happen any minute, so not going to check for it, user needs to manually do browser reload
tmx.clock_tzo;
tmx.tzoc_arr;

TMX.tzoc_start= function() { //runs upon startup
  tmx.clockFace_EL.querySelector("div#dtDisplay").title= tmx.clock_TZ;

  tmx.clock_tzo= tmx.start_dtO.getTimezoneOffset();
  var year_n= tmx.start_dtO.getFullYear();
  var tzYear_key= tmx.clock_TZ +"_" +year_n;
  TMX.data_load("tzoc", dataO => proc_tzoc(dataO.tzoc));

  function proc_tzoc(tz_str) {
    if (!tz_str) tz_str= ""; //param default only works if undeined
    var tz_ar= tz_str.split(",");
    if (tz_ar[0] != tzYear_key) { //init (annually if no travel)
      //.. if user never turns off this app, wont reset annually, edge
      var raw_arr= TMX.tzoc_getDates(year_n);
//console.log(raw_arr)
      if (raw_arr[0] == year_n) { //nrn
        raw_arr[0]= tzYear_key;

        TMXu.message_add("Timezone offset changes for " +raw_arr.join(", "));

        tz_str= raw_arr.join(",");
        TMX.data_save("tzoc", tz_str);

        tz_ar= raw_arr;
      }
    }

    tmx.tzoc_arr= [];
    var alarmNow_obj, ms;
    tz_ar.forEach((str, i) => {
      if (i == 0) { //tzYear_key
        tmx.tzoc_arr[0]= str;
      } else {
        alarmNow_obj= TMX.alrm_procTimeText(str, "", "preview");
        ms= alarmNow_obj ? alarmNow_obj.ms : 0;
        tmx.tzoc_arr[i]= {t:str, ms:ms};
      }
    });

    TMX.tzoc_check(tmx.start_dtO);

  } //proc_tzoc()

}; //TMX.tzoc_start()

TMX.tzoc_check= function(dtO) { //noon and midnite
  if (tmx.tzoc_arr.length <= 1) return; //just tzYear_key, no dateTimes (no daylight savings) //-->

  var now_ms= dtO.getTime();
  var until_ms= now_ms +43200000; //12hr
  var ms;
  tmx.tzoc_arr.forEach((tzO, i) => {
    if (i) { //skip 0, tzYear_key
      ms= tzO.ms;
      if (ms >= now_ms && ms <= until_ms) add_sysAlm(tzO); //daylight savings on/off
    }
  });

  function add_sysAlm(tzO) {
    var name_str= "LOCAL Time zone offset change: " +tzO.t;
    if (tmx.sysAlarms_lu[name_str]) return; //skip, already added //-->

    TMX.sysAlarm_addOrDel( //add
      name_str,
      tzO.ms,
      function(sAO, ms) { //handler
        var dtO= new Date();
        var tzo= dtO.getTimezoneOffset(); //est 300, dst 240
        var diff_tzo= tmx.clock_tzo -tzo; //0, +- 60
        if (!diff_tzo) return "abort_sAO_removal"; //-->
        //.. can happen if clock is slighly ahead
        //.. will try again next minute

        tmx.clock_tzo= tzo;
        var diff_hr= Math.sign(diff_tzo); // +- 1

        //https://www.timeanddate.com/time/dst/transition.html
        console.log("TZO change", diff_hr, dbg.g_fmatDtO(tmx.sync_dtO)); //DST change -1 @3:00:00.013

        //becomes 3am (forward) or 1am (back) ..
        tmx.cf_degO.hr+= diff_hr *tmx.cf_h_inc *60;
        TMX.clock_drawHands();

        tmx.clock_hr24= dtO.getHours(); //reset

        TMX.sound_play("clik");
      } //handler
    );
  } //add_sysAlm()

}; //TMX.tzoc_check()

TMX.tzoc_getDates= function(year_n) { //determine time zone offset changes for current year
  //based on the time/location settings of computer, so should work anywhere
  //generate dates once a year (after new year)
  var arr= [year_n];
  var dtO= new Date(year_n, 0);

  //month: 0-11, 0 indexed
  var first_month_i= 0;
  var last_month_i= 11;
  var ftzo_obj;
  var date_str;

  var first_i= first_month_i;
  var prev_tzo;
  do {
    dtO.setDate(1); dtO.setHours(0); //reset
    ftzo_obj= find_tzoChg(first_i , last_month_i, "setMonth", prev_tzo);
    //note: if tzo changes on and off within a month, we wont catch it, edge or non-issue
    date_str= ftzo_obj ? find_tzoChgInMonth(year_n, ftzo_obj.i) : ""; //date_str also acts as success flag
    if (date_str) {
      arr.push(date_str);
      if (ftzo_obj.i >= last_month_i) {
        date_str= undefined; //break
      } else {
        first_i= ftzo_obj.i +1;
        prev_tzo= ftzo_obj.tzo;
        //next
      }
    }
  } while (date_str)

  return arr;
  //end


  function find_tzoChg(first_i, last_i, dFn_key, prev_tzo) { //note: param 2 is last_i, not .length
    var tzo;
    //Loop through every month of the current year
    for (var i=first_i; i<=last_i; i++) {
      dtO[dFn_key](i); //set month or day
      tzo= dtO.getTimezoneOffset();
//console.log(dFn_key,first_i,i,tzo,dtO)
      if (prev_tzo!=undefined && tzo!=prev_tzo) return {i:i -1, tzo:tzo}; //success //-->
      //.. i -1, change occurs in the previos unit (hr, day, month)

      prev_tzo= tzo;
    }
  } //find_tzoChg()

  function find_tzoChgInMonth(year, month) {
    var ftzo_obj;
    dtO.setMonth(month);
    var daysInMonth= new Date(year, month+1, 0).getDate(); //use the 'next' month, minus 1 day (day 0) //month is 0 indexed, day is 1 indexed
    ftzo_obj= find_tzoChg(1, daysInMonth, "setDate");
    if (!ftzo_obj) return; //-->

    var day= ftzo_obj.i;
    dtO.setDate(day);
    ftzo_obj= find_tzoChg(0, 23, "setHours");
    if (!ftzo_obj) return; //-->

    var hour= ftzo_obj.i;

    //to human read
    month++;
    hour++;
    var amPm_str= hour>=12 ? "PM" : "AM";
    hour= hour%12;
    if (hour == 0) hour= 12;
    return month +"/" +day +" " +hour +":00" +amPm_str;
  } //find_tzoChgInMonth()

}; //TMX.tzoc_getDates()


TMX.init_localesList= function() {
  const regions_Set= new Set();
  const locales_arr= Intl.supportedValuesOf("timeZone");
  locales_arr.forEach(key => {
    regions_Set.add(key.split("/")[0]);
  });
  return [locales_arr, [...regions_Set]];
}; //init_localesList()

TMX.timezoned_date= function(dateV, tz_str) {
  //https://stackoverflow.com/questions/10087819/convert-date-to-another-timezone-in-javascript
  return new Date((typeof dateV=="string" ? new Date(dateV) : dateV).toLocaleString("en-US", {timeZone: tz_str}));
}; //timezoned_date()


TMX.data_load= function(key, cb) {
  var keys_arr= Array.isArray(key) ? key : [key];
  var dataO= {};
  keys_arr.forEach(k => dataO[k]= TMXu.ls(k) ); //ls get
//console.log("load LS", key, "dataO", dataO);
  if (cb) cb(dataO);
}; //TMX.data_load()

TMX.data_save= function(key, data, cb) { //can only save 1 item per call
  TMXu.ls(key, data); //ls set
//console.log("save LS", key, "data", data);
  if (cb) cb("set");
}; //TMX.data_save()
//for TMX.data_remove(), use TMX.data_save() with data as ""


TMX.sound_play= function(ac_key, repeat_n =1, step_ms =750) {
  if (typeof(repeat_n) == "object") repeat_n= repeat_n.length; //repeat_n. passed in an arr
  if (!repeat_n) return; //-->

  if (repeat_n == 1) {
    tmx.audioClips[ac_key].play();
    return; //-->
  }

  var ct= 0;
  step_play(); //kickoff

  function step_play() {
    tmx.audioClips[ac_key].play();
    ct++;
    if (ct < repeat_n) setTimeout(step_play, step_ms); //recurse //-->
  }
}; //TMX.sound_play()


//jm (modal)
const jm= {
  _ELs: {},
  _type: 0,
  _queue: [],

  init: function() {
    //pop jm._ELs (aliasIO is dynamically assigned)
    var el, jid;
    "div#jwmOverlay, span#jwmCloseBut, div#jwmDescription, input#jwmInput, textarea#jwmTextarea, button#jwmOkBut, button#jwmNoBut, button#jwmCancelBut".split(", ").forEach(sel_str => {
      el= document.querySelector(sel_str);
      jid= sel_str.split("#")[1].replace("jwm", ""); //basically, jid is the element id with the "jwm" removed
      jm._ELs[jid]= el;
      if (jid.includes("But")) el.$origText= el.textContent; //for init-button
    });

    //modal handlers
    document.addEventListener("keyup", evt => { //capture any keyup
      if (document.body.classList.contains("jw-modal-active")) { //modal active
        if (evt.key=="Escape" || (evt.key=="Enter" && !evt.shiftKey)) jm._respond(evt.key);
        //since modal can contain textarea, no 'nav' keys should be captured (arrow, tab)
        //also shift-enter allows linebreak in textarea
        else if (jm._type == "BOOLEAN") jm._booleanKeystroke(evt.key); //however, this does do 'nav' keys
      }
    });

    jm._mouseHandler("Textarea_keydown", evt => { //linebreak in textarea, prevent enter key (use shift-enter)
      if (evt.key=="Enter" && !evt.shiftKey) evt.preventDefault();
    });

    jm._mouseHandler("Overlay_mousedown", evt => { //"click" can get accidental "click"
      if (evt.target == jm._ELs.Overlay) jm._respond("Overlay Click"); //close modal
    });

    jm._mouseHandler("OkBut", evt => {
      if (jm._type == "BOOLEAN") jm._ELs.aliasIO.value= "OK";
      jm._respond();
    });

    jm._mouseHandler("NoBut", evt => {
      jm._ELs.aliasIO.value= "NO";
      jm._respond();
    });

    jm._mouseHandler("CancelBut", evt => {
      jm._respond("CANCEL");
    });

    jm._mouseHandler("CloseBut", evt => {
      jm._respond("CLOSE");
    });

  }, //init()

  dialog: function(type_str, text_str, value_str, cb, highlight_flag) { //ck, non blocking modal
    //all types can have cb (callback)

    if (document.body.classList.contains("jw-modal-active")) { //modal active
      jm._queue.push(
        () => { //anon fn that stores function call (w vargs) to be used later
          jm.dialog(type_str, text_str, value_str, cb);
        }
      );
      return; //abort //-->
    }

    jm._ELs.aliasIO= jm._ELs.Input; //default, .Input

    jm._displayEls("Input,Textarea,NoBut,CancelBut", false);
    jm._displayEls("OkBut", "inline"); //OkBut already displayed, but needs init-button
    jm._classEls("OkBut", "toggleable", false);
    jm._classEls("OkBut,NoBut", "hilite", false);

    if (typeHas(/ALERT|ERROR|CONFIRM|BOOLEAN/)) {
      jm._ELs.aliasIO.value= "OK"; //default

      if (typeHas("BOOLEAN")) {
        jm._displayEls("NoBut,CancelBut", "inline");
        jm._classEls("OkBut", "toggleable");
        jm._ELs.OkBut.textContent= "Yes"; //was "OK"
        var state_flag= !!value_str; //to boolean
        //.. local var
        if (!state_flag) jm._ELs.aliasIO.value= "NO";
        //.. actual value kept in aliasIO.value as string ("OK", "NO")
        jm._booleanKeystroke(); //hilte only

      } else if (typeHas("CONFIRM")) { //CONFIRM is just an ALERT with a Cancel button
        jm._displayEls("CancelBut", "inline");

      } else if (typeHas("ERROR")) TMX.sound_play("buzz");

    //} else if (type_str.search(/PROMPT$|PROMPT_TEXTAREA/) > -1) {
    } else if (typeHas("PROMPT_")) {
      if (typeHas("PROMPT_TEXTAREA")) jm._ELs.aliasIO= jm._ELs.Textarea; //.Textarea

      jm._ELs.aliasIO.value= value_str;

      jm._displayEls("aliasIO", true);
      jm._displayEls("CancelBut", "inline");

    } else {
      console.error("jm.dialog, bad type_str:", type_str);
      return; //-->
    }

    function typeHas(v) { //v can be string or regEx
      return (typeof(v)=="string" ? type_str.indexOf(v) : type_str.search(v)) > -1;
    }

    jm._type= type_str;
    jm._ELs.Description.innerHTML= text_str;

    if (cb) {
      if (typeof(cb) == "object") { //custom hooks object

        if (cb.begin_cb && typeof(cb.begin_cb)=="function") {
          if (cb.begin_cb() == false) return; //caller can abort //-->
        }

        jm._cbObject(cb, "start");

      } else if (typeof(cb) != "function") { //otherwise should a fn (that is the 'end' callback)
        cb= undefined; //error, no message
      }
    }
    jm._cb= cb;

    if (typeHas("BOOLEAN")) {
      jm.bool_kc0= jm._ELs.NoBut.textContent[0]; //1st char, "No" .. "N"
      jm.bool_kc1= jm._ELs.OkBut.textContent[0]; //1st char, "Yes" .. "Y"
      //note: only boolean accepts button-first-letter keystrokes
      if (jm.bool_kc0 == jm.bool_kc1) { //need different keystrokes
        jm.bool_kc0= undefined;
        jm.bool_kc1= undefined;
      }
      //needed by _booleanKeystroke()
    }

    jm._modelOpen("jwmModal");

    //modal needs to be visible to .focus() or .select()
    if (typeHas("PROMPT_")) {
      //note: textareas, if text is highlighted, any key (except enter-key) will delete the text!
      //note: enter-key always submits (custom)
      if (highlight_flag) jm._ELs.aliasIO.select();
      else jm._ELs.aliasIO.focus();
    }
  },

  alert: function(text_str, cb) {
    jm.dialog("ALERT", text_str, "", cb); //returns true or null
  },
  error: function(text_str, cb) {
    jm.dialog("ERROR", '<p class="bad">' +text_str +'</p>', "", cb); //returns true or null
  },

  confirm: function(text_str, value_flag, cb) { //value_flag not used
    jm.dialog("CONFIRM", text_str, "", cb); //returns true or null
  },

  boolean: function(text_str, value_flag, cb) {
    jm.dialog("BOOLEAN", text_str, value_flag, cb); //returns true or false or null
    //param called value_flag here, but jm.dialog will still call it value_str
  },

  prompt: function(text_str, value_str, cb, highlight_flag) {
    jm.dialog("PROMPT_INPUT", text_str, value_str, cb, highlight_flag); //returns string or null
  },
  prompt_textarea: function(text_str, value_str, cb, highlight_flag) {
    jm.dialog("PROMPT_TEXTAREA", text_str, value_str, cb, highlight_flag); //returns string or null
  },


  close: function() {
    if (document.body.classList.has("jw-modal-active")) jm._respond("Escape");
  },

  _cbObject: function(cbO, mode_key) { //mode_key: start, finish
    var jid, el, evt_key;
    Object.keys(cbO).forEach(c_code => {
      if (c_code == "custButText") {
        if (mode_key=="start") {
          var but_hash= cbO[c_code];
          if (typeof(but_hash) == "object") { //eg. {CancelBut: "SNOOZE"}
            Object.keys(but_hash).forEach(b_key => {
              if (el= jm._ELs[b_key]) el.textContent= but_hash[b_key];
            });
          }
        }
      } else if (c_code=="begin_cb" || c_code=="end_cb") {
        //do nothing

      } else { //custom hooks
        [jid, evt_key]= c_code.split("_");
        if (evt_key) {
          if (el= jm._ELs[jid]) {
            if (mode_key=="start") el.addEventListener(evt_key, cbO[c_code]);
            else el.removeEventListener(evt_key, cbO[c_code]);
          }
        }
      }
    });

    //c_code
      //custButText
      //begin_cb, returns nothing
      //end_cb, returns resp
      //(custom hooks, handler on any event on any jm._ELs item, returns event)
        //eg. "Input_keyup" is 'keyup' event on input#jwmInput
        //eg. "OkBut_mouseover" is 'mouseover' event on button#jwmOkBut

  }, //_cbObject

  _booleanKeystroke: function(key) {
    //boolean dialogs have 3 buttons, Yes, No and Cancel
    //they are highlightable by nav keys, and is submittable by shortcut key (Y/N)
    var state_flag= jm._ELs.aliasIO.value == "OK"; //local var
    var submit_flag;

    if (key) { //key capture
      key= key.toUpperCase();
      if (key==jm.bool_kc1 || key==jm.bool_kc0) { //"Y" or "N"
        state_flag= value= key==jm.bool_kc1; //"Y"
        submit_flag= true;
      } else if (key.indexOf("ARROW") == 0) {
        state_flag= !state_flag; //toggle
      }
      jm._ELs.aliasIO.value= state_flag ? "OK" : "NO";
    }

    //highlight Y/N Button
    liteBut("OkBut", state_flag);
    liteBut("NoBut", !state_flag);
    function liteBut(jid, flag) {
      TMXu.classEl(jm._ELs[jid], "hilite", flag);
    }

    if (submit_flag) jm._respond(); //btw, closes modal
  }, //_booleanKeystroke

  _respond: function(act_code ="") {
    if (jm._type=="ALERT" && act_code=="Escape") return; //-->
    //hacky - but dont allow esc key for ALERT, because it wont satisfy browser restriction for sound to play

    jm._modalClose();

    var cb= jm._cb;
    if (cb) {

      var resp= true;
      if (act_code.search(/Overlay Click|Escape|CANCEL|CLOSE/) > -1) { //multiple ways to "cancel"
        resp= null;
      } else if (jm._type.includes("PROMPT_")) {
        resp= jm._ELs.aliasIO.value;
      } else if (jm._type == "BOOLEAN") {
        resp= (jm._ELs.aliasIO.value == "OK"); //to boolean
      }

      if (typeof(cb) == "object") {
        jm._cbObject(cb, "finish");
        if (cb.end_cb) cb.end_cb(resp);
      } else {
        cb(resp);
      }
    }

    if (jm._queue.length) jm._queue.shift()(); //remove it from queue and then run it as a function!
  }, //_respond


  //jm utils
  _mouseHandler: function(el, clk_cb) { //default is "click", but can cutomize, eg. "Overlay_mousedown"
    var act_str;
    if (typeof(el) == "string") { //'el' param can be a jid str
      [el, act_str]= el.split("_"); //eg. "Overlay" and "mousedown"
      el= jm._ELs[el];
    }
    if (el) el.addEventListener(act_str || "click", clk_cb);
  },

  //'jids' param is a csv string, ._iterEls() splits and iterates
  _displayEls: function(jids, display_v) {
    jm._iterEls(jids, (el, jid) => {
      TMXu.showEl(el, display_v);
      if (display_v && jid.includes("But")) el.textContent= el.$origText; //init-button with orig text
    });
  },

  _classEls: function(jids, class_str, flag= true) {
    jm._iterEls(jids, el => TMXu.classEl(el, class_str, flag) );
  },

  _iterEls: function(jids, itr_cb) {
    var el;
    jids.split(",").forEach(jid => {
      if (el= jm._ELs[jid]) itr_cb(el, jid);
    });
  },

  _modelOpen: function(id) { //open modal by id
    document.body.classList.add("jw-modal-active");
    var el;
    if (el= document.getElementById(id)) el.classList.add("open");
  },
  _modalClose: function() { //close currently open modal
    document.body.classList.remove("jw-modal-active");
    jm._ELs.Overlay.querySelector(".open").classList.remove("open");
  }

  //adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example
}; //jm
jm.init();




//INIT
(() => { //IIFE
  var init_dtO= new Date();
  console.log("INIT", init_dtO.toLocaleString());

  var app_flag= true;
  var dataO;

  TMX.data_load(["plugins", "allowUrlEndpoint", "snooze_num", "timeview_flag"], dO => {
    dataO= dO;
    if (1||       dataO.plugins) { //zzz
      TMXu.loadScript("pennantChase_plugin/pC_plugin.js", () => {
        TMX_init();
      });
    } else {
      TMX_init();
    }
  });

  function TMX_init() {
    //localStorage.allowUrlEndpoint, no app access, set in console
    if (dataO.allowUrlEndpoint) checkUrlEndpoint(window.location.search);

    if (app_flag) {
      var bcDupe_flag;
      var bC= new BroadcastChannel("bc0");
      bC.postMessage("init"); //send
      bC.onmessage= evt => { //receive
        //console.log("bC", evt)
        if (evt.data == "init") bC.postMessage("dupe"); //send
        else if (evt.data == "dupe") bcDupe_flag= true;
      };

      setTimeout(() => { //allow bC to complete

        jm.alert(!bcDupe_flag ? "Click to start" : "TIMECKS is already running in another window or tab, close this tab", () => {
          //will satisfy browser requirement to allow play-sound

          if (bcDupe_flag) {
            window.close();
          } else {
            tmx.snooze_def_num= (dataO.snooze_num || 5) *1; //default 5
            tmx.timeview_def_flag= dataO.timeview_flag == "true"; //true is view-countdown, default is view-time

            TMX.clock_draw();
            TMX.alarmsDrag_init();
            TMX.clock_start();
            TMX.alarms_start();
            TMX.HOOK("init");
          }

        }); //jm.alert()

      }, 100);
    } //app_flag

  } //TMX_init()

  function checkUrlEndpoint(q_str) {
    //this executes in a SEPARATE webpage (browser tab)
    //its a url based endpoint, not really a webpage, self closes
    //import from via url querystring, stores "externalAlarms" in localstorage
    if (!q_str) return; //-->

    var usp= new URLSearchParams(q_str);
    var action_str, external_str;

    findQS("export");  // ?export=5/5 12:34pm|Some Alarm
    if (!action_str) findQS("exportDelete"); //?exportDelete=Some Alarm

    function findQS(act_str) {
      var exp_str= usp.get(act_str);
      if (exp_str) {
        action_str= act_str.replace("export", "external");
        external_str= exp_str;
      }
    }

    if (action_str && external_str) { //"external", "externalDelete"
      app_flag= false;

      external_str= action_str +"|" +external_str;
//console.log("external_str:", external_str);

      TMX.data_load("externalAlarms", dataO => {
//console.log("dataO:", dataO);
        var prevImport_str= dataO.externalAlarms;
        if (prevImport_str) { //allow multiple
          if (prevImport_str.includes(external_str)) external_str= ""; //dupe, ignore
          else external_str= prevImport_str +"\n" +external_str; //append
        }
//console.log("externalAlarms:", external_str);
        if (external_str) {
          TMX.data_save("externalAlarms", external_str, resp => {
            window.close();
          });
        } else window.close();
      }); //TMX.data_load
    }

  } //checkUrlEndpoint()

})(); //IIFE

</script>




<!--dropbox sync --start-->
<!--not regular plugin, TMXu.loadScript only does simple, no-auth loads-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dropbox.js/10.34.0/Dropbox-sdk.min.js" integrity="sha512-PTKs+sPreCz6TLyLj9CYx3LxxPZmY5k1k5Yb5Y5mUQzngf/XUxNdtyWwYjcPcOZJm4wSYiicZr0kotLmDIRFmQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="dropbox_plugin/dBX_plugin.js"></script>
<!--dropbox sync --end-->

</html>
