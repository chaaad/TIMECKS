<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<link rel="icon" href="./favicon.ico"/>

<title>TIMECKS</title>

<link href="https://fonts.cdnfonts.com/css/seven-segment" rel="stylesheet" crossorigin="anonymous">

<style type="text/css">

/*prereq css begin*/
/*https://codepen.io*/
body {
  font-family: "Lato", sans-serif;
  font-size: 100%;
  font-style: normal;
  font-weight: 300;
}
ul {list-style: none; }
/*prereq css end*/

.squareButton {
  color: lightgray;
  background: #eee;
  border-radius: 8px;
  border: 2px solid chartreuse;
  cursor: pointer;
  user-select: none;
  font-size: larger;
  margin: 8px;
  padding: 8px;
  color: gray;

  width: 20px;
  height: 20px;
  text-align: center;

  &:hover {
    background: #ddd;
  }
}

/*adapted from: https://codepen.io/ndeniche/pen/rNPjmg
*/
.closeButton {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 30px;
  float: right;
  margin-left: 8px;
  margin-top: 2px;
  &:hover {
    &::before,
    &::after {
      background: red; /*bgcolor*/
    }
  }
  &::before,
  &::after {
    content: "";
    position: absolute;
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: darkgray; /*bgcolor*/
    border-radius: 5px; /*rounded*/
    height: 6px; margin-top: -3px; /*heavy*/
  }
  &::before {
    transform: rotate(45deg);
  }
  &::after {
    transform: rotate(-45deg);
  }

  &.big { /*test*/
    transform: scale(3);
    background: pink;

  }

  &.small {
    transform: scale(0.66);
  }

} /*closeButton*/


/*adapted from: https://getcssscan.com/css-checkboxes-examples
*/
.checkbox-wrapper-18 {
  position: relative;

  /*timecks.. */
  top: 4px;
  display: inline-block;
  margin-right: 8px;
}
.checkbox-wrapper-18 label {
  background-color: #fff; /*circle*/
  border: 2px solid #ccc;
  border-radius: 50%;
  cursor: pointer;
  height: 28px;
  width: 28px;
  display: block;
}

.checkbox-wrapper-18 label:after {
  border: 2px solid #fff; /*check mark drawn with borders, then rotated*/
  border-top: none;
  border-right: none;
  content: "";
  height: 6px;
  left: 8px;
  opacity: 0;
  position: absolute;
  top: 9px;
  transform: rotate(-45deg);
  width: 12px;
}

.checkbox-wrapper-18 input[type="checkbox"] {
  visibility: hidden;
  display: none;
  opacity: 0;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label {
  background-color: #66bb6a;
  border-color: #66bb6a;
}

.checkbox-wrapper-18 input[type="checkbox"]:checked + label:after {
  opacity: 1;
}
/*checkbox*/

div.textBox {
  max-width: 290px;
  overflow: auto;
  font-size: medium;
  font-weight: 600;
  background: #eee;
  padding: 8px;
  border-radius: 8px;
  margin-bottom: 8px;
  opacity: 90%;
  letter-spacing: 0.5px;
}


div#topButtons {
  position: fixed;

  div {
    line-height: 22px;
  }

  .on {
    color: chartreuse;
  }

  .down {
    background: chartreuse;
  }

  div#trashCan {
    font-size: xx-large;
    line-height: 20px;
    border-color: lightgray;
    cursor: default;
    background: white;

    &.dropTrash {
      background: cyan;
    }
  }
}

div#wakeLockIndicator {
  line-height: 24px;
  position: fixed;
  right: 4px;
  bottom: 4px;
  cursor: default;

  &.on {
    background-color: lightskyblue;
  }
}

div#stgContainer {
  position: fixed;
  left: 58px;
  top: 8px;
  display: none;

  div { /*squareButton*/
    font-size: small;
    font-weight: bolder;
    width: auto;
    padding: 4px;
    padding-bottom: 0;
  }
}

div#msgContainer {
  position: fixed;
  left: 16px;
  top: 220px;
  width: 300px;
  z-index: 4;

  div.msgInstance {
    background: gold;
  }
}

div#templates {
  display: none;
}

div#alarmsContainer {
  float: right;
  font-size: larger;
  padding: 8px;
  position: relative;

  div.alarmInstance {
    margin-bottom: 20px;
    border-radius: 8px;
    transition: background-color 1s ease-out;

    * {
      cursor: pointer;
      user-select: none;
    }

    div.alarmName {

      .PC_tid { /*PennantChase*/
        color: orangered;
      }
    }

    span.alarmActivate {
      color: lightgray;
      margin-right: 0;
    }

    span.alarmEoM {
      color: blue;
      display: inline-block;
      min-width: 8px;
    }

    span.alarmT {
      width: 200px;
      padding: 4px;
      border-radius: 2px;
      opacity: 25%;
      text-align: right;
    }

    span.alarmTime {
      letter-spacing: 2px;
      display: inline-block;
      font: bold 28px "Seven Segment", sans-serif;
      color: greenyellow;
      background: black;
    }

    span.alarmCountdown {
      display: none;
      font-size: larger;
      font-weight: 800;
      color: darkolivegreen;
      opacity: 50%;
      padding-top: 1px; /*compensate for the fonts being slightly diff height*/
    }

    &.soon {
      div.alarmName {
        background: #ddf;
        opacity: 100%;
      }
      span.alarmTime {
        opacity: 50%;
      }
    }

    &.alarmActive {
      div.alarmName {
        background: black;
        color:white;
        opacity: 100%;
      }
      span.alarmActivate {
        color: chartreuse;
      }
      span.alarmTime {
        opacity: 100%;
      }
    }

    /*drag n drop*/
    &.dragging {
      opacity: 0.5;
    }
/*
    &.dropAbove {
      border-top: 100px solid lightcyan;
      border-bottom: "";
    }
    &.dropBelow {
      border-top: "";
      border-bottom: 100px solid lightcyan;
    }
*/
    &.expired {
      background: pink;
    }
  }

  div.disablableContainer {
    div.alarmName {
      color: white;
      background: #666;
      opacity: 100%;
    }

    .soon div.alarmName {
      background: darkblue;
    }

    div.disabledInstance {
      div.alarmName {
        color: gray;
        background: #eee;
      }
    }
  }


  div#activeDiv {
    display: none;
    margin-bottom: 16px;

    div#activeCountdown {}

    div#wakeyDiv {
      display: none;
      margin-top: 16px;

      div#wakeySnoozeBut,
      div#wakeyOffBut {
        width: 100%;
        height:60px;
        line-height:60px;
        text-align: center;
        margin-top: 12px;
        color: white;
        font-weight: bold;
        font-size: 24px;
        border-radius: 8px;
        cursor: pointer;
        opacity: 50%;

        &:hover {
          opacity: 100%;
        }
      }
      div#wakeyOffBut {
        background: #0078d0;
      }
      div#wakeySnoozeBut {
        background: chocolate;

        div { /*snooze numbers*/
          margin-top: -3px; /*weird but works*/
          span {
            color: chocolate;
            cursor: pointer;
            opacity: 50%;

            &:hover {
              opacity: 100%;
            }
          }
        }
      }
    }

    div#wakeySnzCountdown {}
  }

  .countdown {
    text-align: right;
    color:gray;
    margin-top: 8px;
    font-size: larger;
    font-weight: 800;
    color: cornflowerblue;
  }

} /*alarm*/


div#clockFace {
  width: 272px;
  height: 272px;
  background: #FDFAF7;
  border: 12px solid lightgray;
  border-radius: 100%;
  position: absolute;
  left: 30%;
  top: 50%;
  transform: translate(-50%, -50%);
  user-select: none;
  z-index: -1;

  div.hands,
  div.marker {
    position: absolute; top: 50%; left: 50%;
    transform-origin: 50% 50%;
  }

  div.hands::before {
    content: "";
    position: absolute;
    bottom: 50%;
    background: black;
    opacity: 33%;
    border-radius: 3px;
    transform: translateX(-50%);
  }

  div.hands.throt::before {
    background: blue;
  }
  div.hands.slept::before {
    background: red;
  }

  div#minuteHand {
    transition: transform 1s linear;
  }
  div#minuteHand::before {
    width: 6px;
    height: 110px;
  }

  div#hourHand::before {
    width: 10px;
    height: 70px;
  }

  div.marker {
    height: 118%;
    font-size: xx-large;
    color: white;
    &.on {
      color: black;
    }
  }

  div#spindle {
    width: 7px;
    height: 7px;
    background: #FDFAF7;
    border: 2px solid darkgray;
    border-radius: 100%;
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }

  span { /*tickmarks //each span has 2 tickmarks, uses ::before and ::after to create left and right, so only 30*/
    display: block;
    width: 1px;
    height: 95%;
    position: absolute; top: 50%; left: 50%;

    &::before,
    &::after {
      content: "";
      background: #A0A1A4;
      position: absolute;
      left: 0;
      width: 100%;
      height: 10px;
    }
    &::before {
      bottom: 0;
    }
    &::after {
      top: 0;
    }

    &.fives {
      &::after,
      &::before {
        height: 20px
      }
    }
  }


  ul#hourNumbers {
    height: 38%;
    position: absolute;
    bottom: 44%; /*changed (eyeballed) from 50%*/
    left: 50%;

    li {
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 50% 100%;

      i { /*comandeer i*/
        font-style: normal;
        font-weight: bold;
        font-size: 24px;

        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
    }
  }

  h2,
  h3 {
    letter-spacing: 1px;
    font-variant: small-caps;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }
  h2 {
    font-size: 8px;
    top: 29%;
    letter-spacing: 3px;
    font-weight: bold;
  }
  h3 {
    color: darkgray;
    top: 25%;
    font-size: x-large;
  }

  div#dtDisplay {
    font-size: 32px;
    font-weight: bold;
    color: #bbb;
    background: #eee;
    padding: 6px;
    border-radius: 12px;
    text-align: center;
    position: absolute;
    left: 50%;
    bottom: 25%;
    transform: translateX(-50%);

    &.pm {
      color: #eee;
      background: #bbb;
    }
  }

} /*clockface*/


/* MODAL
adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example#styles-css
-------------------------------*/
body.jw-modal-active { /*dont edit this css*/
  overflow: hidden; /* to hide main scrollbar when modal is active */
  div#jwmOverlay {
    display: block;
  }
}

div#jwmOverlay { /*background mask and overall container*/  /*edit this css carefully*/
  display: none; /* modals are hidden by default */
  position: fixed; /* modal container fixed across whole screen */
  inset: 0;
  z-index: 2; /* zindex higher than rest of page, except ringer */
  padding: 40px;
  overflow: auto; /* enables scrolling for tall modals */

  background-color: rgba(0, 0, 0, .75); /* semi-transparent black background exposed by padding */
  transition: background-color 5s;
  &.flash {
    background-color: rgba(255, 127, 127, .75); /*pink*/
  }

  .jw-modal-item { /*modal instance*/
    font-size: larger;
    width: 430px;
    padding: 24px;
    background: #fff;
    margin: 0px auto; /*center horiz*/
    border-radius: 16px;

    .open { /*dont edit this css*/
      display: block;
    }

    &.wide {
      width: auto;
    }

    div#jwmContent {
      margin-top: 8px;
    }

    div#jwmDescription {
      margin-bottom: 12px;
      line-height: 28px;

      b {
        font-weight: 600;
      }

      i {
        color: cornflowerblue;
        &.E {
          color: red;
        }
      }

      p { /*stronger*/
        margin: 0 0 4px 0;
        font-size: x-large;
        font-weight: bold;
        color: #0078d0;

        .i {
          color: darkorange;
        }
      }

      pre {
        line-height: normal;
        margin: 0;
      }

    }
    input#jwmInput {
      margin-bottom: 12px;
      width: 360px;
      font-size: xxx-large;
      padding: 4px;
    }
    textarea#jwmTextarea {
      margin-bottom: 12px;
      width: 360px;
      height: 100px;
      padding: 8px;
      font-size: x-large;
    }

    /*button
    https://getcssscan.com/css-buttons-examples
    button-71
    */
    button {
      background-color: #0078d0;
      border: 0;
      border-radius: 56px;
      color: #fff;
      cursor: pointer;
      display: inline-block;
      font-family: system-ui,-apple-system,system-ui,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",sans-serif;
      font-size: 20px;
      letter-spacing: 1px;
      font-weight: 600;
      outline: 0;
      padding: 16px 21px;
      position: relative;
      text-align: center;
      text-decoration: none;
      transition: all .3s;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      min-width: 160px; /*timecks addition*/
      margin: 12px 24px 12px 0;
    }

    button:before {
      background-color: initial;
      background-image: linear-gradient(#fff 0, rgba(255, 255, 255, 0) 100%);
      border-radius: 125px;
      content: "";
      height: 50%;
      left: 4%;
      opacity: .5;
      position: absolute;
      top: 0;
      transition: all .3s;
      width: 92%;
    }

    button:hover {
      box-shadow: rgba(255, 255, 255, .2) 0 3px 15px inset, rgba(0, 0, 0, .1) 0 3px 5px, rgba(0, 0, 0, .1) 0 10px 13px;
      transform: scale(1.05);
    }

    @media (min-width: 768px) {
      button {
        padding: 16px 48px;
      }
    }
    /*button-71*/

    button.toggleable {
      opacity: 40%
    }
    button.hilite {
      opacity: 100%;
    }

    button#jwmCancelBut {
      background: chocolate;
      opacity: 50%
    }
  }

} /*jwmOverlay*/

</style>
</head>

<body>

<div id="templates">

  <div class="alarmInstance" draggable="true">
    <div class="textBox alarmName" title="Edit Name"></div>
    <span class="alarmActivate squareButton" title="On/Off">‚èπ</span>
    <span class="alarmEoM"></span>
    <span class="alarmT alarmTime" title="Edit time (LONG PRESS to change default view)"></span>
    <span class="alarmT alarmCountdown" title="Edit time (LONG PRESS to change default view)"></span>
    <span class="alarmDeleteBut closeButton" title="Delete"></span>
  </div>

  <div class="textBox msgInstance">
    <span class="msgDeleteBut closeButton small" title="Delete msessage"></span>
    <div class="msgInfo"></div>
  </div>

</div>

<div id="topButtons">
  <div id="editStgsBut" class="squareButton" title="Settings & Info">Ô∏ô</div>
  <div id="diasablerModeBut" class="squareButton" title="Hide-Alarms Mode">H</div>
  <div id="trashCan" class="squareButton" title="Trash (drag&drop unwanted alarm here)">üóë</div>
  <div id="addAlarmBut" class="squareButton" title="Add new alarm">‚úö</div>
</div>

<div id="msgContainer"></div>

<div id="stgContainer">
  <div id="stgdSnzBut" class="squareButton">Default Snooze</div>
  <div id="stgdATVBut" class="squareButton">Default AlarmTime View</div>
  <div id="stgRDatBut" class="squareButton">Alarms raw data</div>
  <div id="stgRdMeBut" class="squareButton">Read Me</div>
</div>

<div id="alarmsContainer">

  <div id="activeDiv">
    <div id="activeCountdown" class="countdown"></div>
    <div id="wakeyDiv">
      <div id="wakeyOffBut" class="button">OFF</div>
      <div id="wakeySnoozeBut" class="button">
        SNOOZE
        <div>
          <span>1</span>
          <span>5</span>
          <span>10</span>
          <span>15</span>
          <span>20</span>
          <span>30</span>
        </div>
      </div>
      <div id="wakeySnzCountdown" class="countdown">&nbsp;</div>
    </div>
  </div>

</div>


<div id="wakeLockIndicator" class="squareButton" title="Wake Lock">üîí</div>


<div id="clockFace">
  <h2>TIMECKS</h2>
  <h3></h3>

  <div id="dtDisplay"></div>

  <ul id="hourNumbers"></ul>

  <div id="minuteHand" class="hands"></div>
  <div id="hourHand" class="hands"></div>
  <div id="spindle"></div>

  <div id="alarmMarker" class="marker">‚Ä¢</div>
</div>


<div id="jwmOverlay">
  <div id="jwmModal" class="jw-modal-item">
    <span id="jwmCloseBut" class="closeButton"></span>
    <div id="jwmContent">
      <div id="jwmDescription"></div>
      <input id="jwmInput"/>
      <textarea id="jwmTextarea"></textarea>
      <button id="jwmOkBut">OK</button>
      <button id="jwmNoBut" class="toggleable">No</button>
      <button id="jwmCancelBut">Cancel</button>
    </div>
  </div>
</div>

</body>

<script>
//clock
//adapted from: https://codepen.io/opheliafl/pen/RaYbvL/

//favicon
//<a href="https://www.freepik.com/icon/alarm-clock_15092469#fromView=keyword&page=1&position=21&uuid=6aee3d4d-c58a-453e-8681-22457f5c0a34">Icon by sonnycandra</a>
//https://realfavicongenerator.net/

var audioClips= {};
init_audio();

function init_audio() {
  var nvO= {
    beep: "426892_7913959",
    bell: "173000_2193194",
    clik: "668985_14100561",
    buzz: "696600_14786418",
    knoc: "425727_760420",
    oops: "124897_1707984",
    rngr: "246332_4486188",
    slam: "421472_3387258",
    trsh: "655617_13805813"
  };
  var val_str;
  Object.keys(nvO).forEach(key => {
    val_str= nvO[key];
    audioClips[key]= new Audio("https://cdn.freesound.org/previews/" +val_str.substring(0, 3) +"/" +val_str +"-lq.mp3");
    //beep= new Audio("https://cdn.freesound.org/previews/426/426892_7913959-lq.mp3")
  });
} //init_audio()

var clockFace_EL= document.querySelector("DIV#clockFace");

var cf_handH_EL= clockFace_EL.querySelector("div#hourHand");
var cf_handM_EL= clockFace_EL.querySelector("div#minuteHand");

var cf_dow_EL= clockFace_EL.querySelector("h3");
var cf_monthDay_EL= clockFace_EL.querySelector("div#dtDisplay");

var cf_marker_EL= clockFace_EL.querySelector("div.marker");
showEl(cf_marker_EL, false);

function clock_draw() {
  var rotate_n= 0;
  for (var i=0; i<30; i++) {
    let span_EL= document.createElement("span");
    if (!(i%5)) span_EL.className= "fives";
    span_EL.style.transform= "translate(-50%,-50%) rotate(" +rotate_n +"deg)";
    clockFace_EL.appendChild(span_EL);
    rotate_n+= 6;
  }

  //createHourNumbers
  rotate_n= 0;
  var hr_n= 12;
  var ul_EL= document.querySelector("UL#hourNumbers");
  for (i=0; i<12; i++) {
    let li_EL= document.createElement("li");
    if (rotate_n) li_EL.style.transform= "rotate(" +rotate_n +"deg)";
    ul_EL.appendChild(li_EL);

    let i_EL= document.createElement("i");
    i_EL.textContent= hr_n;
    if (rotate_n) i_EL.style.transform= "translateX(-50%) rotate(-" +rotate_n +"deg)";
    li_EL.appendChild(i_EL);

    rotate_n+= 30;
    hr_n++;
    if (hr_n > 12) hr_n= 1;
  }
} //clock_draw()


var cf_degO;
var cf_h_inc= 360 /720; //0.5deg
var cf_m_inc= 360 /60; //6deg

var start_dtO;
var clock_hr24;
var clock_elapse_ms; //what we want the time to be, when compared to Date.now() we get sync_diff_ms
var clock_ctdn_m;
var inc_ms= 60000; //default 1 minute (flex)

var clockMarker_n;

function clock_drawHands(o =cf_degO) {
  cf_handH_EL.style.transform= "rotate(" +o.hr +"deg)";
  cf_handM_EL.style.transform= "rotate(" +o.mn +"deg)";
} //clock_drawHands()

function clock_drawSyncHands() { //temp hands positions based on sync_diff_ms, cf_degO uneffected
  var diff_m= sync_diff_ms /60000;
  clock_drawHands({ //draw mn hand at precise mn position (not usual whole mn)
    hr: cf_degO.hr -cf_h_inc *diff_m,
    mn: cf_degO.mn -cf_m_inc *diff_m
  }); //sleep/throttle actually makes mn hand more accurate lol
  if (sync_diff_ms < 0) return; //clock was behind //-->

  //clock was ahead
  setTimeout(() => {
    clock_drawHands(); //now, can draw mn hand at the 'original' whole mn
    classEl(cf_handM_EL, "throt", false);
  }, sync_diff_ms);
} //clock_drawSyncHands()

/*///////////////
var dbg_m, dbg_h;
function dbgdate() {
  var dtO= new Date();
  if (dbg_m) dtO.setMinutes(dtO.getMinutes() +dbg_m);
  if (dbg_h) dtO.setHours(dtO.getHours() +dbg_h);
  return dtO;
}
*////////////////

function clock_start() {
  start_dtO= new Date();
  //start_dtO= dbgdate();

console.log("clock_start", start_dtO.toLocaleTimeString());
  sound_play("oops");

  clock_elapse_ms= start_dtO.getTime();

  clock_hr24= start_dtO.getHours();
  var minutes= start_dtO.getMinutes(); //0-59
  clock_ctdn_m= 60 -minutes; //60-1

  cf_degO= {
    hr: 30 *clock_hr24  +cf_h_inc *minutes,
    mn: cf_m_inc *minutes
  };
  clock_drawHands();

  tzoc_start();

  var minute_ms= start_dtO.getSeconds()*1000 +start_dtO.getMilliseconds();
  var topOfMinute_ms= 60000 -minute_ms;
  setTimeout(() => {
    clock_elapse_ms+= topOfMinute_ms; //inc (1st min)
    clock_advance(); //1st

    mainloop(); //kickoff

    function mainloop() { //self-recursing
      setTimeout(() => {
        clock_elapse_ms+= 60000; //inc (fixed)
        if (clock_advance()) return; //abort mainloop //-->

        data_load("importedAlarm", dataO => {
          var imported_str= dataO.importedAlarm;
          if (imported_str) alarms_import(imported_str);
        });
        //.. like a poll, for "importedAlarm" in localStorage

        mainloop(); //recurse-->

      }, inc_ms);
    } //mainloop()

  }, topOfMinute_ms);

  clock_drawDay(start_dtO);

} //clock_start()

var monthDay_str;
function clock_drawDay(dtO) { //draw am/pm and monthday
  cf_dow_EL.textContent= dtO.toLocaleDateString("en-US", {weekday:"short"}).toUpperCase();
  //eg. "Tue" .. "TUE"
  var month_n= dtO.getMonth();
  monthDay_str= (month_n +1) +"/" +dtO.getDate(); //0-11 (+1), 1-31
  cf_monthDay_EL.textContent= monthDay_str; //monthday
  classEl(cf_monthDay_EL, "pm", clock_hr24>=12); //am/pm
} //clock_drawDay()


var sync_dtO;
var sync_ms;
var sync_diff_ms; //can debug in console

var clock_throt_flag;
var clock_jump_ct= 0;

function clock_advance() { //+1 clock minute
  sync_dtO= new Date(); //topOfMinute
  //sync_dtO= dbgdate();
  sync_ms= sync_dtO.getTime();
  sync_diff_ms= clock_elapse_ms -sync_ms;

  cf_degO.hr+= cf_h_inc;
  cf_degO.mn+= cf_m_inc;

  clock_ctdn_m--; //inc-
  if (clock_ctdn_m < 1) { //top of hr
    clock_ctdn_m= 60; //wrap (reset)
    clock_hr24= (clock_hr24+1) %24; //inc wrap
    cf_degO.mn= 0;

    if (clock_hr24 %12 == 0) { //noon or midnite
      cf_degO.hr= 0;

      var toh_dtO= clock_hr24==0 && sync_diff_ms>0 ? new Date(sync_ms +3600000) : undefined;
      //if midnite, and real time is behind, add 1 hr to toh_dtO (advance day), toh_dtO is just for month/day

      clock_drawDay(toh_dtO || sync_dtO);
      tzoc_check(sync_dtO);
    }
//console.log("TOP OF HR", g_fmatDtO(sync_dtO))
  } //top of hr

  clock_drawHands();

  if (sync_diff_ms) { //not 0

    //post-sleep (possibly throttle?)
    if (sync_diff_ms <= -60000 ) { //very slow, 1 or more minute behind

      if (sync_diff_ms <= -3600000 ) { //extremely slow, 1 or more hour behind
        restart(); //clean
        return "abort_mainloop"; ////-->
        ///////////////////////
      }

      //jump 1 minute
      clock_jump_ct++;  //post-sleep stage 1/3
      clock_elapse_ms+= 60000; //add 1 clock min
      clock_advance(); //.. can be called as many times as necessary to catch up (up to an hour)

    } else if (clock_jump_ct) { //not 0
      if (clock_jump_ct > 0) { //post-sleep stage 2/3
//console.log("clock jumped ahead", clock_jump_ct, "min", g_fmatDtO(sync_dtO), g_fmatSDM()) //debug
        clock_jump_ct= -1; //stage 3
        inc_ms= 60000 +sync_diff_ms; //get back in sync
        classEl(cf_handM_EL, "slept");
        clock_drawSyncHands();
        sound_play("clik", (clock_jump_ct>3 ? 3 : clock_jump_ct), 500);

      } else { //clock_jump_ct == -1 //post-sleep stage 3/3
        inc_ms= 60000; //reest
        clock_jump_ct= 0;
        classEl(cf_handM_EL, "slept", false);
      }


    //post-throttle
    //what happens is that during throttle, the mainloop runs lil slow, so inc_ms goes lower to try to run mainloop quicker
    //when throttle ends, this low inc_ms makes the next sync actually ahead!
    } else if (sync_diff_ms>100 || clock_throt_flag) { //fast (or throt stage 2)
      if (!clock_throt_flag) { //post-throt stage 1/2
//console.log("clock throt", g_fmatDtO(sync_dtO), g_fmatSDM()) //debug
        clock_throt_flag= true; //stage 2
        inc_ms= 60000 +sync_diff_ms; //get back in sync
        classEl(cf_handM_EL, "throt");
        clock_drawSyncHands();
        sound_play("clik", 2, 500);

      } else { //post-throt stage 2/2
        clock_throt_flag= false;
        //classEl(cf_handM_EL, "throt", false);
        inc_ms= 60000; //reset
      }


    //normal
    } else { //tweak inc_ms
      inc_ms+= sync_diff_ms; //tiny swerves, always trying to achieve sync_diff_ms of 0
      if (inc_ms < 1000) inc_ms= 1000; //not too small, nrn
    }

    //when browser throttled, mainloop 'minute' can be slow (over 7 secs seen), also screen rendering paused
    //https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#reasons_for_delays_longer_than_specified

    //when system sleeps, everything stops

//console.log("advanced Clock",  g_fmatDtO(sync_dtO), g_fmatSDM(), inc_ms )
  } //sync_diff_ms

  alarms_minuteUpdate();

} //clock_advance()

function clock_checkMarker() {
  var marker_n= Math.floor(active_ctdn_m /720); //0 1 2+
  if (marker_n > 2) marker_n= 2;
  if (marker_n == clockMarker_n) return; //-->

  if (cf_marker_EL.mkr_val == undefined) { //init
    cf_marker_EL.style.transform= "translate(-50%, -50%) rotate(" +(30*active_hTimO.h +0.5*active_hTimO.m) +"deg)";
  }
  showEl(cf_marker_EL, active_ctdn_m<1440 ? "block" : false); //within 24hrs
  classEl(cf_marker_EL, "on", active_ctdn_m<720); //within 12hrs
  clockMarker_n= marker_n;
} //clock_checkMarker()


function restart() { //post long sleep
  var elapsed_minutes= Math.floor(sync_diff_ms /60000); //negative
  [...aI_NL].forEach(aI_EL  => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in disabler_mode all are visible)
      aI_EL.$D.ctdn_m+= elapsed_minutes; //negative
      if (aI_EL.$D.ctdn_m < 1) alrm_silentExpire(aI_EL);
    } //skip not visible
  });

  clock_start();

  ringer_stop("off"); //if needed
  active_aI_EL= undefined; //allows aa
  alarms_start();
} //restart()


//debug utils (console.log)
function g_fmatDtO(dtO =new Date()) { //formatted time string, eg. "@11:48:22.005" //shows ms
  return "@" +(dtO.getHours()%12||12) +":" +dtO.toISOString().substring(14, 23);
  //.. toISOString(), eg. "2011-10-05T14:48:22.005Z"
} //g_fmatDtO()
function g_fmatSDM() { //formatted sync_diff_ms string, eg. "dif+12"
  var str= "dif";
  if (sync_diff_ms > 0) str+= "+";
  return str +sync_diff_ms;
} //g_fmatSDM()
function aId(aI_EL) { //not really an id, but good for debugging
  if (aI_EL) return aI_EL.$E.Name.textContent +", " +aI_EL.$E.Ctdn.textContent;
} //aId()
function log_aIs(str ="") {
  var arr= [];
  [...aI_NL].forEach(aI_EL  => arr.push(aId(aI_EL)));
  console.log(str, arr)
} //log_aIs()

var body_EL= document.querySelector("body");

var topButs_EL= document.querySelector("div#topButtons");
//var editStgs_EL= topButs_EL.querySelector("div#editStgsBut");
var stgCont_EL= document.querySelector("div#stgContainer");

var disabler_EL= topButs_EL.querySelector("div#diasablerModeBut");
//var add_EL= topButs_EL.querySelector("div#addAlarmBut");
var trash_EL= topButs_EL.querySelector("div#trashCan");

var wakeLock_EL= document.querySelector("div#wakeLockIndicator");

var msgCont_EL= document.querySelector("div#msgContainer");

var templates_EL= document.querySelector("div#templates");
var template_msgInst_EL= templates_EL.querySelector("div.msgInstance");
var template_alarmInst_EL= templates_EL.querySelector("div.alarmInstance");

//alarms
var alarmsCont_EL= document.querySelector("div#alarmsContainer");
var alarmInst_EL;
var active_aI_EL;

var activeDiv_EL= alarmsCont_EL.querySelector("div#activeDiv");
var activeCountdown_EL= activeDiv_EL.querySelector("div#activeCountdown");


var snooze_def_num;
var timeview_def_flag;

document.addEventListener("keyup", evt => { //capture any keyup
  if (!document.body.classList.contains("jw-modal-active")) { //modal inactive
    if (ring_intimerId) { //keys to silence ringer
      if (evt.key == " ") ringer_stop("snooze");
      else if (evt.key.search(/Enter|Escape/) > -1) ringer_stop("off");
    }
  }
});

topButs_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL.id == "editStgsBut") {
    stgs_tog(targ_EL);
  } else if (targ_EL == disabler_EL) {
    disablerMode_toggle();
  } else if (targ_EL.id == "trashCan") {
    trash_clicked();
  } else if (targ_EL.id == "addAlarmBut") {
    alrm_add();
  }
});

stgCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;
  if (targ_EL.id == "stgdSnzBut") {
    stgs_dSnz();
  } else if (targ_EL.id == "stgdATVBut") {
    stgs_dATV();
  } else if (targ_EL.id == "stgRDatBut") {
    stgs_rDat();
  } else if (targ_EL.id == "stgRdMeBut") {
    stgs_rdMe();
  }
});



//create Message Header
var msgHeader_EL= message_add("Messages");
msgHeader_EL.classList.remove("msgInstance"); //no longer a commoner
//msgHeader_EL.style.cssText= "background:slategrey; color:white; ";
showEl(msgHeader_EL, false);

var msgDelAllBut_EL= msgHeader_EL.querySelector("span.msgDeleteBut");
msgDelAllBut_EL.title= "Delete all messages";

//message
msgCont_EL.addEventListener("click", evt => {
  alrmExpChange_flag= false;
  var targ_EL= evt.target;
  if (targ_EL == msgDelAllBut_EL) {
    msgCont_EL.querySelectorAll("div.msgInstance").forEach(m_el => message_remove(m_el));
  } else if (targ_EL.classList.contains("msgDeleteBut")) {
    message_remove(targ_EL.closest("div.msgInstance"));
  }
  if (alrmExpChange_flag) alarms_sort();
});


//long press
var longPress_flag;
var longPress_timerId;

function longPress_timerStop() {
  if (!longPress_timerId) return; //-->

  clearTimeout(longPress_timerId);
  longPress_timerId= undefined;
}

//longpress
alarmsCont_EL.addEventListener("mousedown", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    longPress_timerStop();
    longPress_flag= false;
    longPress_timerId= setTimeout(function() { //startPressTimer
      var c_alarmInst_EL= targ_EL.closest("div.alarmInstance");
      longPress_flag= true; //this will prevent regular click handler
      alarmInst_EL= c_alarmInst_EL;
      alrm_setTorC(alarmInst_EL, !alarmInst_EL.$D.vu_cd, "persist"); //toggle
      sound_play("clik");
      alarms_save();
    }, 1000);
  }
});


//timehover
alarmsCont_EL.addEventListener("mouseover", evt => {
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (aI_EL==active_aI_EL || aI_EL.$D.t_hov) return; //active or already hovered, skip //-->

    alrm_setTorC(aI_EL, !aI_EL.$D.vu_cd); //toggle, but only temporary
    aI_EL.$D.t_hov= true; //hover on
  }
});

alarmsCont_EL.addEventListener("mouseout", evt => {
  //longpress
  longPress_timerStop();

  //timehover
  var targ_EL= evt.target;
  if (targ_EL.classList.contains("alarmT")) {
    var aI_EL= targ_EL.closest("div.alarmInstance");
    if (!aI_EL.$D.t_hov) return; //already unhovered, skip //-->

    alrm_setTorC(aI_EL, aI_EL.$D.vu_cd); //untoggle, was temporary anyway
    aI_EL.$D.t_hov= false; //hover off
  }
});

//alarm //longpress
alarmsCont_EL.addEventListener("dragstart", () => {
  longPress_timerStop();
});

//alarm (for alarmT, longpress)
alarmsCont_EL.addEventListener("click", evt => {
  var targ_EL= evt.target;

  if (targ_EL.closest("div#wakeySnoozeBut")) {
    var n;
    if (targ_EL.tagName == "SPAN") n= targ_EL.textContent *1;
    ringer_stop("snooze", n);

  } else if (targ_EL.closest("div#wakeyOffBut")) {
    ringer_stop("off");

  } else {
    var _alarmInst_EL;
    if (_alarmInst_EL= targ_EL.closest("div.alarmInstance")) {
      alarmInst_EL= _alarmInst_EL;

      if (alarmInst_EL.classList.contains("expired")) {
        var msg_EL= alarmInst_EL.$exp_msg_EL; //alrm_unexpire() will clear .$exp_msg_EL
        alrm_unexpire(alarmInst_EL);
        alarms_sort();
        if (msg_EL) message_remove(msg_EL);
        //expired alarm, so only unexpire it, ignore other commands

      } else if (targ_EL.classList.contains("alarmActivate")) {
        var toggleOff_flag= alarmInst_EL==active_aI_EL;
        if (wakey_aI_EL) {
          ringer_stop("off");
          if (!toggleOff_flag) alrm_activate(alarmInst_EL);
        } else {
          alrm_activate(toggleOff_flag ? false : alarmInst_EL);
        }

      } else if (targ_EL.closest("div.alarmName")) {
        if (targ_EL.classList.contains("PC_tid")) PClink(targ_EL);
        else alrm_editName();

      } else if (targ_EL.classList.contains("alarmT")) {
        longPress_timerStop();
        if (longPress_flag) return; //-->

        alrm_editTime();

      } else if (targ_EL.classList.contains("alarmDeleteBut")) {
        alrm_delete();

      } else if (targ_EL.tagName == "INPUT") { //disabler checkbox (there can only 1 input el in alarmInstance)
        classEl(alarmInst_EL, "disabledInstance", !targ_EL.checked);
        alarms_save();
      }
    }
  }
});


wakeLock_EL.addEventListener("click", wakeLock_set); //toggle //no more toggle, just a msg

//https://developer.chrome.com/blog/new-in-chrome-79/#wake-lock
var wakeLock_OBJ;
async function _wakeLock_on() {
  if (document.hidden) return; //-->
	try {
		wakeLock_OBJ= await navigator.wakeLock.request();
    classEl(wakeLock_EL, "on");

  	wakeLock_OBJ.addEventListener("release", () => {
      sound_play("knoc");
  		wakeLock_OBJ= undefined; //clear global
      classEl(wakeLock_EL, "on", false);
  	});
	} catch (err) {console.log(err.message); }
} //_wakeLock_on()

async function _wakeLock_off() { //note: minimizing of browser, or unfocus of browser tab, will automatically release wakeLock
	if (!wakeLock_OBJ) return; //-->
  try {await wakeLock_OBJ.release(); }
	catch (err) {console.log(err.message); }
} //_wakeLock_off()

function wakeLock_set(flag) { //on, off, click-evt (toggle)
	if (flag=="on") {
    if (!wakeLock_OBJ) _wakeLock_on();
  } else if (flag=="off") {
    if (wakeLock_OBJ) _wakeLock_off();
  } else { //wakeLock button click
    //wakeLock_set(wakeLock_OBJ ? "off" : "on"); //toggle

    //no more toggle, wakeLock became auto, just show msg
    jm.alert("<b>Wake Lock</b> prevents computer from going into sleep mode.<br>However, Wake Lock won't work if this page is hidden.");
  }
} //wakeLock_set()

document.addEventListener("visibilitychange", function() {
  //wakeLock auto
  if (!document.hidden) wakeLock_set("on"); //on "wake" or "show"
  //else (on sleep, browser minimized or tab switch, another window covers this window), do nothing
});

var stg_mode;
function stgs_tog(but_EL) {
  stg_mode= !stg_mode;
  showEl(stgCont_EL, stg_mode ? undefined : false);
  classEl(but_EL, "down", stg_mode);
} //stgs_tog()

function stgs_dSnz(key) {
  jm.prompt("<p>Default Snooze duration</p>(minutes, 1-30)", snooze_def_num, resp => {
    if (resp == null) return; //-->

    var v_num= resp *1;
    if (v_num == snooze_def_num) return; //same, do nothing //-->

    if (isNaN(v_num) || v_num<1 || v_num>30) {
      jm.error('<p class="bad">Snooze must be 1-30 minutes</p>Your input:<i class="E">' +resp +'</i>', () => {
        timecksStgs_edit(); //try again
      });
    } else {
      snooze_def_num= v_num;
      data_save("snooze_num", snooze_def_num);
    }
  }, "highlight");
} //stgs_dSnz()

function stgs_dATV(key) {
  jm.boolean("<p>Default AlarmTime View", timeview_def_flag, {
    //jm custom cb object
    custButText: {OkBut: "Countdown", NoBut: "Time"},
    end_cb: resp => {
      if (resp==null || resp==timeview_def_flag) return; //cancel or same, do nothing //-->
      timeview_def_flag= resp;
      data_save("timeview_flag", timeview_def_flag);
    }
  });
} //stgs_dATV()

function xParseJSON(str) {
  var json_dat;
  try {json_dat= JSON.parse(str); } catch (err) {console.error(err); }
  return json_dat;
}

function stgs_rDat() {
  data_load("alarms", dataO => {
    var json_str= dataO.alarms;
    var json_dat= xParseJSON(json_str);
//console.log("json_dat:", json_dat);
    if (!json_dat) json_str= "";

    jm.prompt_textarea("<p>Alarms raw data (JSON)</p>", json_str, resp => {
      if (resp == null) return; //-->

      json_str= resp;
      json_dat= xParseJSON(json_str);
      if (json_dat) {
        data_save("alarms", json_str);
        alarms_start();
        message_add("Alarms raw data (JSON) saved", "lightblue");
      } else {
        message_add("Saving Alarms raw data (JSON) failed");
      }
    }); //jm.prompt_textarea()

  }); //data_load()
} //stgs_rDat()

function stgs_rdMe() {
  var url_str= "readme.txt";
  txtFile_fetch(url_str, str => {
    if (str) {
      var modal_EL= document.getElementById("jwmModal");
      jm.alert("<p>Read Me</p><pre>" +str +"<pre>", {
        //jm custom cb object
        begin_cb: () => {classEl(modal_EL, "wide"); },
        end_cb: () => {classEl(modal_EL, "wide", false); }
      });

    } else {
      message_add("Reading " +url_str +" failed");
    }
  });
} //stgs_rdMe()

async function txtFile_fetch(url_str, cb) {
  var resp;
  try {
    resp= await fetch(url_str); //no local testing with file:///...
//console.log("resp:", resp);
    if (resp.ok) {
      var str= await resp.text();
      cb(str);
    } else {
      console.error("Fetch error2:", resp.statusText); cb();
    }
  } catch (err) {
    console.error("Fetch error1:", err); cb();
  }
} //txtFile_fetch()

function trash_clicked() {
  jm.alert("You can delete an alarm by Dragging and Dropping it onto the <b>Trash</b> button");
} //trash_clicked()

var activeCountdown_flag;
var active_ctdn_m;
var active_hTimO;

var aI_NL; //from .getElementsByClassName(), dynamic nodeList
var vis_ct;

function alarms_start() {
  disblr_ct= 0;
  vis_ct= 0;
  alarmsCont_EL.innerHTML= ""; //clear container el
  alarmInst_EL= undefined;

  data_load("alarms", dataO => {
    var json_str= dataO.alarms;
    var storedAl_arr= xParseJSON(json_str);
    if (!storedAl_arr) json_str= "";
    if (!storedAl_arr) storedAl_arr= [{t:"12:00 AM"}]; //default if empty

    //storedAl_arr is closest thing to a data model in this app
    //totally temporary, rest of the time, data is solely in the DOM

    storedAl_arr.forEach(a_obj => {
      aInst_EL= template_alarmInst_EL.cloneNode(true); //clone
      alarmsCont_EL.appendChild(aInst_EL); //add
      alrm_addHelpers(aInst_EL, a_obj.id);
      aInst_EL.$E.Name.innerHTML= a_obj.n || ""; //alarm name
      aInst_EL.$E.Time.textContent= a_obj.t; //alarm time
      alrm_initCountdown(aInst_EL);
      if (a_obj.c) alrm_setTorC(aInst_EL, true, "persist"); //init alarm countdown view

      if (disabler_mode) {
        vis_ct++;
        alrm_drawDisablerMode(aInst_EL, a_obj.d); //disabler mode
      } else if (a_obj.d) {
        showEl(aInst_EL, false); //alarm disabled
      } else {
        vis_ct++;
      }
    });

    aI_NL= alarmsCont_EL.getElementsByClassName("alarmInstance");

    alarms_sort();
    wakeLock_set("on");
  });
} //alarms_start()


var disabler_mode;
var disblr_ct; //for css checkbox label to work

function disablerMode_toggle() {
  disabler_mode= !disabler_mode; //toggle
  if (!disabler_mode) { //turn disabler mode off
    active_aI_EL= undefined; //so will auto-activate top alarm (alarms_sort)
  }

  classEl(disabler_EL, "down", disabler_mode);
  classEl(alarmsCont_EL, "disablableContainer", disabler_mode);
  alarms_start();
} //disablerMode_toggle()


function alarmsDrag_init() {
  //dragndrop
  //adapted from: https://www.w3resource.com/javascript-exercises/event/javascript-event-handling-exercise-6.php

  var dragAl_EL;
  var prev_dragOver_EL;

  // Add event listeners for drag and drop events
  alarmsCont_EL.addEventListener("dragstart", dragStart);
  document.addEventListener("dragover", dragOver);
  document.addEventListener("drop", drop); //user can drop anywhere, listening only on dragList doesnt cut it

  //global stop drag
  document.addEventListener("click", evt => {
    if (dragAl_EL) clear("fully");
  }); //recover after a failed drop

  function dragStart(evt) {
    if (dragAl_EL) clear("fully"); //recover after a failed drop

    dragAl_EL= evt.target;
    classEl(dragAl_EL, "dragging");
    //evt.dataTransfer.effectAllowed= "move"; //what does this even do? unnecessary for this reorder functionality

    /* //got rid of alarms manual ordering, so no alarms drag reordering
    var ct= 0;
    [...aI_NL].forEach(aI_EL => {if (aI_EL.checkVisibility()) aI_EL.$D.drag_i= ct++; }); //drag index
    //.. current order, set .drag_i for each alarm
    // .drag_i is only accurate up until the drop, it must be popped upon every dragStart
    */
  } //dragStart()

  function dragOver(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dragOver_EL= evt.target;
    var dragOvAl_EL;

    if (dragOver_EL == trash_EL) { //trash can
      if (dragOver_EL == prev_dragOver_EL) return; //-->

      if (prev_dragOver_EL) clear();
      classEl(dragOver_EL, "dropTrash");

      prev_dragOver_EL= dragOver_EL;

    } else { //not trashcan
      if (prev_dragOver_EL && prev_dragOver_EL == trash_EL) { //trash can
        clear();
        prev_dragOver_EL= undefined;
      }

      /* //got rid of alarms manual ordering, so no alarms drag reordering
      if (dragOvAl_EL= dragOver_EL.closest("div.alarmInstance")) { //alarm instance (reorder)
        if (prev_dragOver_EL) clear();
        if (dragOvAl_EL == dragAl_EL) return; //-->

        //evt.dataTransfer.dropEffect= "move"; //what does this do? unneeded for reorder

        const boundingRect= dragOvAl_EL.getBoundingClientRect();
        const offset_y= boundingRect.y +(boundingRect.height /2);
        if (evt.clientY-offset_y < 0) {
          if (dragOvAl_EL.$D.drag_i-1 != dragAl_EL.$D.drag_i) classEl(dragOvAl_EL, "dropAbove");
        } else {
          if (dragOvAl_EL.$D.drag_i+1 != dragAl_EL.$D.drag_i) classEl(dragOvAl_EL, "dropBelow");
        }

        prev_dragOver_EL= dragOvAl_EL;
      }
      */
    }
  } //dragOver()

  function drop(evt) {
    if (!dragAl_EL) return; //-->

    evt.preventDefault();
    var dropOn_EL= prev_dragOver_EL; //not actual the dropOn_EL, but this allows user to make drop even with imprecise drop
    //.. if user drops outside of window, no drop event at all, accept this fact
    if (dropOn_EL) {
      if (dropOn_EL == trash_EL) {
        alarmInst_EL= dragAl_EL;
        alrm_execDelete();

      /* //got rid of alarms manual ordering, so no alarms drag reordering
      } else if (dropOn_EL.classList.contains("dropAbove") || dropOn_EL.classList.contains("dropBelow")) {

        //move in DOM..
        if (dropOn_EL.classList.contains("dropAbove")) dropOn_EL.before(dragAl_EL);
        else dropOn_EL.after(dragAl_EL);

        if (active_aI_EL) active_aI_EL.after(activeDiv_EL);

        alarms_save();
        */
      }
    }

    clear("fully");
  } //drop()

  function clear(fully_flag) { //if not fully, just clear dragOver's class
    if (prev_dragOver_EL) prev_dragOver_EL.classList.remove("dropAbove", "dropBelow", "dropTrash");
    if (fully_flag) {
      if (dragAl_EL) classEl(dragAl_EL, "dragging", false);
      dragAl_EL= undefined;
      prev_dragOver_EL= undefined;
    }
  } //clear()

  //dragndrop
} //alarmsDrag_init()


function alrm_addHelpers(aI_EL, id) { //.dataset only stores strings
  //breaks html/js laws, but as far as js only goes, an element is just an object
  aI_EL.id= id;

  //because .dataset only stores strings
  aI_EL.$D= {};
  aI_EL.$E= { //pointers to sub els
    Activ: aI_EL.querySelector("span.alarmActivate"),
    Name: aI_EL.querySelector("div.alarmName"),
    Time: aI_EL.querySelector("span.alarmTime"),
    Ctdn: aI_EL.querySelector("span.alarmCountdown"),
    EoM: aI_EL.querySelector("span.alarmEoM")
  };
} //alrm_addHelpers()

function alrm_drawDisablerMode(aI_EL, dsbl_flag) {
  var checked_str= dsbl_flag ? "" : " checked";
  classEl(aI_EL, "disabledInstance", !!dsbl_flag); //in classEl(), flag of undefined will default to true

  aI_EL.$E.Activ.insertAdjacentHTML(
  "afterend",
  `<div class="checkbox-wrapper-18" title="Enable/Disable"><input type="checkbox" id="chkbx_${disblr_ct}"${checked_str}/><label for="chkbx_${disblr_ct}"></label></div>`
  );
  showEl(aI_EL.$E.Activ, false);
  disblr_ct++;
} //alrm_drawDisablerMode()

function alrm_glow(s =1, aI_EL =alarmInst_EL, color_str ="aquamarine") {
  aI_EL.scrollIntoView(scrollParam);

  aI_EL.style.background= color_str;
  setTimeout(() => {aI_EL.style.background= ""; }, s *1000);
} //alrm_glow()

var scrollParam= {behavior:"smooth", block:"center"};

function alrm_scrollTo(noExp_flag) {
  var chosen_EL;
  if (!noExp_flag) chosen_EL= alarmsCont_EL.querySelector("div.expired");
  if (!chosen_EL) chosen_EL= active_aI_EL;
  if (chosen_EL) chosen_EL.scrollIntoView(scrollParam);
} //alrm_scrollTo()


function alrm_editName(NEW_flag) { //if new, NEW_flag is "NEW"
  var name_str= NEW_flag || alarmInst_EL.$E.Name.innerHTML.replaceAll("<br>", "\n"); //autoreplace "<br>"s
  var orig_name_str= name_str;
  var prom_str= "<b>Name</b> for " +(NEW_flag?"new ":"") +'alarm:' +g_promStr(name_str, NEW_flag?"?":"") +'<br>80 chars max, shift-enter for linebreak<br>(html allowed)'
  namePrompt_fn(); //so can be reused as err cb

  function namePrompt_fn() {
    jm.prompt_textarea(prom_str, name_str, resp => {
      if (resp==null || (resp==orig_name_str && !NEW_flag)) return; //-->

      name_str= (resp || "").trim();
      if (name_str.length > 80) {
        jm.error(`<p class="bad">Name length is up to 80 chars</p>Your text is ${name_str.length} chars`, () => {
          namePrompt_fn();
        });
      } else {
        name_str= name_str.replaceAll("\n", "<br>"); //autoreplace "\n"s
        if (NEW_flag) {
          alrm_editTime(name_str || "*"); //so NEW_str not empty
        } else {
          alarmInst_EL.$E.Name.innerHTML= name_str;
          alrm_glow();
          alarms_save();
        }
      }
    }, NEW_flag); //NEW_flag as highlight
  } //namePrompt_fn()

} //alrm_editName()

function alrm_editTime(NEW_str) { //if new, NEW_str is alarm name
  var orig_time_str= NEW_str ? "12:00" : alarmInst_EL.$E.Time.textContent;
  var time_str= orig_time_str;
  var prom_str= "<b>Time</b> for " +(NEW_str?"new ":"") +"alarm:" +g_promStr(NEW_str, time_str);
  timePrompt_fn(); //so can be reused as err fn

  function timePrompt_fn() {
    jm.prompt(prom_str, time_str, {
      //jm custom cb object

      begin_cb: () => {
        livePreview_EL= jm._ELs.Description.querySelector(".livePreview");
        pop_prompt();
      },

      //custom hook
      Input_keyup: evt => { //or "aliasIO_keyup" would work also
        if (time_str != jm._ELs.Input.value) pop_prompt();
        //ignore many unwanted keys like "Shift"
      },

      end_cb: resp => {
        var mod_time_str= resp;
        if (mod_time_str==null || (mod_time_str==orig_time_str && !NEW_str)) return; //-->

        //proc input str
        var alarmNow_obj;
        if (alarmNow_obj= alrm_procTimeText(mod_time_str, timePrompt_fn)) {
          //time_prompt() as err cb (try again)

          if (NEW_str) {
            alrm_execAdd();
            sound_play("bell");
            alarmInst_EL.$E.Name.innerHTML= NEW_str;
          }

          alarmInst_EL.$E.Time.textContent= alarmNow_obj.time;
          alrm_initCountdown();
          if (active_aI_EL == alarmInst_EL) activeCountdown_EL.textContent= alarmInst_EL.$E.Ctdn.textContent;
          alarms_sort([alarmInst_EL]);

          alarms_save();
          alrm_glow(NEW_str ? 4 : 1);
        }
      }
    }, NEW_str); //NEW_str as highlight
  } //time_prompt()

  var livePreview_EL;
  function pop_prompt() {
    time_str= jm._ELs.Input.value;
    var alarmNow_obj= alrm_procTimeText(time_str, "previewLive");
    livePreview_EL.innerHTML= alarmNow_obj ? (alarmNow_obj.time +"<br>" +alarmNow_obj.lpUntil) : "";
  }

} //alrm_editTime()


var DoW_arr= "SUN,MON,TUE,WED,THU,FRI,SAT".split(",");

function alrm_procTimeText(input_str, param) { //returns alarmNow_obj if raw_str is good
  var preview_flag;
  var err_cb;
  if (typeof(param) == "string") preview_flag= param; //'preview' will not alert errors
  else if (typeof(param) == "function") err_cb= param;

  //.. geared toward keypad input, with some shortcuts baked in
  input_str= input_str.trim();
  var raw_str= input_str.toUpperCase();

  var time_dtO= new Date();
  var moDaO;
  if (raw_str.includes("/") || raw_str.search(/^[SMTWF]/)==0) {
    raw_str+= " ";
    let index= raw_str.indexOf(" ");
    let mD_str= raw_str.substring(0, index);
    raw_str= raw_str.substring(index +1);
    if (!raw_str) raw_str= "12"; //default midnite
    moDaO= proc_moDa(mD_str); if (!moDaO) return err("bad month/day or DoW"); //-->
  }

  var time_str;
  var offset_str, offsetMod_str;
  [time_str, offset_str]= raw_str.split(/\+|-/);
  if (offset_str) offsetMod_str= raw_str[time_str.length]; //1 char,  + or -

  var raw_hTimO;
  if (time_str) {
    raw_hTimO= g_procRawTime(time_str);

    if (raw_hTimO.h > 12) return err('bad hour:<i class="E">' +raw_hTimO.h +'"</i>max is 12'); //-->
    if (raw_hTimO.m > 59) return err('bad minute:<i class="E">' +raw_hTimO.m +'</i>max is 59'); //-->

    raw_hTimO.p= time_str.search(/P|\*/) > -1; //chars: P *
    let rawAmPm_flag= raw_hTimO.p || time_str.search(/A/) > -1; //chars: A (AM)

    if (raw_hTimO.h == 0) { //auto-derive hr from now
        let h= time_dtO.getHours(); //0-23
        if (!rawAmPm_flag) raw_hTimO.p= (h >= 12);
        let m= time_dtO.getMinutes();
        if (raw_hTimO.m <= m) { //if rawminutes less than nowminutes, goto next hour
          h++; //inc
          if (h == 24) h= 0; //wrap
          raw_hTimO.h= h;
          proc_24to12(raw_hTimO);
        }
    }

  } else {
    raw_hTimO= {
      h: time_dtO.getHours(), //0-23
      m: time_dtO.getMinutes()
    };
    proc_24to12(raw_hTimO);
  }

  if (moDaO) raw_hTimO.MD= moDaO;

  time_dtO= g_dtO_fromHumanDtO(raw_hTimO);

  var lpUntil_str;

  if (offset_str) {
    var ofsO;
    ofsO= g_procRawTime(offset_str, "offset");
    if (ofsO.h +ofsO.m < 1) return err("0 hour+minute (offset mode)"); //-->

    var time_ms= time_dtO.getTime();
    var sgn_num= offsetMod_str=="+" ? 1 : -1;

    if (ofsO.m) {
      if (ofsO.m > 59) return err(`modifier minutes:<i class="E">${ofsO.m}</i>max is 59`); //-->
      time_ms+= sgn_num *ofsO.m *60000; //60*1000 //modify mns
    }
    if (ofsO.h) {
      let max_h= ofsO.m ? 23 : 24; //max 24 hrs modifier
      if (ofsO.h > max_h) return err(`modifier hours:<i class="E">${ofsO.h}</i>max is ${max_h}`); //-->
      time_ms+= sgn_num *ofsO.h *3600000; //60*60*1000 //modify hrs
    }

    if (preview_flag == "previewLive") {
      lpUntil_str= "(" +get_fmatHTime_str(raw_hTimO);
      lpUntil_str+= " OFFSET";
      lpUntil_str+= offsetMod_str +g_untilStr(ofsO.m, ofsO.h) +")";
    }

    time_dtO= new Date(time_ms);
    //DST handled here by js date ?

    if (moDaO) { //offset can change d/m/y
      moDaO= {
        mo: time_dtO.getMonth() +1,
        da: time_dtO.getDate()
      };
    }
  } //offset_str

  function g_procRawTime(str, offset_flag) {
    var h= m= 0;

    var split_arr= str.split(/:|\./);
    if (split_arr.length > 1) { //contains ":" or ".", explicit hrs and mns
      h= get_nstr(split_arr[0]) *1;
      m= get_nstr(split_arr[1]) *1;

    } else { //special shorthand
      var hm_str= get_nstr(str);
      var L= hm_str.length;
      if (hm_str[0]=="0" || L<=2) { //1-2 digits, or starts with "0"
        if (hm_str[0] == "0") { //starts with "0"
          //minutes mode, eg. "01" is 1 mn, "012" is 12 mns
          //just mns, hr 0
          m= hm_str *1;
        } else { //1-2 digits
          let n= hm_str *1;
          var maxH_n= offset_flag ? 24 : 12;
          if (n <= maxH_n) {
            h= n; //just hr, mn 0
            if (offset_flag && h==24) m= 0;
          } else {
            m= n; //just mn, hr 0
          }
        }
      } else { //3-4 digits
        //.. with "*" for 'pm', eg. 1220 .. 12:20am, or 420* .. 4:20pm
        h= hm_str.substring(0, L -2) *1; //begining, up to last 2 digits
        m= hm_str.substring(L -2) *1; //last 2 digits
      }
    }
    return {h:h, m:m};
  } //g_procRawTime()

  var hTimO= {
    h: time_dtO.getHours(), //0-23
    m: time_dtO.getMinutes()
  };
  proc_24to12(hTimO);
  if (moDaO) hTimO.MD= moDaO;

  //EndofMonth auto-adjust
  if (moDaO && !moDaO.DoW) {
    if (hTimO.MD.da != time_dtO.getDate()) { //days mismatch
      time_dtO.setMonth(hTimO.MD.mo, 0); //no month-1 (so, next month), day 0 is -1 day
      moDaO.EoM= time_dtO.getDate(); //day (eg. for Apr, will be 30)
    }
  }


  //success
  var aNow_obj= {
    hTimO: hTimO,
    time: get_fmatHTime_str(hTimO),
    ms: time_dtO.getTime()
  };


  if (preview_flag=="previewLive" && !lpUntil_str) {
    let diff_ms= time_dtO -new Date(); //ms
    lpUntil_str= `(in: ${g_untilStr(Math.ceil(diff_ms /60000))})`; //ms to minutes
  }

  if (lpUntil_str) {
    if (moDaO && moDaO.EoM) lpUntil_str+= " MonthEnd=" +moDaO.EoM;
    aNow_obj.lpUntil= lpUntil_str;
  }

  return aNow_obj;




  function get_nstr(str) {
    return (str.match(/\d+/) || ["0"])[0]; //gets 'first' number, ignores rest //if none, will return "0"
    //note: "0" is truth-y
  }

  function get_fmatHTime_str(tO) {
    var str= "";
    if (tO.MD) str= (tO.MD.DoW ? tO.MD.DoW : ((tO.MD.mW || tO.MD.mo) +"/" +tO.MD.da)) +" "; //DoW or m/d
    return str +tO.h +":" +String(tO.m).padStart(2, "0")  +(tO.p?" PM":" AM"); //human time
  } //get_fmatHTime_str()

  function proc_24to12(tO) { //to human
    tO.p= tO.h >= 12;
    var h= tO.h;
    if (h > 12) h-= 12;
    else if (h == 0) h= 12;
    tO.h= h;
  }

  function g_dtO_fromHumanDtO(htO) { //from human time 12:59am/pm, to computer time 23:59
    var dtO= new Date(); //dateobj, start as now, but most items will be re-set

    if (htO.MD) {
      if (htO.MD.yr) dtO.setFullYear(htO.MD.yr, htO.MD.mo -1, htO.MD.da); //y //m 0..11 //d 1..31 //near New Year day
      else dtO.setMonth(htO.MD.mo -1, htO.MD.da); //m 0..11 //d 1..31
      //.. dont set month and date separately, because months having diff number of days, mistake can happen
    }

    var h= htO.h;
    if (h == 12) h= 0;
    if (htO.p) h+= 12;
    dtO.setHours(h);

    dtO.setMinutes(htO.m);
    dtO.setSeconds(0);

    var diff_ms= dtO -new Date();
    if (diff_ms < 1) { //if less than nowTime
      //dtO to future
      if (htO.MD) {
        if (htO.MD.DoW) dtO.setDate(dtO.getDate() +7); //+1 week, DayOfWeek
        else if (htO.MD.mW) dtO.setMonth(dtO.getMonth() +1); //+1 month, mon_wildcard_str
        else dtO.setFullYear(dtO.getFullYear() +1); //+1 year, m/d

      } else {
        dtO.setDate(dtO.getDate() +1); //+1 day
      }
      //DST handled here by js date ?
    }

    return dtO;
  } //g_dtO_fromHumanDtO()

  function err(err_str) {
    if (preview_flag) return; //-->

    jm.error('<p class="bad">Alarm time error</p>' +err_str +'<br><br>Your raw input: <i class="E">' +input_str +'</i>', err_cb);
    //multiple errors are not returned, only the first error encountered
  }

  function proc_moDa(mD_str) { //if success, returns obj
    var mon_wildcard_str;
    var DoW_str;
    if (mD_str.includes("/")) { // m/d (month/day)
      var month, day, year;
      [month, day]= mD_str.split("/");

      month*= 1;
      if (isNaN(month) || month<1 || month>12) {
        mon_wildcard_str= "?"; // ?/d (month wildcard)
        month= time_dtO.getMonth() +1; //no month? assume this month
      }

      day*= 1;
      if (isNaN(day) || day<1 || day>31) day= 1; //not verifying against number of days in month

    } else if (mD_str.search(/^[SMTWF]/) == 0) { // DoW (Day of Week)
      var match_arr= [];
      DoW_arr.forEach((str, i) => {if (str.indexOf(mD_str)==0) match_arr.push(i); });
      if (match_arr.length != 1) return; //-->

      var DoW_n= match_arr[0];
      var copy_dtO= new Date(time_dtO); //lets not change time_dtO here
      var DoW_diff_n= DoW_n -copy_dtO.getDay(); //.getDay(), could be called getDoW, returns 0-6 (sun-sat)
      if (DoW_diff_n) copy_dtO.setDate(copy_dtO.getDate() +DoW_diff_n); //getDate() will change month/day correctly

      month= copy_dtO.getMonth() +1;
      day= copy_dtO.getDate(); //.getDate(), could be called getDay, returns 1-31
      var copy_year= copy_dtO.getFullYear();
      if (copy_year != time_dtO.getFullYear()) year= copy_year; //near New Year day

      DoW_str= DoW_arr[DoW_n];

    } else {
      return; //fail //-->
    }

    var o= {
      mo: month,
      da: day
    };
    if (year) o.yr= year;
    if (DoW_str) o.DoW= DoW_str;
    else if (mon_wildcard_str) o.mW= mon_wildcard_str;

    //success
    return o;
  } //proc_moDa()

} //alrm_procTimeText()


function alrm_setTorC(aI_EL, flag, persist_flag) {
  if (aI_EL == active_aI_EL) jm.alert('Default view stored, will be displayed when this is not the active alarm');
  else alrm_setCtdnView(aI_EL, flag);

  if (persist_flag) aI_EL.$D.vu_cd= flag;
} //alrm_setTorC()

function alrm_setCtdnView(aI_EL, flag) {
  showEl(aI_EL.$E.Ctdn, flag ? "inline-block" : false);
  showEl(aI_EL.$E.Time, !flag ? "inline-block" : false);
} //alrm_setCtdnView()

function alrm_initCountdown(aI_EL =alarmInst_EL) {
  var alarmNow_obj= alrm_procTimeText(aI_EL.$E.Time.textContent, "preview");
  if (alarmNow_obj) {
    var ms= alarmNow_obj.ms -new Date();
    if (ms < 60000) ms= 60000; //minimum of 1 minute
    aI_EL.$D.ctdn_m= Math.ceil(ms /60000);
    aI_EL.$E.Ctdn.textContent= g_untilStr(aI_EL.$D.ctdn_m);
    check_soon(aI_EL);

    //EndofMonth display
    var EoM_num= alarmNow_obj.hTimO.MD && alarmNow_obj.hTimO.MD.EoM;
    aI_EL.$E.EoM.textContent= EoM_num ? "‚ú±" :"";
    aI_EL.$E.EoM.title= EoM_num ? "MonthEnd=" +EoM_num : "";
  }
} //alrm_initCountdown()


function alrm_add() { //from UI
  alrm_editName("NEW");
} //alrm_add()

function alrm_execAdd() { //add 1
  var clAlrmInst_EL= template_alarmInst_EL.cloneNode(true); //clone
  alrm_addHelpers(clAlrmInst_EL, alrm_genId());
  alarmsCont_EL.appendChild(clAlrmInst_EL); //add to DOM
  if (disabler_mode) alrm_drawDisablerMode(clAlrmInst_EL);
  alarmInst_EL= clAlrmInst_EL;
  if (timeview_def_flag) alrm_setTorC(alarmInst_EL, true, "persist");
} //alrm_execAdd()

function alrm_genId() { //keeps id values low by utilizing unused "slots"
  var ids_set= new Set(delIds_set); //shallow copy
  [...aI_NL].forEach(aI_EL => {
    ids_set.add(aI_EL.id *1);
  });
  var new_id= 1;
  while (ids_set.has(new_id)) {
    new_id++;
  }
  return new_id;
} //alrm_genId()


function alrm_delete() { //from alarm delete-button
  jm.confirm("<b>Delete</b> alarm:" +g_promStr(), {
    custButText: {OkBut:"Delete"},
    end_cb: resp => {
      if (resp != true) return; //null-->
      alrm_execDelete();
    }
  });
} //deleteAlarm()

function alrm_execDelete() { //from alrm_delete() or drag&drop
  alrm_exeDel();
  alarms_save();
  sound_play("trsh");
} //alrm_execDelete()

delIds_set= new Set(); //alrm_genId() will "reuse" lower ids, this ensures unique ids (per session)

function alrm_exeDel() { //from alrm_execDelete() or alarms_import()
  if (!alarmInst_EL) return; //-->
  alarmInst_EL.remove(); //from DOM
  if (alarmInst_EL == wakey_aI_EL) {
    ringer_stop("off");
  } else if (alarmInst_EL == active_aI_EL) {
    alrm_activate(false);
    alarms_autoActivate();
  }
  delIds_set.add(alarmInst_EL.id *1);
  alarmInst_EL= undefined;
} //alrm_exeDel()


function g_promStr(n_str, t_str) {
  var alStrO;
  if (!n_str || !t_str) alStrO= g_alStrO(alarmInst_EL);
  return `<p>${n_str || alStrO.name}</p>Time:<i class="livePreview">${t_str || alStrO.time}</i>`;
} //g_promStr()

function g_alStrO(aI_EL) {
  var str= aI_EL.$E.Name.innerHTML.replaceAll("<br>", " | ");
  var tmp_doc= new DOMParser().parseFromString(str, 'text/html');
  str= (tmp_doc.body.textContent || "").substring(0, 40);
  return {
    name: str,
    time: aI_EL.$E.Time.textContent
  };
} //g_alStrO()


function alrm_activate(aI_EL) {
//console.trace("alrm_activate:", aId(aI_EL))

  if (active_aI_EL) { //prev active-alarm off
//console.log("prev alarm off? active_aI_EL", aId(active_aI_EL))
    classEl(active_aI_EL, ["alarmActive", "expired", "soon"], false);
    alrm_initCountdown(active_aI_EL);
    alrm_setCtdnView(active_aI_EL, active_aI_EL.$D.vu_cd);
    alrm_glow(4, active_aI_EL, "darkgray");
    sound_play("slam");
  }

  var on_flag= !!aI_EL; //to boolean
  if (on_flag) {
    var alrm_str= aI_EL.$E.Time.textContent;
    var alarmNow_obj= alrm_procTimeText(alrm_str, "preview"); //nrn, final check of alrm_str
    if (!alarmNow_obj) {on_flag= false; message_add("bad alarm time: " +alrm_str +" | " +alStrO.name, "pink"); }
  }

  if (on_flag) { //alarm on
    active_aI_EL= aI_EL;
    activeCountdown_flag= true;
    active_ctdn_m= aI_EL.$D.ctdn_m;
    activeCountdown_EL.textContent= g_untilStr(active_ctdn_m);
    active_hTimO= alarmNow_obj.hTimO;

    classEl(aI_EL, "alarmActive");
    aI_EL.after(activeDiv_EL);
    showEl(activeDiv_EL);
    showEl(activeCountdown_EL);
    alrm_setCtdnView(aI_EL, false); //if needed //shows time

    clockMarker_n= undefined;
    clock_checkMarker();

    sound_play("beep");
    alrm_scrollTo();

  } else { //alarm off
    active_aI_EL= undefined;
    activeCountdown_flag= false;
    active_ctdn_m= 0;

    showEl(activeDiv_EL, false);
    showEl(cf_marker_EL, false);
  }
} //alrm_activate()

function alrm_silentExpire(aI_EL) { //alarm not active, so no ringer
  var alStrO= g_alStrO(aI_EL);
  var msg_EL= message_add("Alarm expired: " +alStrO.time +" | " +alStrO.name, "pink");
  msg_EL.$exp_aI_EL= aI_EL;
  aI_EL.$exp_msg_EL= msg_EL;
} //alrm_silentExpire()


function alarms_minuteUpdate() {
  sysAlarm_check(sync_ms);

  if (!vis_ct) return; //-->

  var until_str;
  [...aI_NL].forEach(aI_EL => {
    if (aI_EL.checkVisibility()) { //skip disabled (fyi, when in disabler_mode all are visible)
      aI_EL.$D.ctdn_m-= 1; //-1 minute
      if (aI_EL==active_aI_EL && activeCountdown_flag) active_ctdn_m= aI_EL.$D.ctdn_m;

      if (aI_EL.$D.ctdn_m <1 ) { //expire
        if (!aI_EL.classList.contains("expired")) { //new expire
          classEl(aI_EL, "expired");
          if (aI_EL != active_aI_EL) alrm_silentExpire(aI_EL);
        }

      } else {
        check_soon(aI_EL);
      }

      until_str= g_untilStr(aI_EL.$D.ctdn_m);
      if (until_str != aI_EL.$E.Ctdn.textContent) aI_EL.$E.Ctdn.textContent= until_str;
      //.. alarms 1+ days, dont need to re-render every minute

    } //visible
  });

  if (activeCountdown_flag) {
    if (active_ctdn_m < 1) { //end active countdown
      activeCountdown_flag= false;
      showEl(activeCountdown_EL, false);
      ringer_start(active_aI_EL);
    } else {
      activeCountdown_EL.textContent= g_untilStr(active_ctdn_m);
      clock_checkMarker();
    }

  } else if (snooze_ctdn_m) {
    snooze_ctdn_m--; //inc-
    snooze_check();
  }
} //alarms_minuteUpdate()

function check_soon(aI_EL) {
  var soon_flag= aI_EL.$D.ctdn_m < 720; //12 hrs, soon
  if (soon_flag != aI_EL.classList.contains("soon")) classEl(aI_EL, "soon", soon_flag);
} //check_soon()

function alarms_sort(aa_override_arr =[]) {
  if (!vis_ct) return; //-->

  sound_play("clik");

  var arr= [...aI_NL];
  arr
    .sort((a, b) => a.$D.ctdn_m -b.$D.ctdn_m)
    .forEach(aI_EL => alarmsCont_EL.appendChild(aI_EL)) //reorder in DOM
  ;

  if (!wakey_aI_EL) alarms_autoActivate(aa_override_arr); //no autoActivate if alarm is ringing/snoozed

  if (active_aI_EL) active_aI_EL.after(activeDiv_EL); //alarm els sorted, move activeDiv_EL under correct alarm el

  alrm_scrollTo();
} //alarms_sort()

function alarms_autoActivate(override_arr =[]) {
  //auto activate top alarm
  var topAI_EL= [...aI_NL].find(aI_EL => aI_EL.checkVisibility() && !aI_EL.classList.contains("expired")); //skip disabled, expired
  if (topAI_EL && topAI_EL!=active_aI_EL && (!active_aI_EL || override_arr.includes(topAI_EL))) {
    //exists      not same                   dont override active, unless its in aa_override_arr
    alrm_activate(topAI_EL);
  }
} //alarms_autoActivate()

function alarms_import(imported_str) {
  //localStorage.setItem("importedAlarm", "");
  data_save("importedAlarm", "");

  var action_str;
  var spl_ar;
  var time_str, tSpl_ar;
  var alarmNow_obj;
  var html_str;
  var k_str; //keeper
  var add_arr= []; //for sound only
  var del_arr= []; //for sound only
  imported_str.split("\n").forEach(item_str => {
    spl_ar= item_str.split("|");
    //external|WED 5/5 12:34pm|PC|New%20York%20Yankees|K|123-1 //to test, can paste right into console "Local storage"
    //0        1               2  3                    4 5
    action_str= spl_ar[0]; //external, externalDelete
//console.log(action_str,"item_str",item_str,"split",spl_ar);
    if (spl_ar[2] == "PC") { //qualify (weakly) as pennantChase
      if (action_str == "external") {
        time_str= spl_ar[1]; //WED 5/5 12:34pm
        tSpl_ar= time_str.split(" ");
        if (alarmNow_obj= alrm_procTimeText(`${tSpl_ar[1]} ${tSpl_ar[2]} -020`, "preview")) { // -20 minutes
          alrm_execAdd();

          k_str= spl_ar[4] ? " (K)" : ""; //keeper league
          html_str= `${tSpl_ar[0]} <br><i>${spl_ar[3]}</i>${k_str} <i class="PC_tid" title="?">${spl_ar[5]}</i>`;
          alarmInst_EL.$E.Name.innerHTML= html_str;

          alarmInst_EL.$E.Time.textContent= alarmNow_obj.time;
          alrm_initCountdown();
          alrm_glow(4);
          add_arr.push(alarmInst_EL); //for sound only
        }

      } else if (action_str == "externalDelete") {
        //externalDelete|123-1|PC
        //0              1   2
        let tid= spl_ar[1];
        let delTid_EL= [...alarmsCont_EL.querySelectorAll("i.PC_tid")]
          .find(EL => EL.textContent == tid)
        ;
//console.log("externalDelete tid",tid, "delTid_EL",delTid_EL) //debug
        if (delTid_EL) { //if multiple alarms with this tid, only 1st alarm deleted //so edge its silly
          del_arr.push(delTid_EL); //for sound only
          alarmInst_EL= delTid_EL.closest("div.alarmInstance");
          alrm_exeDel();
        } else {
          message_add("External-delete of " +tid +" failed");
        }

      } //action_str
    } //PC
  });

  sound_play("bell", add_arr, 1500); //1400, bell is longish clip
  sound_play("trsh", del_arr, 1000);
  //when both add and de, sounds prob mess up

  if (add_arr.length || del_arr.length) {
    alarms_sort(add_arr);
    alarms_save();
  }
} //alarms_import()

function alarms_getDataArr() {
  vis_ct= 0;
  var al_arr= []; //data model, temporary
  if (aI_NL.length) {
    var a_obj;
    var name_str;
    [...aI_NL].forEach(aI_EL => {
      a_obj= {id:aI_EL.id *1, t:aI_EL.$E.Time.textContent}; //id, time
      if (name_str= aI_EL.$E.Name.innerHTML) a_obj.n= name_str;
      if (aI_EL.$D.vu_cd) a_obj.c= 1; //countdown view

      if (disabler_mode ? !aI_EL.querySelector("input").checked : !aI_EL.checkVisibility()) a_obj.d= 1; //disabled
      else vis_ct++;

      al_arr.push(a_obj);
    });
  }
  return al_arr;
} //alarms_getDataArr()

function alarms_save() {
  var saveAl_arr= alarms_getDataArr();
//console.trace("alarms_save",saveAl_arr)
  var json_str= JSON.stringify(saveAl_arr);
  data_save("alarms", json_str);
  if (alarmsSave_hook) alarmsSave_hook(json_str);
} //alarms_save()


var wakeyDiv_EL= document.querySelector("div#wakeyDiv");
var wakeySnoozeBut_EL= wakeyDiv_EL.querySelector("div#wakeySnoozeBut")
var wakeySnzCountdown_EL= wakeyDiv_EL.querySelector("div#wakeySnzCountdown");

var wakey_aI_EL;
var ring_intimerId;
var snooze_ctdn_m;

function ringer_start(aI_EL) {
  if (aI_EL) wakey_aI_EL= aI_EL; //1st ringer_start, as opposed to snooze-end ringer_start

  alrm_scrollTo("noExp");
  sound_play("rngr");

  showEl(wakeyDiv_EL);
  jm._ELs.Overlay.classList.add("flash");
  ring_intimerId= setInterval(() => { //recurse
    jm._ELs.Overlay.classList.toggle("flash");
    sound_play("rngr");
  }, 5000);

  jm.confirm("Alarm ring<p>" +active_aI_EL.$E.Name.textContent +"</p>", {
    //jm custom cb object
    custButText: {OkBut:"OFF", CancelBut:"SNOOZE"},
    end_cb: resp => {
      if (resp) resp= "off"; //true .. "off" //else snooze
      ringer_stop(resp);
    }
  });

} //ringer_start()

//note: for ringer start, if these are 'in progress'...
//longPress, should be ok, process normally
//drag, will be just be an unsuccessful drop
//modal, as if it was 'paused'

function ringer_stop(flag, snooze_n) { //without flag, default is 'snooze'
  if (!wakey_aI_EL) return; //-->

  if (ring_intimerId) {
    clearInterval(ring_intimerId);
    ring_intimerId= undefined;
    jm._ELs.Overlay.classList.remove("flash");
  }

  if (flag == "off") {
    wakey_aI_EL= undefined;
    showEl(activeDiv_EL, false);
    showEl(wakeyDiv_EL, false);
    snooze_ctdn_m= 0; //if needed

    alrm_activate(false);
    alarms_sort();

  } else { //snooze
    //note: snooze wont be exact, since it only checks/fires at top of minute
    //eg. 5 minutes will be 4-5 minutes
    snooze_ctdn_m= snooze_n || snooze_def_num;
    sound_play("knoc");
  }

  snooze_draw(); //if needed
} //ringer_stop()

function snooze_draw() {
  wakeySnzCountdown_EL.innerHTML= snooze_ctdn_m ? g_untilStr(snooze_ctdn_m) : "&nbsp;";
} //snooze_draw()

function snooze_check() {
  snooze_draw();
  if (!snooze_ctdn_m) { //end snooze
    ringer_start();
  }
} //snooze_check()

function g_untilStr(m, h) {
  var str;
  if (m >= 1440) {
   str= Math.floor(m /1440) +"d";

  } else {
    if (h == undefined) {
      if (m > 59) {
        h= Math.floor(m /60);
        m= m %60;
      }
    }
    str= h ? (h +"h") : "";
    if (m) str+= " " +m +"m";
  }

  return str;
} //g_untilStr()


var bC= new BroadcastChannel("bc0");
bC.postMessage("init");

var bC_dupe_flag;
bC.onmessage= evt => {
//console.log("bC", evt)
  if (evt.data == "init") bC.postMessage("dupe");
  else if (evt.data == "dupe") bC_dupe_flag= true;
};


function PClink(tid_EL) { //PennantChase
  var tid= tid_EL.textContent;
  var lgid= tid.split("-")[0];
  var tname= tid_EL.closest("div.alarmName").querySelector("i").textContent; //tree up then down
  //div.alarmName will contain 2 <i>, 1st will be teamname, 2nd will be tid with <i class="PC_tid">
  jm.alert(`PennantChase<br>lg${lgid} <b>${tname}</b> <a href="https://www.pennantchase.com/lgTeamLineup.aspx?tid=${tid}&lgid=${lgid}" target="_blank">Lineup</a>`);
} //PClink()


function message_add(str, bgColor_str) {
  showEl(msgHeader_EL);
  msg_EL= template_msgInst_EL.cloneNode(true); //clone
  msgCont_EL.appendChild(msg_EL); //add
  msg_EL.querySelector("div.msgInfo").innerHTML= str;
  if (bgColor_str) msg_EL.style.background= bgColor_str;
  return msg_EL; //bonus get
} //message_add()

function message_remove(msg_EL) {
  msg_EL.remove();
  if (!msgCont_EL.querySelectorAll("div.msgInstance").length) showEl(msgHeader_EL, false);
  var exp_aI_EL; if (exp_aI_EL= msg_EL.$exp_aI_EL) alrm_unexpire(exp_aI_EL);
} //message_remove()

var alrmExpChange_flag;

function alrm_unexpire(aI_EL) {
  alrmExpChange_flag= true;
  delete aI_EL.$exp_msg_EL;

  if (!aI_EL.closest("div#alarmsContainer")) { //is orphan
    //after an alarms_start() (various ways), this aI_EL is an "orphan" (not in current DOM)
    //reacquire alarm..
    let _aI_EL= alarmsCont_EL.querySelector('[id="' +aI_EL.id +'"]'); //note: els dont have .getElementById()
//console.log("alrm_unexpire, orphan:",aI_EL, "reacquire:",_aI_EL);
    if (_aI_EL) aI_EL= _aI_EL; //reacquired
    else return; //could not reacquire alarm //-->
  }

  classEl(aI_EL, ["expired", "soon"], false);
  alrm_initCountdown(aI_EL);
  alrm_glow(2, aI_EL, "pink");
} //alrm_unexpire()


var sysAlarms_arr= [];
var sysAlarms_lu= {};

function sysAlarm_addOrDel(name_str, ms, handler) {
  var sAO;
  if (ms != undefined) { //add
    sAO= {n:name_str, ms:ms, handler:handler};
    sysAlarms_arr.push(sAO);
    sysAlarms_lu[name_str]= sAO;

  } else { //del
    sAO= sysAlarms_lu[name_str];
    sysAlarms_arr.splice(sysAlarms_arr.indexOf(sAO), 1);
    delete sysAlarms_lu[name_str];
  }
} //sysAlarm_addOrDel()

function sysAlarm_check(ms) {
  if (!sysAlarms_arr.length) return; //-->

  sysAlarms_arr.forEach(sAO => {
    if (ms >= sAO.ms) {
      if (sAO.handler) { //handler goes first
        if (sAO.handler(sAO, ms)) return; //handler can abort sAO removal //-->
      }

      message_add(sAO.n);
      sysAlarm_addOrDel(sAO.n); //delete sysAlarm
    }
  });
} //sysAlarm_check();


var clock_TZ= Intl.DateTimeFormat().resolvedOptions().timeZone;
//timezone change can happen any minute, so not going to check for it, user needs to manually do browser reload
var clock_tzo;
var tzoc_arr;

function tzoc_start() { //runs upon startup
  clockFace_EL.querySelector("div#dtDisplay").title= clock_TZ;

  clock_tzo= start_dtO.getTimezoneOffset();
  var year_n= start_dtO.getFullYear();
  var tzYear_key= clock_TZ +"_" +year_n;
  data_load("tzoc", dataO => proc_tzoc(dataO.tzoc));

  function proc_tzoc(tz_str) {
    if (!tz_str) tz_str= ""; //param default only works if undeined
    var tz_ar= tz_str.split(",");
    if (tz_ar[0] != tzYear_key) { //init (annually if no travel)
      //.. if user never turns off this app, wont reset annually, edge
      var raw_arr= tzoc_getDates(year_n);
//console.log(raw_arr)
      if (raw_arr[0] == year_n) { //nrn
        raw_arr[0]= tzYear_key;

        message_add("Timezone offset changes for " +raw_arr.join(", "));

        tz_str= raw_arr.join(",");
        data_save("tzoc", tz_str);

        tz_ar= raw_arr;
      }
    }

    tzoc_arr= [];
    var alarmNow_obj, ms;
    tz_ar.forEach((str, i) => {
      if (i == 0) { //tzYear_key
        tzoc_arr[0]= str;
      } else {
        alarmNow_obj= alrm_procTimeText(str, "preview");
        ms= alarmNow_obj ? alarmNow_obj.ms : 0;
        tzoc_arr[i]= {t:str, ms:ms};
      }
    });

    tzoc_check(start_dtO);

  } //proc_tzoc()

} //tzoc_start()

function tzoc_check(dtO) { //noon and midnite
  if (tzoc_arr.length <= 1) return; //just tzYear_key, no dateTimes (no daylight savings) //-->

  var now_ms= dtO.getTime();
  var until_ms= now_ms +43200000; //12hr
  var ms;
  tzoc_arr.forEach((tzO, i) => {
    if (i) { //skip 0, tzYear_key
      ms= tzO.ms;
      if (ms >= now_ms && ms <= until_ms) add_sysAlm(tzO); //daylight savings on/off
    }
  });

  function add_sysAlm(tzO) {
    var name_str= "Time zone offset change: " +tzO.t;
    if (sysAlarms_lu[name_str]) return; //skip, already added //-->

    sysAlarm_addOrDel( //add
      name_str,
      tzO.ms,
      function(sAO, ms) { //handler
        var dtO= new Date();
        var tzo= dtO.getTimezoneOffset(); //est 300, dst 240
        var diff_tzo= clock_tzo -tzo; //0, +- 60
        if (!diff_tzo) return "abort_sAO_removal"; //-->
        //.. can happen if clock is slighly ahead
        //.. will try again next minute

        clock_tzo= tzo;
        var diff_hr= Math.sign(diff_tzo); // +- 1

        //https://www.timeanddate.com/time/dst/transition.html
        console.log("TZO change", diff_hr, g_fmatDtO(sync_dtO)); //DST change -1 @3:00:00.013

        //becomes 3am (forward) or 1am (back) ..
        cf_degO.hr+= diff_hr *cf_h_inc *60;
        clock_drawHands();

        clock_hr24= dtO.getHours(); //reset

        sound_play("clik");
      } //handler
    );
  } //add_sysAlm()

} //tzoc_check()

function tzoc_getDates(year_n) { //determine time zone offset changes for current year
  //based on the time/location settings of computer, so should work anywhere
  //generate dates once a year (after new year)
  var arr= [year_n];
  var dtO= new Date(year_n, 0);

  //month: 0-11, 0 indexed
  var first_month_i= 0;
  var last_month_i= 11;
  var ftzo_obj;
  var date_str;

  var first_i= first_month_i;
  var prev_tzo;
  do {
    dtO.setDate(1); dtO.setHours(0); //reset
    ftzo_obj= find_tzoChg(first_i , last_month_i, "setMonth", prev_tzo);
    //note: if tzo changes on and off within a month, we wont catch it, edge or non-issue
    date_str= ftzo_obj ? find_tzoChgInMonth(year_n, ftzo_obj.i) : ""; //date_str also acts as success flag
    if (date_str) {
      arr.push(date_str);
      if (ftzo_obj.i >= last_month_i) {
        date_str= undefined; //break
      } else {
        first_i= ftzo_obj.i +1;
        prev_tzo= ftzo_obj.tzo;
        //next
      }
    }
  } while (date_str)

  return arr;
  //end


  function find_tzoChg(first_i, last_i, dFn_key, prev_tzo) { //note: param 2 is last_i, not .length
    var tzo;
    //Loop through every month of the current year
    for (var i=first_i; i<=last_i; i++) {
      dtO[dFn_key](i); //set month or day
      tzo= dtO.getTimezoneOffset();
//console.log(dFn_key,first_i,i,tzo,dtO)
      if (prev_tzo!=undefined && tzo!=prev_tzo) return {i:i -1, tzo:tzo}; //success //-->
      //.. i -1, change occurs in the previos unit (hr, day, month)

      prev_tzo= tzo;
    }
  } //find_tzoChg()

  function find_tzoChgInMonth(year, month) {
    var ftzo_obj;
    dtO.setMonth(month);
    var daysInMonth= new Date(year, month+1, 0).getDate(); //use the 'next' month, minus 1 day (day 0) //month is 0 indexed, day is 1 indexed
    ftzo_obj= find_tzoChg(1, daysInMonth, "setDate");
    if (!ftzo_obj) return; //-->

    var day= ftzo_obj.i;
    dtO.setDate(day);
    ftzo_obj= find_tzoChg(0, 23, "setHours");
    if (!ftzo_obj) return; //-->

    var hour= ftzo_obj.i;

    //to human read
    month++;
    hour++;
    var amPm_str= hour>=12 ? "PM" : "AM";
    hour= hour%12;
    if (hour == 0) hour= 12;
    return month +"/" +day +" " +hour +":00" +amPm_str;
  } //find_tzoChgInMonth()

} //tzoc_getDates()



function data_load(key, cb) {
  var keys_arr= Array.isArray(key) ? key : [key];
  var dataO= {};
  keys_arr.forEach(k => dataO[k]= localStorage.getItem(k) );
//console.log("load LS", key, "dataO", dataO);
  if (cb) cb(dataO);
} //data_load()

function data_save(key, data, cb) { //can only save 1 item per call
  //.. note: alarms is always all alarms, no such thing as saving 1 alarm
  localStorage.setItem(key, data);
//console.log("save LS", key, "data", data);
  if (cb) cb("set");
} //data_save()

/*
//localStorage doesnt have 'getKeys'
function getAllLocalStorageKeys() {
  const keys = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    keys.push(key);
  }
  return keys;
}
const allKeys = getAllLocalStorageKeys();
console.log(allKeys);
*/


function sound_play(ac_key, repeat_n =1, step_ms =750) {
  if (typeof(repeat_n) == "object") repeat_n= repeat_n.length; //repeat_n. passed in an arr
  if (!repeat_n) return; //-->

  if (repeat_n == 1) {
    audioClips[ac_key].play();
    return; //-->
  }

  var ct= 0;
  step_play(); //kickoff

  function step_play() {
    audioClips[ac_key].play();
    ct++;
    if (ct < repeat_n) setTimeout(step_play, step_ms); //recurse //-->
  }
} //sound_play()

//utils
function showEl(el, display_str ="block") {
  //showEl(el) //on
  //showEl(el, falsy) //off
  //showEl(el, "inline") //on, other than "block"
  if (el) el.style.display= display_str==false ? "none" : display_str;
}
function classEl(el, class_param, flag =true) { //class_param can be string or array
  if (!el) return; //-->
  if (Array.isArray(class_param)) el.classList[flag?"add":"remove"](...class_param);
  else el.classList[flag?"add":"remove"](class_param);
}




//jm (modal)
var jm= {
  _ELs: {},
  _type: 0,
  _queue: [],

  init: function() {
    //pop jm._ELs (aliasIO is dynamically assigned)
    var el, jid;
    "div#jwmOverlay, span#jwmCloseBut, div#jwmDescription, input#jwmInput, textarea#jwmTextarea, button#jwmOkBut, button#jwmNoBut, button#jwmCancelBut".split(", ").forEach(sel_str => {
      el= document.querySelector(sel_str);
      jid= sel_str.split("#")[1].replace("jwm", ""); //basically, jid is the element id with the "jwm" removed
      jm._ELs[jid]= el;
      if (jid.includes("But")) el.$origText= el.textContent; //for init-button
    });

    //modal handlers
    document.addEventListener("keyup", evt => { //capture any keyup
      if (document.body.classList.contains("jw-modal-active")) { //modal active
        if (evt.key=="Escape" || (evt.key=="Enter" && !evt.shiftKey)) jm._respond(evt.key);
        //since modal can contain textarea, no 'nav' keys should be captured (arrow, tab)
        //also shift-enter allows linebreak in textarea
        else if (jm._type == "BOOLEAN") jm._booleanKeystroke(evt.key); //however, this does do 'nav' keys
      }
    });

    jm._mouseHandler("Textarea_keydown", evt => { //linebreak in textarea, prevent enter key (use shift-enter)
      if (evt.key=="Enter" && !evt.shiftKey) evt.preventDefault();
    });

    jm._mouseHandler("Overlay_mousedown", evt => { //"click" can get accidental "click"
      if (evt.target == jm._ELs.Overlay) jm._respond("Overlay Click"); //closeModal
    });

    jm._mouseHandler("OkBut", evt => {
      if (jm._type == "BOOLEAN") jm._ELs.aliasIO.value= "OK";
      jm._respond();
    });

    jm._mouseHandler("NoBut", evt => {
      jm._ELs.aliasIO.value= "NO";
      jm._respond();
    });

    jm._mouseHandler("CancelBut", evt => {
      jm._respond("CANCEL");
    });

    jm._mouseHandler("CloseBut", evt => {
      jm._respond("CLOSE");
    });

  }, //init()

  dialog: function(type_str, text_str, value_str, cb, highlight_flag) { //ck, non blocking modal
    //all types can have cb (callback)

    if (document.body.classList.contains("jw-modal-active")) { //modal active
      jm._queue.push(
        () => { //anon fn that stores function call (w vargs) to be used later
          jm.dialog(type_str, text_str, value_str, cb);
        }
      );
      return; //abort //-->
    }

    jm._ELs.aliasIO= jm._ELs.Input; //default, .Input

    jm._displayEls("Input,Textarea,NoBut,CancelBut", false);
    jm._displayEls("OkBut", "inline"); //OkBut already displayed, but needs init-button
    jm._classEls("OkBut", "toggleable", false);
    jm._classEls("OkBut,NoBut", "hilite", false);

    if (typeHas(/ALERT|ERROR|CONFIRM|BOOLEAN/)) {
      jm._ELs.aliasIO.value= "OK"; //default

      if (typeHas("BOOLEAN")) {
        jm._displayEls("NoBut,CancelBut", "inline");
        jm._classEls("OkBut", "toggleable");
        jm._ELs.OkBut.textContent= "Yes"; //was "OK"
        var state_flag= !!value_str; //to boolean
        //.. local var
        if (!state_flag) jm._ELs.aliasIO.value= "NO";
        //.. actual value kept in aliasIO.value as string ("OK", "NO")
        jm._booleanKeystroke(); //hilte only

      } else if (typeHas("CONFIRM")) { //CONFIRM is just an ALERT with a Cancel button
        jm._displayEls("CancelBut", "inline");

      } else if (typeHas("ERROR")) sound_play("buzz");

    //} else if (type_str.search(/PROMPT$|PROMPT_TEXTAREA/) > -1) {
    } else if (typeHas("PROMPT_")) {
      if (typeHas("PROMPT_TEXTAREA")) jm._ELs.aliasIO= jm._ELs.Textarea; //.Textarea

      jm._ELs.aliasIO.value= value_str;

      jm._displayEls("aliasIO");
      jm._displayEls("CancelBut", "inline");

    } else {
      console.error("jm.dialog, bad type_str:", type_str);
      return; //-->
    }

    function typeHas(v) { //v can be string or regEx
      return (typeof(v)=="string" ? type_str.indexOf(v) : type_str.search(v)) > -1;
    }

    jm._type= type_str;
    jm._ELs.Description.innerHTML= text_str;

    if (cb) {
      if (typeof(cb) == "object") { //custom hooks object

        if (cb.begin_cb && typeof(cb.begin_cb)=="function") {
          if (cb.begin_cb() == false) return; //caller can abort //-->
        }

        jm._cbObject(cb, true); //true, add listeners

      } else if (typeof(cb) != "function") { //otherwise should a fn (that is the 'end' callback)
        cb= undefined; //error, no message
      }
    }
    jm._cb= cb;

    if (typeHas("BOOLEAN")) {
      jm.bool_kc0= jm._ELs.NoBut.textContent[0]; //1st char, "No" .. "N"
      jm.bool_kc1= jm._ELs.OkBut.textContent[0]; //1st char, "Yes" .. "Y"
      //note: only boolean accepts button-first-letter keystrokes
      if (jm.bool_kc0 == jm.bool_kc1) { //need different keystrokes
        jm.bool_kc0= undefined;
        jm.bool_kc1= undefined;
      }
      //needed by _booleanKeystroke()
    }

    jm.openModal("jwmModal");

    //modal needs to be visible to .focus() or .select()
    if (typeHas("PROMPT_")) {
      //note: textareas, if text is highlighted, any key (except enter-key) will delete the text!
      //note: enter-key always submits (custom)
      if (highlight_flag) jm._ELs.aliasIO.select();
      else jm._ELs.aliasIO.focus();
    }
  },

  alert: function(text_str, cb) {
    jm.dialog("ALERT", text_str, "", cb); //returns true or null
  },
  error: function(text_str, cb) {
    jm.dialog("ERROR", '<p class="bad">' +text_str +'</p>', "", cb); //returns true or null
  },

  confirm: function(text_str, cb) {
    jm.dialog("CONFIRM", text_str, "", cb); //returns true or null
  },

  boolean: function(text_str, value_flag, cb) {
    jm.dialog("BOOLEAN", text_str, value_flag, cb); //returns true or false or null
    //param called value_flag here, but jm.dialog will still call it value_str
  },

  prompt: function(text_str, value_str, cb, highlight_flag) {
    jm.dialog("PROMPT_INPUT", text_str, value_str, cb, highlight_flag); //returns string or null
  },
  prompt_textarea: function(text_str, value_str, cb, highlight_flag) {
    jm.dialog("PROMPT_TEXTAREA", text_str, value_str, cb, highlight_flag); //returns string or null
  },

  _booleanKeystroke: function(key) {
    //boolean dialogs have 3 buttons, Yes, No and Cancel
    //they are highlightable by nav keys, and is submittable by shortcut key (Y/N)
    var state_flag= jm._ELs.aliasIO.value == "OK"; //local var
    var submit_flag;

    if (key) { //key capture
      key= key.toUpperCase();
      if (key==jm.bool_kc1 || key==jm.bool_kc0) { //"Y" or "N"
        state_flag= value= key==jm.bool_kc1; //"Y"
        submit_flag= true;
      } else if (key.indexOf("ARROW") == 0) {
        state_flag= !state_flag; //toggle
      }
      jm._ELs.aliasIO.value= state_flag ? "OK" : "NO";
    }

    //highlight Y/N Button
    liteBut("OkBut", state_flag);
    liteBut("NoBut", !state_flag);
    function liteBut(jid, flag) {
      classEl(jm._ELs[jid], "hilite", flag);
    }

    if (submit_flag) jm._respond(); //btw, closes modal
  },

  _respond: function(act_code ="") {
    if (jm._type=="ALERT" && act_code=="Escape") return; //-->
    //hacky - but dont allow esc key for ALERT, because it wont satisfy browser restriction for sound to play

    jm.closeModal();

    var cb= jm._cb;
    if (cb) {

      var resp= true;
      if (act_code.search(/Overlay Click|Escape|CANCEL|CLOSE/) > -1) { //multiple ways to "cancel"
        resp= null;
      } else if (jm._type.includes("PROMPT_")) {
        resp= jm._ELs.aliasIO.value;
      } else if (jm._type == "BOOLEAN") {
        resp= (jm._ELs.aliasIO.value == "OK"); //to boolean
      }

      if (typeof(cb) == "object") {
        jm._cbObject(cb, false); //false, remove listeners
        if (cb.end_cb) cb.end_cb(resp);
      } else {
        cb(resp);
      }
    }

    if (jm._queue.length) jm._queue.shift()(); //remove it from queue and then run it as a function!
  }, //_respond

  _cbObject: function(cbO, add_flag) { //add_flag, true for begin / false for end
    var jid, el, evt_key;
    Object.keys(cbO).forEach(c_code => {
      if (c_code=="custButText" && add_flag) {
        var but_hash= cbO[c_code];
        if (typeof(but_hash) == "object") { //eg. {CancelBut: "SNOOZE"}
          Object.keys(but_hash).forEach(b_key => {
            if (el= jm._ELs[b_key]) el.textContent= but_hash[b_key];
          });
        }

      } else { //custom hooks
        [jid, evt_key]= c_code.split("_");
        if (evt_key) {
          if (el= jm._ELs[jid]) {
            if (add_flag) el.addEventListener(evt_key, cbO[c_code]);
            else el.removeEventListener(evt_key, cbO[c_code]);
          }
        }
      }
    });

    //c_code
      //custButText
      //begin_cb, returns nothing
      //end_cb, returns resp
      //(custom hooks, handler on any event on any jm._ELs item, returns event)
        //eg. "Input_keyup" is 'keyup' event on input#jwmInput
        //eg. "OkBut_mouseover" is 'mouseover' event on button#jwmOkBut

  }, //_cbObject

  //jm utils
  _mouseHandler: function(el, clk_cb) { //default is "click", but can cutomize, eg. "Overlay_mousedown"
    var act_str;
    if (typeof(el) == "string") { //'el' param can be a jid str
      [el, act_str]= el.split("_"); //eg. "Overlay" and "mousedown"
      el= jm._ELs[el];
    }
    if (el) el.addEventListener(act_str || "click", clk_cb);
  },

  //'jids' param is a csv string, ._iterEls() splits and iterates
  _displayEls: function(jids, display_v) {
    jm._iterEls(jids, (el, jid) => {
      showEl(el, display_v);
      if (display_v && jid.includes("But")) el.textContent= el.$origText; //init-button with orig text
    });
  },

  _classEls: function(jids, class_str, flag= true) {
    jm._iterEls(jids, el => classEl(el, class_str, flag) );
  },

  _iterEls: function(jids, itr_cb) {
    var el;
    jids.split(",").forEach(jid => {
      if (el= jm._ELs[jid]) itr_cb(el, jid);
    });
  },

  //adapted from: https://jasonwatmore.com/post/2023/01/04/vanilla-js-css-modal-popup-dialog-tutorial-with-example
  openModal: function(id) { //open modal by id
    document.body.classList.add("jw-modal-active");
    var el;
    if (el= document.getElementById(id)) el.classList.add("open");
  },
  closeModal: function() { //close currently open modal
    document.body.classList.remove("jw-modal-active");
    jm._ELs.Overlay.querySelector(".open").classList.remove("open");
  }
}; //jm
jm.init();




//INIT
var init_dtO= new Date();
console.log("INIT", init_dtO.toLocaleString());

var fClick_flag= true;
alarms_urlImport(window.location.search);
if (fClick_flag) { //satisfy browser requirement to allow play-sound

  data_load(["snooze_num", "timeview_flag"], dataO => {
    snooze_def_num= (dataO.snooze_num || 5) *1; //default 5
    timeview_def_flag= dataO.timeview_flag == "true"; //true is view-countdown, default is view-time
  });

  setTimeout(() => {
    jm.alert(bC_dupe_flag ? "TIMECKS is already running in another window or tab, close this tab" : "Click to start", () => {
      if (bC_dupe_flag) {
        window.close();
      } else {
        clock_draw();
        alarmsDrag_init();
        clock_start();
        alarms_start();
      }
    });
  }, 100); //allow 1st data_load and bC to complete
}


function alarms_urlImport(q_str) { //import from via url querystring, stores "importedAlarm" in localstorage
  //.. this is a url based endpoint, not really a webpage, self closes
  if (!q_str) return; //-->

  var usp= new URLSearchParams(q_str);
  var action_str, external_str;

  //for local testing// file:///C:/Users/chaaad/Documents/GitHub/TIMECKS/index.htm
  findQS("export");  // ?export=WED 5/5 12:34pm|PC|New%20York%20Yankees|K|123-1
  findQS("exportDelete"); //?exportDelete=123-1|PC

  function findQS(act_str) {
    var exp_str= usp.get(act_str);
    if (exp_str) {
      var split_arr= exp_str.split("|");
      if (split_arr[1] == "PC") {
        //.. qualify //only PC can import
        action_str= act_str.replace("export", "external");
        external_str= exp_str;
      }
    }
  }

  if (action_str && external_str) {
    fClick_flag= false;

    external_str= action_str +"|" +external_str;
//console.log("external_str:", external_str);

    data_load("importedAlarm", dataO => {
//console.log("dataO:", dataO);
      var prevImport_str= dataO.importedAlarm;
      if (prevImport_str) { //allow multiple
        if (prevImport_str.includes(external_str)) external_str= ""; //dupe, ignore
        else external_str= prevImport_str +"\n" +external_str; //append
      }
//console.log("data_save? importedAlarm:", external_str);
      if (external_str) {
        data_save("importedAlarm", external_str, resp => {
          window.close();
        });
      } else window.close();
    }); //data_load
  }

} //alarms_urlImport()


</script>

<script src="dropbox_plugin/dBX_plugin.js"></script>

</html>
